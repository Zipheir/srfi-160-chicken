== SRFI-160: Homogeneous numeric vector libraries
=== Abstract
This SRFI describes a set of operations on [[https://srfi.schemers.org/srfi-4/srfi-4.html|SRFI 4]] homogeneous vector types (plus a few additional types) that are closely analogous to the vector operations library, [[https://srfi.schemers.org/srfi-133/srfi-133.html|SRFI 133]]. An external representation is specified which may be supported by the read and write procedures and by the program parser so that programs can contain references to literal homogeneous vectors.

For more information see:  [[https://srfi.schemers.org/srfi-160/|SRFI-160: Homogeneous numeric vector libraries]]
=== Rationale
Like lists, Scheme vectors are a heterogeneous datatype which impose no restriction on the type of the elements. This generality is not needed for applications where all the elements are of the same type. The use of Scheme vectors is not ideal for such applications because, in the absence of a compiler with a fancy static analysis, the representation will typically use some form of boxing of the elements which means low space efficiency and slower access to the elements. Moreover, homogeneous vectors are convenient for interfacing with low-level libraries (e.g. binary block I/O) and to interface with foreign languages which support homogeneous vectors. Finally, the use of homogeneous vectors allows certain errors to be caught earlier.

This SRFI specifies a set of homogeneous vector datatypes which cover the most practical cases, that is where the type of the elements is numeric (exact integer or inexact real or complex) and the precision and representation is efficiently implemented on the hardware of most current computer architectures (8, 16, 32 and 64 bit integers, either signed or unsigned, and 32 and 64 bit floating point numbers).

This SRFI extends SRFI 4 by providing the additional {{c64vector}} and {{c128vector}} types, and by providing analogues for almost all of the heterogeneous vector procedures of SRFI 133. There are some additional procedures, most of which are closely analogous to the string procedures of [[https://srfi.schemers.org/srfi-152/srfi-152.html|SRFI 152]].

Note that there are no conversions between homogeneous vectors and strings in this SRFI. In addition, there is no support for u1vectors (bitvectors) provided, not because they are not useful, but because they are different enough in both specification and implementation to be put into a future SRFI of their own.
=== Specification
There are eight datatypes of exact integer homogeneous vectors (which will be called integer vectors):

* s8vector: signed exact integer in the range -2^7 to 2^7-1
* u8vector: unsigned exact integer in the range 0 to 2^8-1
* s16vector: signed exact integer in the range -2^15 to 2^15-1
* u16vector: unsigned exact integer in the range 0 to 2^16-1
* s32vector: signed exact integer in the range -2^31 to 2^31-1
* u32vector: unsigned exact integer in the range 0 to 2^32-1
* s64vector: signed exact integer in the range -2^63 to 2^63-1
* u64vector: unsigned exact integer in the range 0 to 2^64-1

All are part of SRFI 4.

There are two datatypes of inexact real homogeneous vectors (which will be called ''float vectors''):

* f32vector: inexact real, typically 32 bits
* f64vector: inexact real, typically 64 bits

These are also part of SRFI 4.

{{f64vectors}} must preserve at least as much precision and range as {{f32vectors}}. (See the implementation section for details.)

And there are two datatypes of inexact complex homogeneous vectors (which will be called complex vectors):

<type>c64vector</type>

inexact complex, typically 64 bits

<type>c128vector</type>

inexact complex, typically 128 bits

These are not part of SRFI 4.

{{c128vectors}} must preserve at least as much precision and range as {{c64vectors}}. (See the implementation section for details.)

A Scheme system that conforms to this SRFI does not have to support all of these homogeneous vector datatypes. However, a Scheme system must support float vectors if it supports Scheme inexact reals (of any precision). A Scheme system must support complex vectors if it supports Scheme inexact complex numbers (of any precision). Finally, a Scheme system must support a particular integer vector datatype if the system's exact integer datatype contains all the values that can be stored in such an integer vector. Thus a Scheme system with bignum support must implement all the integer vector datatypes, but a Scheme system might only support {{s8vectors}}, {{u8vectors}}, {{s16vectors}} and u16vectors if it only supports integers in the range -2^29 to 2^29-1 (which would be the case if they are represented as 32-bit machine integers with a 2-bit tag).

Scheme systems which conform to this SRFI and also conform to either R6RS or R7RS should use the same datatype for {{bytevectors}} and for {{u8vectors}}, and systems that also implement [[https://srfi.schemers.org/srfi-74/|SRFI 74]] (blobs) should use the same datatype for them as well. All other homogeneous vector types are disjoint from each other and from all other Scheme types,

Each element of a homogeneous vector must be valid. That is, for an integer vector, it must be an exact integer within the inclusive range specified above; for a float vector, it must be an inexact real number; and for a complex vector, it must be an inexact complex number. It is an error to try to use a constructor or mutator to set an element to an invalid value.
=== Notation
So as not to multiply the number of procedures described in this SRFI beyond necessity, a special notational convention is used. The description of the procedure make-@vector is really shorthand for the descriptions of the twelve procedures {{make-s8vector}}, {{make-u8vector}}, ... {{make-c128vector}}, all of which are exactly the same except that they construct different homogeneous vector types. Furthermore, except as otherwise noted, the semantics of each procedure are those of the corresponding SRFI 133 procedure, except that it is an error to attempt to insert an invalid value into a homogeneous vector. Consequently, only a brief description of each procedure is given, and SRFI 133 (or in some cases SRFI 152) should be consulted for the details. It is worth mentioning, however, that all the procedures that return one or more vectors (homogeneous or heterogeneous) invariably return newly allocated vectors specifically.

In the section containing specifications of procedures, the following notation is used to specify parameters and return values:

<procedure>(f arg[1] arg[2] ...) -> something</procedure>

A procedure {{f}} that takes the parameters {{arg[1] arg[2] ...}} and returns a value of the type something. If two values are returned, two types are specified. If something is unspecified, then {{f}} returns a single implementation-dependent value; this SRFI does not specify what it returns, and in order to write portable code, the return value should be ignored.

<parameter>vec</parameter>

Must be a heterogeneous vector, i.e. it must satisfy the predicate vector?.

<parameter>@vec</parameter>

<parameter>@to</parameter>

<parameter>@from</parameter>

Must be a homogeneous vector, i.e. it must satisfy the predicate {{@vector?}}. In {{@vector-copy!}} and {{reverse-@vector-copy!}}, {{@to}} is the destination and {{@from}} is the source.

<parameter>i</parameter>

<parameter>j</parameter>

<parameter>start</parameter>

<parameter>at</parameter>

Must be an exact nonnegative integer less than the length of the {{@vector}}. In {{@vector-copy!}} and {{reverse-@vector-copy!}}, at refers to the destination and {{start}} to the source.

<parameter>end</parameter>

Must be an exact nonnegative integer not less than {{start}} and not greater than the length of the vector. This indicates the index directly before which traversal will stop -- processing will occur until the index of the vector is one less than {{end}}. It is the open right side of a range.

<parameter>f</parameter>

Must be a procedure taking one or more arguments, which returns (except as noted otherwise) exactly one value.

<parameter>pred</parameter>

Must be a procedure taking one or more arguments that returns one value, which is treated as a boolean.

<parameter>=</parameter>

Must be an equivalence procedure.

<parameter>obj</parameter>

<parameter>seed</parameter>

<parameter>knil</parameter>

Any Scheme object.

<parameter>fill</parameter>

<parameter>value</parameter>

Any number that is valid with respect to the {{@vec}}.

<parameter>[something]</parameter>

An optional argument; it needn't necessarily be applied. Something needn't necessarily be one thing; for example, this usage of it is perfectly valid:

 [start [end]]

and is indeed used quite often.

<parameter>something ...</parameter>

Zero or more somethings are allowed to be arguments.

<parameter>something[1] something[2] ...</parameter>

At least one something must be arguments.
=== Packaging
For each {{@vector}} type, there is a corresponding library named (srfi 160 @), and if an implementation provides a given type, it must provide that library as well. In addition, the library (srfi 160 base) provides a few basic procedures for all {{@vector}} types. If a particular type is not provided by an implementation, then it is an error to call the corresponding procedures in this library. Note that there is no library named (srfi 160).

=== Module (srfi 160 base)

Defines {{make-@vector}}, {{@vector}}, {{@vector?}}, {{@vector-length}},
{{@vector-ref}}, {{@vector-set!}}, {{@vector->list}}, {{list->@vector}}, and
{{@?}}, for all types. All of these are also re-exported by the respective
(srfi 160 @) modules and described below.


=== Module (srfi 160 u8)
==== Constructors
<procedure>(make-u8vector size [fill]) -> u8vector</procedure>

Returns a {{u8vector}} whose length is size. If fill is provided, all the elements of the {{u8vector}} are initialized to it.

<procedure>(u8vector value ...) -> u8vector</procedure>

Returns a {{u8vector}} initialized with values.

<procedure>(u8vector-unfold f length seed) -> u8vector</procedure>

Creates a vector whose length is length and iterates across each index {{k}} between 0 and {{length - 1}}, applying {{f}} at each iteration to the current index and current state, in that order, to receive two values: the element to put in the kth slot of the new vector and a new state for the next iteration. On the first call to {{f}}, the state's value is seed.

<procedure>(u8vector-unfold-right f length seed) -> u8vector</procedure>

The same as u8vector-unfold, but initializes the {{u8vector}} from right to left.

<procedure>(u8vector-copy u8vec [start [end]]) -> u8vector</procedure>

Makes a copy of the portion of {{u8vec}} from {{start}} to {{end}} and returns it.

<procedure>(u8vector-reverse-copy u8vec [start [end]]) -> u8vector</procedure>

The same as {{u8vector-copy}}, but in reverse order.

<procedure>(u8vector-append u8vec ...) -> u8vector</procedure>

Returns a {{u8vector}} containing all the elements of the {{u8vecs}} in order.

<procedure>(u8vector-concatenate list-of-u8vectors) -> u8vector</procedure>

The same as {{u8vector-append}}, but takes a list of {{u8vectors}} rather than multiple arguments.

<procedure>(u8vector-append-subvectors [u8vec start end] ...) -> u8vector</procedure>

Concatenates the result of applying {{u8vector-copy}} to each triplet of {{u8vec}}, {{start}}, {{end}} arguments, but may be implemented more efficiently.
==== Predicates
<procedure>(u8? obj) -> boolean</procedure>

Returns {{#t}} if obj is a valid element of an {{u8vector}}, and {{#f}} otherwise.

<procedure>(u8vector? obj) -> boolean</procedure>

Returns {{#t}} if obj is a {{u8vector}}, and {{#f}} otherwise.

<procedure>(u8vector-empty? u8vec) -> boolean</procedure>

Returns {{#t}} if {{u8vec}} has a length of zero, and {{#f}} otherwise.

<procedure>(u8vector= u8vec ...) -> boolean</procedure>

Compares the {{u8vecs}} for elementwise equality, using = to do the comparisons. Returns {{#f}} unless all {{u8vectors}} are the same length.
==== Selectors
<procedure>(u8vector-ref u8vec i) -> value</procedure>

Returns the ith element of {{u8vec}}.

<procedure>(u8vector-length u8vec) -> exact nonnegative integer</procedure>

Returns the length of {{u8vec}}
==== Iteration
<procedure>(u8vector-take u8vec n) -> u8vector] [SRFI 152]</procedure>

<procedure>(u8vector-take-right u8vec n) -> u8vector [SRFI 152]</procedure>

Returns a {{u8vector}} containing the first/last {{n}} elements of {{u8vec}}.

<procedure>(u8vector-drop u8vec n) -> u8vector [SRFI 152]</procedure>

<procedure>(u8vector-drop-right u8vec n) -> u8vector [SRFI 152]</procedure>

Returns a {{u8vector}} containing all except the first/last {{n}} elements of {{u8vec}}.

<procedure>(u8vector-segment u8vec n) -> list [SRFI 152]</procedure>

Returns a list of {{u8vectors}}, each of which contains n consecutive elements of {{u8vec}}. The last {{u8vector}} may be shorter than {{n}}.

<procedure>(u8vector-fold kons knil u8vec u8vec2 ...) -> object</procedure>

<procedure>(u8vector-fold-right kons knil u8vec u8vec2 ...) -> object</procedure>

When one {{u8vector}} argument {{u8vec}} is given, folds {{kons}} over the elements of {{u8vec}} in increasing/decreasing order using {{knil}} as the initial value. The {{kons}} procedure is called with the state first and the element second, as in SRFIs 43 and 133 (heterogeneous vectors). This is the opposite order to that used in SRFI 1 (lists) and the various string SRFIs.

When multiple {{u8vector}} arguments are given, {{kons}} is called with the current state value and each value from all the vectors; {{u8vector-fold}} scans elements from left to right, while {{u8vector-fold-right}} does from right to left. If the lengths of vectors differ, only the portion of each vector up to the length of the shortest vector is scanned.

<procedure>(u8vector-map f u8vec u8vec2 ...) -> u8vector</procedure>

<procedure>(u8vector-map! f u8vec u8vec2 ...) -> unspecified</procedure>

<procedure>(u8vector-for-each f u8vec u8vec2 ...) -> unspecified</procedure>

Iterate over the elements of {{u8vec}} and apply {{f}} to each, returning respectively a {{u8vector}} of the results, an undefined value with the results placed back in {{u8vec}}, and an undefined value with no change to {{u8vec}}.

If more than one vector is passed, {{f}} gets one element from each vector as arguments. If the lengths of the vectors differ, iteration stops at the end of the shortest vector. For {{u8vector-map!}}, only {{u8vec}} is modified even when multiple vectors are passed.

If {{u8vector-map}} or {{u8vector-map!}} returns more than once (i.e. because of a continuation captured by {{f}}), the values returned or stored by earlier returns may be mutated.

<procedure>(u8vector-count pred? u8vec u8vec2 ...) -> exact nonnegative integer</procedure>

Call {{pred?}} on each element of {{u8vec}} and return the number of calls that return true.

When multiple vectors are given, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are given for each iteration, which stops at the end of the shortest vector.

<procedure>(u8vector-cumulate f knil u8vec) -> u8vector</procedure>

Like {{u8vector-fold}}, but returns an {{u8vector}} of partial results rather than just the final result.
==== Searching
<procedure>(u8vector-take-while pred? u8vec) -> u8vector [SRFI 152]</procedure>

<procedure>(u8vector-take-while-right pred? u8vec) -> u8vector [SRFI 152]</procedure>

Return the shortest prefix/suffix of {{u8vec}} all of whose elements satisfy {{pred?}}.

<procedure>(u8vector-drop-while pred? u8vec) -> u8vector [SRFI 152]</procedure>

<procedure>(u8vector-drop-while-right pred? u8vec) -> u8vector [SRFI 152]</procedure>

Drops the longest initial prefix/suffix of {{u8vec}} such that all its elements satisfy pred.

<procedure>(u8vector-index pred? u8vec u8vec2 ...) -> exact nonnegative integer or #f</procedure>

<procedure>(u8vector-index-right pred? u8vec u8vec2 ...) -> exact nonnegative integer or #f</procedure>

Return the index of the first/last element of {{u8vec}} that satisfies {{pred?}}.

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are passed for each iteration. If the lengths of vectors differ, {{u8vector-index}} stops iteration at the end of the shortest one. Lengths of vectors must be the same for {{u8vector-index-right}}.

<procedure>(u8vector-skip pred? u8vec u8vec2 ...) -> exact nonnegative integer or #f</procedure>

<procedure>(u8vector-skip-right pred? u8vec u8vec2 ...) -> exact nonnegative integer or #f</procedure>

Returns the index of the first/last element of {{u8vec}} that does not satisfy {{pred?}}.

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are passed for each iteration. If the lengths of vectors differ, {{u8vector-skip}} stops iteration at the end of the shortest one. Lengths of vectors must be the same for {{u8vector-skip-right}}.

<procedure>(u8vector-any pred? u8vec u8vec2 ...) -> value or boolean</procedure>

Returns first non-false result of applying {{pred?}} on a element from the {{u8vec}}, or {{#f}} if there is no such element. If {{u8vec}} is empty, returns #t

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are passed for each iteration. If the lengths of vectors differ, it stops at the end of the shortest one.

<procedure>(u8vector-every pred? u8vec u8vec2 ...) -> value or boolean</procedure>

If all elements from {{u8vec}} satisfy {{pred?}}, return the last result of {{pred?}}. If not all do, return {{#f}}. If {{u8vec}} is empty, return #t

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector is passed for each iteration. If the lengths of vectors differ, it stops at the end of the shortest one.

<procedure>(u8vector-partition pred? u8vec) -> u8vector and integer</procedure>

Returns an {{u8vector}} of the same type as {{u8vec}}, but with all elements satisfying {{pred?}} in the leftmost part of the vector and the other elements in the remaining part. The order of elements is otherwise preserved. Returns two values, the new {{u8vector}} and the number of elements satisfying {{pred?}}.

<procedure>(u8vector-filter pred? u8vec) -> u8vector [SRFI 152]</procedure>

<procedure>(u8vector-remove pred? u8vec) -> u8vector [SRFI 152]</procedure>

Return an {{u8vector}} containing the elements of {{u8vec}} that satisfy / do not satisfy {{pred?}}.
==== Mutators
<procedure>(u8vector-set! u8vec i value) -> unspecified</procedure>

Sets the ith element of {{u8vec}} to value.

<procedure>(u8vector-swap! u8vec i j) -> unspecified</procedure>

Interchanges the ith and jth elements of {{u8vec}}.

<procedure>(u8vector-fill! u8vec fill [start [end]]) -> unspecified</procedure>

Fills the portion of {{u8vec}} from {{start}} to {{end}} with the value fill.

<procedure>(u8vector-reverse! u8vec [start [end]]) -> unspecified</procedure>

Reverses the portion of {{u8vec}} from {{start}} to {{end}}.

<procedure>(u8vector-copy! u8to at u8from [start [end]]) -> unspecified</procedure>

Copies the portion of {{u8from}} from {{start}} to {{end}} onto {{u8to}}, starting at index at.

<procedure>(u8vector-reverse-copy! u8to at u8from [start [end]]) -> unspecified</procedure>

The same as {{u8vector-copy!}}, but copies in reverse.

<procedure>(u8vector-unfold! f u8vec start end seed) -> u8vector</procedure>

Like vector-unfold, but the elements are copied into the vector {{u8vec}} starting at element {{start}} rather than into a newly allocated vector. Terminates when {{end}} - {{start}} elements have been generated.

<procedure>(u8vector-unfold-right! f u8vec start end seed) -> u8vector</procedure>

The same as {{u8vector-unfold!}}, but initializes the {{u8vector}} from right to left.
==== Conversion
<procedure>(u8vector->list u8vec [start [end]]) -> proper-list</procedure>

<procedure>(reverse-u8vector->list u8vec [start [end]]) -> proper-list</procedure>

<procedure>(list->u8vector proper-list) -> u8vector</procedure>

<procedure>(reverse-list->u8vector proper-list) -> u8vector</procedure>

<procedure>(u8vector->vector u8vec [start [end]]) -> vector</procedure>

<procedure>(vector->u8vector vec [start [end]]) -> u8vector</procedure>

Returns a list, {{u8vector}}, or heterogeneous vector with the same elements as the argument, in reverse order where specified.
==== Generators
<procedure>(make-u8vector-generator u8vector)</procedure>

Returns a [[https://srfi.schemers.org/srfi-121/srfi-121.html][SRFI 121]] generator that generates all the values of {{u8vector}} in order. Note that the generator is finite.
==== Comparators
{{u8vector-comparator}}

Variable containing a [[https://srfi.schemers.org/srfi-128/srfi-128.html][SRFI 128]] comparator whose components provide ordering and hashing of {{u8vectors}}.
==== Output
<procedure>(write-u8vector u8vec [ port ] ) -> unspecified</procedure>

Prints to port (the current output port by default) a representation of {{u8vec}} in the lexical syntax explained below.
=== Module (srfi 160 s8)
==== Constructors
<procedure>(make-s8vector size [fill]) -> s8vector</procedure>

Returns a {{s8vector}} whose length is size. If fill is provided, all the elements of the {{s8vector}} are initialized to it.

<procedure>(s8vector value ...) -> s8vector</procedure>

Returns a {{s8vector}} initialized with values.

<procedure>(s8vector-unfold f length seed) -> s8vector</procedure>

Creates a vector whose length is length and iterates across each index {{k}} between 0 and {{length - 1}}, applying {{f}} at each iteration to the current index and current state, in that order, to receive two values: the element to put in the kth slot of the new vector and a new state for the next iteration. On the first call to {{f}}, the state's value is seed.

<procedure>(s8vector-unfold-right f length seed) -> s8vector</procedure>

The same as s8vector-unfold, but initializes the {{s8vector}} from right to left.

<procedure>(s8vector-copy s8vec [start [end]]) -> s8vector</procedure>

Makes a copy of the portion of {{s8vec}} from {{start}} to {{end}} and returns it.

<procedure>(s8vector-reverse-copy s8vec [start [end]]) -> s8vector</procedure>

The same as {{s8vector-copy}}, but in reverse order.

<procedure>(s8vector-append s8vec ...) -> s8vector</procedure>

Returns a {{s8vector}} containing all the elements of the {{s8vecs}} in order.

<procedure>(s8vector-concatenate list-of-s8vectors) -> s8vector</procedure>

The same as {{s8vector-append}}, but takes a list of {{s8vectors}} rather than multiple arguments.

<procedure>(s8vector-append-subvectors [s8vec start end] ...) -> s8vector</procedure>

Concatenates the result of applying {{s8vector-copy}} to each triplet of {{s8vec}}, {{start}}, {{end}} arguments, but may be implemented more efficiently.
==== Predicates
<procedure>(s8? obj) -> boolean</procedure>

Returns {{#t}} if obj is a valid element of an {{s8vector}}, and {{#f}} otherwise.

<procedure>(s8vector? obj) -> boolean</procedure>

Returns {{#t}} if obj is a {{s8vector}}, and {{#f}} otherwise.

<procedure>(s8vector-empty? s8vec) -> boolean</procedure>

Returns {{#t}} if {{s8vec}} has a length of zero, and {{#f}} otherwise.

<procedure>(s8vector= s8vec ...) -> boolean</procedure>

Compares the {{s8vecs}} for elementwise equality, using = to do the comparisons. Returns {{#f}} unless all {{s8vectors}} are the same length.
==== Selectors
<procedure>(s8vector-ref s8vec i) -> value</procedure>

Returns the ith element of {{s8vec}}.

<procedure>(s8vector-length s8vec) -> exact nonnegative integer</procedure>

Returns the length of {{s8vec}}
==== Iteration
<procedure>(s8vector-take s8vec n) -> s8vector] [SRFI 152]</procedure>

<procedure>(s8vector-take-right s8vec n) -> s8vector [SRFI 152]</procedure>

Returns a {{s8vector}} containing the first/last {{n}} elements of {{s8vec}}.

<procedure>(s8vector-drop s8vec n) -> s8vector [SRFI 152]</procedure>

<procedure>(s8vector-drop-right s8vec n) -> s8vector [SRFI 152]</procedure>

Returns a {{s8vector}} containing all except the first/last {{n}} elements of {{s8vec}}.

<procedure>(s8vector-segment s8vec n) -> list [SRFI 152]</procedure>

Returns a list of {{s8vectors}}, each of which contains n consecutive elements of {{s8vec}}. The last {{s8vector}} may be shorter than {{n}}.

<procedure>(s8vector-fold kons knil s8vec s8vec2 ...) -> object</procedure>

<procedure>(s8vector-fold-right kons knil s8vec s8vec2 ...) -> object</procedure>

When one {{s8vector}} argument {{s8vec}} is given, folds {{kons}} over the elements of {{s8vec}} in increasing/decreasing order using {{knil}} as the initial value. The {{kons}} procedure is called with the state first and the element second, as in SRFIs 43 and 133 (heterogeneous vectors). This is the opposite order to that used in SRFI 1 (lists) and the various string SRFIs.

When multiple {{s8vector}} arguments are given, {{kons}} is called with the current state value and each value from all the vectors; {{s8vector-fold}} scans elements from left to right, while {{s8vector-fold-right}} does from right to left. If the lengths of vectors differ, only the portion of each vector up to the length of the shortest vector is scanned.

<procedure>(s8vector-map f s8vec s8vec2 ...) -> s8vector</procedure>

<procedure>(s8vector-map! f s8vec s8vec2 ...) -> unspecified</procedure>

<procedure>(s8vector-for-each f s8vec s8vec2 ...) -> unspecified</procedure>

Iterate over the elements of {{s8vec}} and apply {{f}} to each, returning respectively a {{s8vector}} of the results, an undefined value with the results placed back in {{s8vec}}, and an undefined value with no change to {{s8vec}}.

If more than one vector is passed, {{f}} gets one element from each vector as arguments. If the lengths of the vectors differ, iteration stops at the end of the shortest vector. For {{s8vector-map!}}, only {{s8vec}} is modified even when multiple vectors are passed.

If {{s8vector-map}} or {{s8vector-map!}} returns more than once (i.e. because of a continuation captured by {{f}}), the values returned or stored by earlier returns may be mutated.

<procedure>(s8vector-count pred? s8vec s8vec2 ...) -> exact nonnegative integer</procedure>

Call {{pred?}} on each element of {{s8vec}} and return the number of calls that return true.

When multiple vectors are given, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are given for each iteration, which stops at the end of the shortest vector.

<procedure>(s8vector-cumulate f knil s8vec) -> s8vector</procedure>

Like {{s8vector-fold}}, but returns an {{s8vector}} of partial results rather than just the final result.
==== Searching
<procedure>(s8vector-take-while pred? s8vec) -> s8vector [SRFI 152]</procedure>

<procedure>(s8vector-take-while-right pred? s8vec) -> s8vector [SRFI 152]</procedure>

Return the shortest prefix/suffix of {{s8vec}} all of whose elements satisfy {{pred?}}.

<procedure>(s8vector-drop-while pred? s8vec) -> s8vector [SRFI 152]</procedure>

<procedure>(s8vector-drop-while-right pred? s8vec) -> s8vector [SRFI 152]</procedure>

Drops the longest initial prefix/suffix of {{s8vec}} such that all its elements satisfy pred.

<procedure>(s8vector-index pred? s8vec s8vec2 ...) -> exact nonnegative integer or #f</procedure>

<procedure>(s8vector-index-right pred? s8vec s8vec2 ...) -> exact nonnegative integer or #f</procedure>

Return the index of the first/last element of {{s8vec}} that satisfies {{pred?}}.

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are passed for each iteration. If the lengths of vectors differ, {{s8vector-index}} stops iteration at the end of the shortest one. Lengths of vectors must be the same for {{s8vector-index-right}}.

<procedure>(s8vector-skip pred? s8vec s8vec2 ...) -> exact nonnegative integer or #f</procedure>

<procedure>(s8vector-skip-right pred? s8vec s8vec2 ...) -> exact nonnegative integer or #f</procedure>

Returns the index of the first/last element of {{s8vec}} that does not satisfy {{pred?}}.

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are passed for each iteration. If the lengths of vectors differ, {{s8vector-skip}} stops iteration at the end of the shortest one. Lengths of vectors must be the same for {{s8vector-skip-right}}.

<procedure>(s8vector-any pred? s8vec s8vec2 ...) -> value or boolean</procedure>

Returns first non-false result of applying {{pred?}} on a element from the {{s8vec}}, or {{#f}} if there is no such element. If {{s8vec}} is empty, returns #t

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are passed for each iteration. If the lengths of vectors differ, it stops at the end of the shortest one.

<procedure>(s8vector-every pred? s8vec s8vec2 ...) -> value or boolean</procedure>

If all elements from {{s8vec}} satisfy {{pred?}}, return the last result of {{pred?}}. If not all do, return {{#f}}. If {{s8vec}} is empty, return #t

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector is passed for each iteration. If the lengths of vectors differ, it stops at the end of the shortest one.

<procedure>(s8vector-partition pred? s8vec) -> s8vector and integer</procedure>

Returns an {{s8vector}} of the same type as {{s8vec}}, but with all elements satisfying {{pred?}} in the leftmost part of the vector and the other elements in the remaining part. The order of elements is otherwise preserved. Returns two values, the new {{s8vector}} and the number of elements satisfying {{pred?}}.

<procedure>(s8vector-filter pred? s8vec) -> s8vector [SRFI 152]</procedure>

<procedure>(s8vector-remove pred? s8vec) -> s8vector [SRFI 152]</procedure>

Return an {{s8vector}} containing the elements of {{s8vec}} that satisfy / do not satisfy {{pred?}}.
==== Mutators
<procedure>(s8vector-set! s8vec i value) -> unspecified</procedure>

Sets the ith element of {{s8vec}} to value.

<procedure>(s8vector-swap! s8vec i j) -> unspecified</procedure>

Interchanges the ith and jth elements of {{s8vec}}.

<procedure>(s8vector-fill! s8vec fill [start [end]]) -> unspecified</procedure>

Fills the portion of {{s8vec}} from {{start}} to {{end}} with the value fill.

<procedure>(s8vector-reverse! s8vec [start [end]]) -> unspecified</procedure>

Reverses the portion of {{s8vec}} from {{start}} to {{end}}.

<procedure>(s8vector-copy! s8to at s8from [start [end]]) -> unspecified</procedure>

Copies the portion of {{s8from}} from {{start}} to {{end}} onto {{s8to}}, starting at index at.

<procedure>(s8vector-reverse-copy! s8to at s8from [start [end]]) -> unspecified</procedure>

The same as {{s8vector-copy!}}, but copies in reverse.

<procedure>(s8vector-unfold! f s8vec start end seed) -> s8vector</procedure>

Like vector-unfold, but the elements are copied into the vector {{s8vec}} starting at element {{start}} rather than into a newly allocated vector. Terminates when {{end}} - {{start}} elements have been generated.

<procedure>(s8vector-unfold-right! f s8vec start end seed) -> s8vector</procedure>

The same as {{s8vector-unfold!}}, but initializes the {{s8vector}} from right to left.
==== Conversion
<procedure>(s8vector->list s8vec [start [end]]) -> proper-list</procedure>

<procedure>(reverse-s8vector->list s8vec [start [end]]) -> proper-list</procedure>

<procedure>(list->s8vector proper-list) -> s8vector</procedure>

<procedure>(reverse-list->s8vector proper-list) -> s8vector</procedure>

<procedure>(s8vector->vector s8vec [start [end]]) -> vector</procedure>

<procedure>(vector->s8vector vec [start [end]]) -> s8vector</procedure>

Returns a list, {{s8vector}}, or heterogeneous vector with the same elements as the argument, in reverse order where specified.
==== Generators
<procedure>(make-s8vector-generator s8vector)</procedure>

Returns a [[https://srfi.schemers.org/srfi-121/srfi-121.html][SRFI 121]] generator that generates all the values of {{s8vector}} in order. Note that the generator is finite.
==== Comparators
{{s8vector-comparator}}

Variable containing a [[https://srfi.schemers.org/srfi-128/srfi-128.html][SRFI 128]] comparator whose components provide ordering and hashing of {{s8vectors}}.
==== Output
<procedure>(write-s8vector s8vec [ port ] ) -> unspecified</procedure>

Prints to port (the current output port by default) a representation of {{s8vec}} in the lexical syntax explained below.
=== Module (srfi 160 u16)
==== Constructors
<procedure>(make-u16vector size [fill]) -> u16vector</procedure>

Returns a {{u16vector}} whose length is size. If fill is provided, all the elements of the {{u16vector}} are initialized to it.

<procedure>(u16vector value ...) -> u16vector</procedure>

Returns a {{u16vector}} initialized with values.

<procedure>(u16vector-unfold f length seed) -> u16vector</procedure>

Creates a vector whose length is length and iterates across each index {{k}} between 0 and {{length - 1}}, applying {{f}} at each iteration to the current index and current state, in that order, to receive two values: the element to put in the kth slot of the new vector and a new state for the next iteration. On the first call to {{f}}, the state's value is seed.

<procedure>(u16vector-unfold-right f length seed) -> u16vector</procedure>

The same as u16vector-unfold, but initializes the {{u16vector}} from right to left.

<procedure>(u16vector-copy u16vec [start [end]]) -> u16vector</procedure>

Makes a copy of the portion of {{u16vec}} from {{start}} to {{end}} and returns it.

<procedure>(u16vector-reverse-copy u16vec [start [end]]) -> u16vector</procedure>

The same as {{u16vector-copy}}, but in reverse order.

<procedure>(u16vector-append u16vec ...) -> u16vector</procedure>

Returns a {{u16vector}} containing all the elements of the {{u16vecs}} in order.

<procedure>(u16vector-concatenate list-of-u16vectors) -> u16vector</procedure>

The same as {{u16vector-append}}, but takes a list of {{u16vectors}} rather than multiple arguments.

<procedure>(u16vector-append-subvectors [u16vec start end] ...) -> u16vector</procedure>

Concatenates the result of applying {{u16vector-copy}} to each triplet of {{u16vec}}, {{start}}, {{end}} arguments, but may be implemented more efficiently.
==== Predicates
<procedure>(u16? obj) -> boolean</procedure>

Returns {{#t}} if obj is a valid element of an {{u16vector}}, and {{#f}} otherwise.

<procedure>(u16vector? obj) -> boolean</procedure>

Returns {{#t}} if obj is a {{u16vector}}, and {{#f}} otherwise.

<procedure>(u16vector-empty? u16vec) -> boolean</procedure>

Returns {{#t}} if {{u16vec}} has a length of zero, and {{#f}} otherwise.

<procedure>(u16vector= u16vec ...) -> boolean</procedure>

Compares the {{u16vecs}} for elementwise equality, using = to do the comparisons. Returns {{#f}} unless all {{u16vectors}} are the same length.
==== Selectors
<procedure>(u16vector-ref u16vec i) -> value</procedure>

Returns the ith element of {{u16vec}}.

<procedure>(u16vector-length u16vec) -> exact nonnegative integer</procedure>

Returns the length of {{u16vec}}
==== Iteration
<procedure>(u16vector-take u16vec n) -> u16vector] [SRFI 152]</procedure>

<procedure>(u16vector-take-right u16vec n) -> u16vector [SRFI 152]</procedure>

Returns a {{u16vector}} containing the first/last {{n}} elements of {{u16vec}}.

<procedure>(u16vector-drop u16vec n) -> u16vector [SRFI 152]</procedure>

<procedure>(u16vector-drop-right u16vec n) -> u16vector [SRFI 152]</procedure>

Returns a {{u16vector}} containing all except the first/last {{n}} elements of {{u16vec}}.

<procedure>(u16vector-segment u16vec n) -> list [SRFI 152]</procedure>

Returns a list of {{u16vectors}}, each of which contains n consecutive elements of {{u16vec}}. The last {{u16vector}} may be shorter than {{n}}.

<procedure>(u16vector-fold kons knil u16vec u16vec2 ...) -> object</procedure>

<procedure>(u16vector-fold-right kons knil u16vec u16vec2 ...) -> object</procedure>

When one {{u16vector}} argument {{u16vec}} is given, folds {{kons}} over the elements of {{u16vec}} in increasing/decreasing order using {{knil}} as the initial value. The {{kons}} procedure is called with the state first and the element second, as in SRFIs 43 and 133 (heterogeneous vectors). This is the opposite order to that used in SRFI 1 (lists) and the various string SRFIs.

When multiple {{u16vector}} arguments are given, {{kons}} is called with the current state value and each value from all the vectors; {{u16vector-fold}} scans elements from left to right, while {{u16vector-fold-right}} does from right to left. If the lengths of vectors differ, only the portion of each vector up to the length of the shortest vector is scanned.

<procedure>(u16vector-map f u16vec u16vec2 ...) -> u16vector</procedure>

<procedure>(u16vector-map! f u16vec u16vec2 ...) -> unspecified</procedure>

<procedure>(u16vector-for-each f u16vec u16vec2 ...) -> unspecified</procedure>

Iterate over the elements of {{u16vec}} and apply {{f}} to each, returning respectively a {{u16vector}} of the results, an undefined value with the results placed back in {{u16vec}}, and an undefined value with no change to {{u16vec}}.

If more than one vector is passed, {{f}} gets one element from each vector as arguments. If the lengths of the vectors differ, iteration stops at the end of the shortest vector. For {{u16vector-map!}}, only {{u16vec}} is modified even when multiple vectors are passed.

If {{u16vector-map}} or {{u16vector-map!}} returns more than once (i.e. because of a continuation captured by {{f}}), the values returned or stored by earlier returns may be mutated.

<procedure>(u16vector-count pred? u16vec u16vec2 ...) -> exact nonnegative integer</procedure>

Call {{pred?}} on each element of {{u16vec}} and return the number of calls that return true.

When multiple vectors are given, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are given for each iteration, which stops at the end of the shortest vector.

<procedure>(u16vector-cumulate f knil u16vec) -> u16vector</procedure>

Like {{u16vector-fold}}, but returns an {{u16vector}} of partial results rather than just the final result.
==== Searching
<procedure>(u16vector-take-while pred? u16vec) -> u16vector [SRFI 152]</procedure>

<procedure>(u16vector-take-while-right pred? u16vec) -> u16vector [SRFI 152]</procedure>

Return the shortest prefix/suffix of {{u16vec}} all of whose elements satisfy {{pred?}}.

<procedure>(u16vector-drop-while pred? u16vec) -> u16vector [SRFI 152]</procedure>

<procedure>(u16vector-drop-while-right pred? u16vec) -> u16vector [SRFI 152]</procedure>

Drops the longest initial prefix/suffix of {{u16vec}} such that all its elements satisfy pred.

<procedure>(u16vector-index pred? u16vec u16vec2 ...) -> exact nonnegative integer or #f</procedure>

<procedure>(u16vector-index-right pred? u16vec u16vec2 ...) -> exact nonnegative integer or #f</procedure>

Return the index of the first/last element of {{u16vec}} that satisfies {{pred?}}.

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are passed for each iteration. If the lengths of vectors differ, {{u16vector-index}} stops iteration at the end of the shortest one. Lengths of vectors must be the same for {{u16vector-index-right}}.

<procedure>(u16vector-skip pred? u16vec u16vec2 ...) -> exact nonnegative integer or #f</procedure>

<procedure>(u16vector-skip-right pred? u16vec u16vec2 ...) -> exact nonnegative integer or #f</procedure>

Returns the index of the first/last element of {{u16vec}} that does not satisfy {{pred?}}.

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are passed for each iteration. If the lengths of vectors differ, {{u16vector-skip}} stops iteration at the end of the shortest one. Lengths of vectors must be the same for {{u16vector-skip-right}}.

<procedure>(u16vector-any pred? u16vec u16vec2 ...) -> value or boolean</procedure>

Returns first non-false result of applying {{pred?}} on a element from the {{u16vec}}, or {{#f}} if there is no such element. If {{u16vec}} is empty, returns #t

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are passed for each iteration. If the lengths of vectors differ, it stops at the end of the shortest one.

<procedure>(u16vector-every pred? u16vec u16vec2 ...) -> value or boolean</procedure>

If all elements from {{u16vec}} satisfy {{pred?}}, return the last result of {{pred?}}. If not all do, return {{#f}}. If {{u16vec}} is empty, return #t

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector is passed for each iteration. If the lengths of vectors differ, it stops at the end of the shortest one.

<procedure>(u16vector-partition pred? u16vec) -> u16vector and integer</procedure>

Returns an {{u16vector}} of the same type as {{u16vec}}, but with all elements satisfying {{pred?}} in the leftmost part of the vector and the other elements in the remaining part. The order of elements is otherwise preserved. Returns two values, the new {{u16vector}} and the number of elements satisfying {{pred?}}.

<procedure>(u16vector-filter pred? u16vec) -> u16vector [SRFI 152]</procedure>

<procedure>(u16vector-remove pred? u16vec) -> u16vector [SRFI 152]</procedure>

Return an {{u16vector}} containing the elements of {{u16vec}} that satisfy / do not satisfy {{pred?}}.
==== Mutators
<procedure>(u16vector-set! u16vec i value) -> unspecified</procedure>

Sets the ith element of {{u16vec}} to value.

<procedure>(u16vector-swap! u16vec i j) -> unspecified</procedure>

Interchanges the ith and jth elements of {{u16vec}}.

<procedure>(u16vector-fill! u16vec fill [start [end]]) -> unspecified</procedure>

Fills the portion of {{u16vec}} from {{start}} to {{end}} with the value fill.

<procedure>(u16vector-reverse! u16vec [start [end]]) -> unspecified</procedure>

Reverses the portion of {{u16vec}} from {{start}} to {{end}}.

<procedure>(u16vector-copy! u16to at u16from [start [end]]) -> unspecified</procedure>

Copies the portion of {{u16from}} from {{start}} to {{end}} onto {{u16to}}, starting at index at.

<procedure>(u16vector-reverse-copy! u16to at u16from [start [end]]) -> unspecified</procedure>

The same as {{u16vector-copy!}}, but copies in reverse.

<procedure>(u16vector-unfold! f u16vec start end seed) -> u16vector</procedure>

Like vector-unfold, but the elements are copied into the vector {{u16vec}} starting at element {{start}} rather than into a newly allocated vector. Terminates when {{end}} - {{start}} elements have been generated.

<procedure>(u16vector-unfold-right! f u16vec start end seed) -> u16vector</procedure>

The same as {{u16vector-unfold!}}, but initializes the {{u16vector}} from right to left.
==== Conversion
<procedure>(u16vector->list u16vec [start [end]]) -> proper-list</procedure>

<procedure>(reverse-u16vector->list u16vec [start [end]]) -> proper-list</procedure>

<procedure>(list->u16vector proper-list) -> u16vector</procedure>

<procedure>(reverse-list->u16vector proper-list) -> u16vector</procedure>

<procedure>(u16vector->vector u16vec [start [end]]) -> vector</procedure>

<procedure>(vector->u16vector vec [start [end]]) -> u16vector</procedure>

Returns a list, {{u16vector}}, or heterogeneous vector with the same elements as the argument, in reverse order where specified.
==== Generators
<procedure>(make-u16vector-generator u16vector)</procedure>

Returns a [[https://srfi.schemers.org/srfi-121/srfi-121.html][SRFI 121]] generator that generates all the values of {{u16vector}} in order. Note that the generator is finite.
==== Comparators
{{u16vector-comparator}}

Variable containing a [[https://srfi.schemers.org/srfi-128/srfi-128.html][SRFI 128]] comparator whose components provide ordering and hashing of {{u16vectors}}.
==== Output
<procedure>(write-u16vector u16vec [ port ] ) -> unspecified</procedure>

Prints to port (the current output port by default) a representation of {{u16vec}} in the lexical syntax explained below.
=== Module (srfi 160 s16)
==== Constructors
<procedure>(make-s16vector size [fill]) -> s16vector</procedure>

Returns a {{s16vector}} whose length is size. If fill is provided, all the elements of the {{s16vector}} are initialized to it.

<procedure>(s16vector value ...) -> s16vector</procedure>

Returns a {{s16vector}} initialized with values.

<procedure>(s16vector-unfold f length seed) -> s16vector</procedure>

Creates a vector whose length is length and iterates across each index {{k}} between 0 and {{length - 1}}, applying {{f}} at each iteration to the current index and current state, in that order, to receive two values: the element to put in the kth slot of the new vector and a new state for the next iteration. On the first call to {{f}}, the state's value is seed.

<procedure>(s16vector-unfold-right f length seed) -> s16vector</procedure>

The same as s16vector-unfold, but initializes the {{s16vector}} from right to left.

<procedure>(s16vector-copy s16vec [start [end]]) -> s16vector</procedure>

Makes a copy of the portion of {{s16vec}} from {{start}} to {{end}} and returns it.

<procedure>(s16vector-reverse-copy s16vec [start [end]]) -> s16vector</procedure>

The same as {{s16vector-copy}}, but in reverse order.

<procedure>(s16vector-append s16vec ...) -> s16vector</procedure>

Returns a {{s16vector}} containing all the elements of the {{s16vecs}} in order.

<procedure>(s16vector-concatenate list-of-s16vectors) -> s16vector</procedure>

The same as {{s16vector-append}}, but takes a list of {{s16vectors}} rather than multiple arguments.

<procedure>(s16vector-append-subvectors [s16vec start end] ...) -> s16vector</procedure>

Concatenates the result of applying {{s16vector-copy}} to each triplet of {{s16vec}}, {{start}}, {{end}} arguments, but may be implemented more efficiently.
==== Predicates
<procedure>(s16? obj) -> boolean</procedure>

Returns {{#t}} if obj is a valid element of an {{s16vector}}, and {{#f}} otherwise.

<procedure>(s16vector? obj) -> boolean</procedure>

Returns {{#t}} if obj is a {{s16vector}}, and {{#f}} otherwise.

<procedure>(s16vector-empty? s16vec) -> boolean</procedure>

Returns {{#t}} if {{s16vec}} has a length of zero, and {{#f}} otherwise.

<procedure>(s16vector= s16vec ...) -> boolean</procedure>

Compares the {{s16vecs}} for elementwise equality, using = to do the comparisons. Returns {{#f}} unless all {{s16vectors}} are the same length.
==== Selectors
<procedure>(s16vector-ref s16vec i) -> value</procedure>

Returns the ith element of {{s16vec}}.

<procedure>(s16vector-length s16vec) -> exact nonnegative integer</procedure>

Returns the length of {{s16vec}}
==== Iteration
<procedure>(s16vector-take s16vec n) -> s16vector] [SRFI 152]</procedure>

<procedure>(s16vector-take-right s16vec n) -> s16vector [SRFI 152]</procedure>

Returns a {{s16vector}} containing the first/last {{n}} elements of {{s16vec}}.

<procedure>(s16vector-drop s16vec n) -> s16vector [SRFI 152]</procedure>

<procedure>(s16vector-drop-right s16vec n) -> s16vector [SRFI 152]</procedure>

Returns a {{s16vector}} containing all except the first/last {{n}} elements of {{s16vec}}.

<procedure>(s16vector-segment s16vec n) -> list [SRFI 152]</procedure>

Returns a list of {{s16vectors}}, each of which contains n consecutive elements of {{s16vec}}. The last {{s16vector}} may be shorter than {{n}}.

<procedure>(s16vector-fold kons knil s16vec s16vec2 ...) -> object</procedure>

<procedure>(s16vector-fold-right kons knil s16vec s16vec2 ...) -> object</procedure>

When one {{s16vector}} argument {{s16vec}} is given, folds {{kons}} over the elements of {{s16vec}} in increasing/decreasing order using {{knil}} as the initial value. The {{kons}} procedure is called with the state first and the element second, as in SRFIs 43 and 133 (heterogeneous vectors). This is the opposite order to that used in SRFI 1 (lists) and the various string SRFIs.

When multiple {{s16vector}} arguments are given, {{kons}} is called with the current state value and each value from all the vectors; {{s16vector-fold}} scans elements from left to right, while {{s16vector-fold-right}} does from right to left. If the lengths of vectors differ, only the portion of each vector up to the length of the shortest vector is scanned.

<procedure>(s16vector-map f s16vec s16vec2 ...) -> s16vector</procedure>

<procedure>(s16vector-map! f s16vec s16vec2 ...) -> unspecified</procedure>

<procedure>(s16vector-for-each f s16vec s16vec2 ...) -> unspecified</procedure>

Iterate over the elements of {{s16vec}} and apply {{f}} to each, returning respectively a {{s16vector}} of the results, an undefined value with the results placed back in {{s16vec}}, and an undefined value with no change to {{s16vec}}.

If more than one vector is passed, {{f}} gets one element from each vector as arguments. If the lengths of the vectors differ, iteration stops at the end of the shortest vector. For {{s16vector-map!}}, only {{s16vec}} is modified even when multiple vectors are passed.

If {{s16vector-map}} or {{s16vector-map!}} returns more than once (i.e. because of a continuation captured by {{f}}), the values returned or stored by earlier returns may be mutated.

<procedure>(s16vector-count pred? s16vec s16vec2 ...) -> exact nonnegative integer</procedure>

Call {{pred?}} on each element of {{s16vec}} and return the number of calls that return true.

When multiple vectors are given, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are given for each iteration, which stops at the end of the shortest vector.

<procedure>(s16vector-cumulate f knil s16vec) -> s16vector</procedure>

Like {{s16vector-fold}}, but returns an {{s16vector}} of partial results rather than just the final result.
==== Searching
<procedure>(s16vector-take-while pred? s16vec) -> s16vector [SRFI 152]</procedure>

<procedure>(s16vector-take-while-right pred? s16vec) -> s16vector [SRFI 152]</procedure>

Return the shortest prefix/suffix of {{s16vec}} all of whose elements satisfy {{pred?}}.

<procedure>(s16vector-drop-while pred? s16vec) -> s16vector [SRFI 152]</procedure>

<procedure>(s16vector-drop-while-right pred? s16vec) -> s16vector [SRFI 152]</procedure>

Drops the longest initial prefix/suffix of {{s16vec}} such that all its elements satisfy pred.

<procedure>(s16vector-index pred? s16vec s16vec2 ...) -> exact nonnegative integer or #f</procedure>

<procedure>(s16vector-index-right pred? s16vec s16vec2 ...) -> exact nonnegative integer or #f</procedure>

Return the index of the first/last element of {{s16vec}} that satisfies {{pred?}}.

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are passed for each iteration. If the lengths of vectors differ, {{s16vector-index}} stops iteration at the end of the shortest one. Lengths of vectors must be the same for {{s16vector-index-right}}.

<procedure>(s16vector-skip pred? s16vec s16vec2 ...) -> exact nonnegative integer or #f</procedure>

<procedure>(s16vector-skip-right pred? s16vec s16vec2 ...) -> exact nonnegative integer or #f</procedure>

Returns the index of the first/last element of {{s16vec}} that does not satisfy {{pred?}}.

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are passed for each iteration. If the lengths of vectors differ, {{s16vector-skip}} stops iteration at the end of the shortest one. Lengths of vectors must be the same for {{s16vector-skip-right}}.

<procedure>(s16vector-any pred? s16vec s16vec2 ...) -> value or boolean</procedure>

Returns first non-false result of applying {{pred?}} on a element from the {{s16vec}}, or {{#f}} if there is no such element. If {{s16vec}} is empty, returns #t

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are passed for each iteration. If the lengths of vectors differ, it stops at the end of the shortest one.

<procedure>(s16vector-every pred? s16vec s16vec2 ...) -> value or boolean</procedure>

If all elements from {{s16vec}} satisfy {{pred?}}, return the last result of {{pred?}}. If not all do, return {{#f}}. If {{s16vec}} is empty, return #t

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector is passed for each iteration. If the lengths of vectors differ, it stops at the end of the shortest one.

<procedure>(s16vector-partition pred? s16vec) -> s16vector and integer</procedure>

Returns an {{s16vector}} of the same type as {{s16vec}}, but with all elements satisfying {{pred?}} in the leftmost part of the vector and the other elements in the remaining part. The order of elements is otherwise preserved. Returns two values, the new {{s16vector}} and the number of elements satisfying {{pred?}}.

<procedure>(s16vector-filter pred? s16vec) -> s16vector [SRFI 152]</procedure>

<procedure>(s16vector-remove pred? s16vec) -> s16vector [SRFI 152]</procedure>

Return an {{s16vector}} containing the elements of {{s16vec}} that satisfy / do not satisfy {{pred?}}.
==== Mutators
<procedure>(s16vector-set! s16vec i value) -> unspecified</procedure>

Sets the ith element of {{s16vec}} to value.

<procedure>(s16vector-swap! s16vec i j) -> unspecified</procedure>

Interchanges the ith and jth elements of {{s16vec}}.

<procedure>(s16vector-fill! s16vec fill [start [end]]) -> unspecified</procedure>

Fills the portion of {{s16vec}} from {{start}} to {{end}} with the value fill.

<procedure>(s16vector-reverse! s16vec [start [end]]) -> unspecified</procedure>

Reverses the portion of {{s16vec}} from {{start}} to {{end}}.

<procedure>(s16vector-copy! s16to at s16from [start [end]]) -> unspecified</procedure>

Copies the portion of {{s16from}} from {{start}} to {{end}} onto {{s16to}}, starting at index at.

<procedure>(s16vector-reverse-copy! s16to at s16from [start [end]]) -> unspecified</procedure>

The same as {{s16vector-copy!}}, but copies in reverse.

<procedure>(s16vector-unfold! f s16vec start end seed) -> s16vector</procedure>

Like vector-unfold, but the elements are copied into the vector {{s16vec}} starting at element {{start}} rather than into a newly allocated vector. Terminates when {{end}} - {{start}} elements have been generated.

<procedure>(s16vector-unfold-right! f s16vec start end seed) -> s16vector</procedure>

The same as {{s16vector-unfold!}}, but initializes the {{s16vector}} from right to left.
==== Conversion
<procedure>(s16vector->list s16vec [start [end]]) -> proper-list</procedure>

<procedure>(reverse-s16vector->list s16vec [start [end]]) -> proper-list</procedure>

<procedure>(list->s16vector proper-list) -> s16vector</procedure>

<procedure>(reverse-list->s16vector proper-list) -> s16vector</procedure>

<procedure>(s16vector->vector s16vec [start [end]]) -> vector</procedure>

<procedure>(vector->s16vector vec [start [end]]) -> s16vector</procedure>

Returns a list, {{s16vector}}, or heterogeneous vector with the same elements as the argument, in reverse order where specified.
==== Generators
<procedure>(make-s16vector-generator s16vector)</procedure>

Returns a [[https://srfi.schemers.org/srfi-121/srfi-121.html][SRFI 121]] generator that generates all the values of {{s16vector}} in order. Note that the generator is finite.
==== Comparators
{{s16vector-comparator}}

Variable containing a [[https://srfi.schemers.org/srfi-128/srfi-128.html][SRFI 128]] comparator whose components provide ordering and hashing of {{s16vectors}}.
==== Output
<procedure>(write-s16vector s16vec [ port ] ) -> unspecified</procedure>

Prints to port (the current output port by default) a representation of {{s16vec}} in the lexical syntax explained below.
=== Module (srfi 160 u32)
==== Constructors
<procedure>(make-u32vector size [fill]) -> u32vector</procedure>

Returns a {{u32vector}} whose length is size. If fill is provided, all the elements of the {{u32vector}} are initialized to it.

<procedure>(u32vector value ...) -> u32vector</procedure>

Returns a {{u32vector}} initialized with values.

<procedure>(u32vector-unfold f length seed) -> u32vector</procedure>

Creates a vector whose length is length and iterates across each index {{k}} between 0 and {{length - 1}}, applying {{f}} at each iteration to the current index and current state, in that order, to receive two values: the element to put in the kth slot of the new vector and a new state for the next iteration. On the first call to {{f}}, the state's value is seed.

<procedure>(u32vector-unfold-right f length seed) -> u32vector</procedure>

The same as u32vector-unfold, but initializes the {{u32vector}} from right to left.

<procedure>(u32vector-copy u32vec [start [end]]) -> u32vector</procedure>

Makes a copy of the portion of {{u32vec}} from {{start}} to {{end}} and returns it.

<procedure>(u32vector-reverse-copy u32vec [start [end]]) -> u32vector</procedure>

The same as {{u32vector-copy}}, but in reverse order.

<procedure>(u32vector-append u32vec ...) -> u32vector</procedure>

Returns a {{u32vector}} containing all the elements of the {{u32vecs}} in order.

<procedure>(u32vector-concatenate list-of-u32vectors) -> u32vector</procedure>

The same as {{u32vector-append}}, but takes a list of {{u32vectors}} rather than multiple arguments.

<procedure>(u32vector-append-subvectors [u32vec start end] ...) -> u32vector</procedure>

Concatenates the result of applying {{u32vector-copy}} to each triplet of {{u32vec}}, {{start}}, {{end}} arguments, but may be implemented more efficiently.
==== Predicates
<procedure>(u32? obj) -> boolean</procedure>

Returns {{#t}} if obj is a valid element of an {{u32vector}}, and {{#f}} otherwise.

<procedure>(u32vector? obj) -> boolean</procedure>

Returns {{#t}} if obj is a {{u32vector}}, and {{#f}} otherwise.

<procedure>(u32vector-empty? u32vec) -> boolean</procedure>

Returns {{#t}} if {{u32vec}} has a length of zero, and {{#f}} otherwise.

<procedure>(u32vector= u32vec ...) -> boolean</procedure>

Compares the {{u32vecs}} for elementwise equality, using = to do the comparisons. Returns {{#f}} unless all {{u32vectors}} are the same length.
==== Selectors
<procedure>(u32vector-ref u32vec i) -> value</procedure>

Returns the ith element of {{u32vec}}.

<procedure>(u32vector-length u32vec) -> exact nonnegative integer</procedure>

Returns the length of {{u32vec}}
==== Iteration
<procedure>(u32vector-take u32vec n) -> u32vector] [SRFI 152]</procedure>

<procedure>(u32vector-take-right u32vec n) -> u32vector [SRFI 152]</procedure>

Returns a {{u32vector}} containing the first/last {{n}} elements of {{u32vec}}.

<procedure>(u32vector-drop u32vec n) -> u32vector [SRFI 152]</procedure>

<procedure>(u32vector-drop-right u32vec n) -> u32vector [SRFI 152]</procedure>

Returns a {{u32vector}} containing all except the first/last {{n}} elements of {{u32vec}}.

<procedure>(u32vector-segment u32vec n) -> list [SRFI 152]</procedure>

Returns a list of {{u32vectors}}, each of which contains n consecutive elements of {{u32vec}}. The last {{u32vector}} may be shorter than {{n}}.

<procedure>(u32vector-fold kons knil u32vec u32vec2 ...) -> object</procedure>

<procedure>(u32vector-fold-right kons knil u32vec u32vec2 ...) -> object</procedure>

When one {{u32vector}} argument {{u32vec}} is given, folds {{kons}} over the elements of {{u32vec}} in increasing/decreasing order using {{knil}} as the initial value. The {{kons}} procedure is called with the state first and the element second, as in SRFIs 43 and 133 (heterogeneous vectors). This is the opposite order to that used in SRFI 1 (lists) and the various string SRFIs.

When multiple {{u32vector}} arguments are given, {{kons}} is called with the current state value and each value from all the vectors; {{u32vector-fold}} scans elements from left to right, while {{u32vector-fold-right}} does from right to left. If the lengths of vectors differ, only the portion of each vector up to the length of the shortest vector is scanned.

<procedure>(u32vector-map f u32vec u32vec2 ...) -> u32vector</procedure>

<procedure>(u32vector-map! f u32vec u32vec2 ...) -> unspecified</procedure>

<procedure>(u32vector-for-each f u32vec u32vec2 ...) -> unspecified</procedure>

Iterate over the elements of {{u32vec}} and apply {{f}} to each, returning respectively a {{u32vector}} of the results, an undefined value with the results placed back in {{u32vec}}, and an undefined value with no change to {{u32vec}}.

If more than one vector is passed, {{f}} gets one element from each vector as arguments. If the lengths of the vectors differ, iteration stops at the end of the shortest vector. For {{u32vector-map!}}, only {{u32vec}} is modified even when multiple vectors are passed.

If {{u32vector-map}} or {{u32vector-map!}} returns more than once (i.e. because of a continuation captured by {{f}}), the values returned or stored by earlier returns may be mutated.

<procedure>(u32vector-count pred? u32vec u32vec2 ...) -> exact nonnegative integer</procedure>

Call {{pred?}} on each element of {{u32vec}} and return the number of calls that return true.

When multiple vectors are given, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are given for each iteration, which stops at the end of the shortest vector.

<procedure>(u32vector-cumulate f knil u32vec) -> u32vector</procedure>

Like {{u32vector-fold}}, but returns an {{u32vector}} of partial results rather than just the final result.
==== Searching
<procedure>(u32vector-take-while pred? u32vec) -> u32vector [SRFI 152]</procedure>

<procedure>(u32vector-take-while-right pred? u32vec) -> u32vector [SRFI 152]</procedure>

Return the shortest prefix/suffix of {{u32vec}} all of whose elements satisfy {{pred?}}.

<procedure>(u32vector-drop-while pred? u32vec) -> u32vector [SRFI 152]</procedure>

<procedure>(u32vector-drop-while-right pred? u32vec) -> u32vector [SRFI 152]</procedure>

Drops the longest initial prefix/suffix of {{u32vec}} such that all its elements satisfy pred.

<procedure>(u32vector-index pred? u32vec u32vec2 ...) -> exact nonnegative integer or #f</procedure>

<procedure>(u32vector-index-right pred? u32vec u32vec2 ...) -> exact nonnegative integer or #f</procedure>

Return the index of the first/last element of {{u32vec}} that satisfies {{pred?}}.

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are passed for each iteration. If the lengths of vectors differ, {{u32vector-index}} stops iteration at the end of the shortest one. Lengths of vectors must be the same for {{u32vector-index-right}}.

<procedure>(u32vector-skip pred? u32vec u32vec2 ...) -> exact nonnegative integer or #f</procedure>

<procedure>(u32vector-skip-right pred? u32vec u32vec2 ...) -> exact nonnegative integer or #f</procedure>

Returns the index of the first/last element of {{u32vec}} that does not satisfy {{pred?}}.

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are passed for each iteration. If the lengths of vectors differ, {{u32vector-skip}} stops iteration at the end of the shortest one. Lengths of vectors must be the same for {{u32vector-skip-right}}.

<procedure>(u32vector-any pred? u32vec u32vec2 ...) -> value or boolean</procedure>

Returns first non-false result of applying {{pred?}} on a element from the {{u32vec}}, or {{#f}} if there is no such element. If {{u32vec}} is empty, returns #t

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are passed for each iteration. If the lengths of vectors differ, it stops at the end of the shortest one.

<procedure>(u32vector-every pred? u32vec u32vec2 ...) -> value or boolean</procedure>

If all elements from {{u32vec}} satisfy {{pred?}}, return the last result of {{pred?}}. If not all do, return {{#f}}. If {{u32vec}} is empty, return #t

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector is passed for each iteration. If the lengths of vectors differ, it stops at the end of the shortest one.

<procedure>(u32vector-partition pred? u32vec) -> u32vector and integer</procedure>

Returns an {{u32vector}} of the same type as {{u32vec}}, but with all elements satisfying {{pred?}} in the leftmost part of the vector and the other elements in the remaining part. The order of elements is otherwise preserved. Returns two values, the new {{u32vector}} and the number of elements satisfying {{pred?}}.

<procedure>(u32vector-filter pred? u32vec) -> u32vector [SRFI 152]</procedure>

<procedure>(u32vector-remove pred? u32vec) -> u32vector [SRFI 152]</procedure>

Return an {{u32vector}} containing the elements of {{u32vec}} that satisfy / do not satisfy {{pred?}}.
==== Mutators
<procedure>(u32vector-set! u32vec i value) -> unspecified</procedure>

Sets the ith element of {{u32vec}} to value.

<procedure>(u32vector-swap! u32vec i j) -> unspecified</procedure>

Interchanges the ith and jth elements of {{u32vec}}.

<procedure>(u32vector-fill! u32vec fill [start [end]]) -> unspecified</procedure>

Fills the portion of {{u32vec}} from {{start}} to {{end}} with the value fill.

<procedure>(u32vector-reverse! u32vec [start [end]]) -> unspecified</procedure>

Reverses the portion of {{u32vec}} from {{start}} to {{end}}.

<procedure>(u32vector-copy! u32to at u32from [start [end]]) -> unspecified</procedure>

Copies the portion of {{u32from}} from {{start}} to {{end}} onto {{u32to}}, starting at index at.

<procedure>(u32vector-reverse-copy! u32to at u32from [start [end]]) -> unspecified</procedure>

The same as {{u32vector-copy!}}, but copies in reverse.

<procedure>(u32vector-unfold! f u32vec start end seed) -> u32vector</procedure>

Like vector-unfold, but the elements are copied into the vector {{u32vec}} starting at element {{start}} rather than into a newly allocated vector. Terminates when {{end}} - {{start}} elements have been generated.

<procedure>(u32vector-unfold-right! f u32vec start end seed) -> u32vector</procedure>

The same as {{u32vector-unfold!}}, but initializes the {{u32vector}} from right to left.
==== Conversion
<procedure>(u32vector->list u32vec [start [end]]) -> proper-list</procedure>

<procedure>(reverse-u32vector->list u32vec [start [end]]) -> proper-list</procedure>

<procedure>(list->u32vector proper-list) -> u32vector</procedure>

<procedure>(reverse-list->u32vector proper-list) -> u32vector</procedure>

<procedure>(u32vector->vector u32vec [start [end]]) -> vector</procedure>

<procedure>(vector->u32vector vec [start [end]]) -> u32vector</procedure>

Returns a list, {{u32vector}}, or heterogeneous vector with the same elements as the argument, in reverse order where specified.
==== Generators
<procedure>(make-u32vector-generator u32vector)</procedure>

Returns a [[https://srfi.schemers.org/srfi-121/srfi-121.html][SRFI 121]] generator that generates all the values of {{u32vector}} in order. Note that the generator is finite.
==== Comparators
{{u32vector-comparator}}

Variable containing a [[https://srfi.schemers.org/srfi-128/srfi-128.html][SRFI 128]] comparator whose components provide ordering and hashing of {{u32vectors}}.
==== Output
<procedure>(write-u32vector u32vec [ port ] ) -> unspecified</procedure>

Prints to port (the current output port by default) a representation of {{u32vec}} in the lexical syntax explained below.
=== Module (srfi 160 s32)
==== Constructors
<procedure>(make-s32vector size [fill]) -> s32vector</procedure>

Returns a {{s32vector}} whose length is size. If fill is provided, all the elements of the {{s32vector}} are initialized to it.

<procedure>(s32vector value ...) -> s32vector</procedure>

Returns a {{s32vector}} initialized with values.

<procedure>(s32vector-unfold f length seed) -> s32vector</procedure>

Creates a vector whose length is length and iterates across each index {{k}} between 0 and {{length - 1}}, applying {{f}} at each iteration to the current index and current state, in that order, to receive two values: the element to put in the kth slot of the new vector and a new state for the next iteration. On the first call to {{f}}, the state's value is seed.

<procedure>(s32vector-unfold-right f length seed) -> s32vector</procedure>

The same as s32vector-unfold, but initializes the {{s32vector}} from right to left.

<procedure>(s32vector-copy s32vec [start [end]]) -> s32vector</procedure>

Makes a copy of the portion of {{s32vec}} from {{start}} to {{end}} and returns it.

<procedure>(s32vector-reverse-copy s32vec [start [end]]) -> s32vector</procedure>

The same as {{s32vector-copy}}, but in reverse order.

<procedure>(s32vector-append s32vec ...) -> s32vector</procedure>

Returns a {{s32vector}} containing all the elements of the {{s32vecs}} in order.

<procedure>(s32vector-concatenate list-of-s32vectors) -> s32vector</procedure>

The same as {{s32vector-append}}, but takes a list of {{s32vectors}} rather than multiple arguments.

<procedure>(s32vector-append-subvectors [s32vec start end] ...) -> s32vector</procedure>

Concatenates the result of applying {{s32vector-copy}} to each triplet of {{s32vec}}, {{start}}, {{end}} arguments, but may be implemented more efficiently.
==== Predicates
<procedure>(s32? obj) -> boolean</procedure>

Returns {{#t}} if obj is a valid element of an {{s32vector}}, and {{#f}} otherwise.

<procedure>(s32vector? obj) -> boolean</procedure>

Returns {{#t}} if obj is a {{s32vector}}, and {{#f}} otherwise.

<procedure>(s32vector-empty? s32vec) -> boolean</procedure>

Returns {{#t}} if {{s32vec}} has a length of zero, and {{#f}} otherwise.

<procedure>(s32vector= s32vec ...) -> boolean</procedure>

Compares the {{s32vecs}} for elementwise equality, using = to do the comparisons. Returns {{#f}} unless all {{s32vectors}} are the same length.
==== Selectors
<procedure>(s32vector-ref s32vec i) -> value</procedure>

Returns the ith element of {{s32vec}}.

<procedure>(s32vector-length s32vec) -> exact nonnegative integer</procedure>

Returns the length of {{s32vec}}
==== Iteration
<procedure>(s32vector-take s32vec n) -> s32vector] [SRFI 152]</procedure>

<procedure>(s32vector-take-right s32vec n) -> s32vector [SRFI 152]</procedure>

Returns a {{s32vector}} containing the first/last {{n}} elements of {{s32vec}}.

<procedure>(s32vector-drop s32vec n) -> s32vector [SRFI 152]</procedure>

<procedure>(s32vector-drop-right s32vec n) -> s32vector [SRFI 152]</procedure>

Returns a {{s32vector}} containing all except the first/last {{n}} elements of {{s32vec}}.

<procedure>(s32vector-segment s32vec n) -> list [SRFI 152]</procedure>

Returns a list of {{s32vectors}}, each of which contains n consecutive elements of {{s32vec}}. The last {{s32vector}} may be shorter than {{n}}.

<procedure>(s32vector-fold kons knil s32vec s32vec2 ...) -> object</procedure>

<procedure>(s32vector-fold-right kons knil s32vec s32vec2 ...) -> object</procedure>

When one {{s32vector}} argument {{s32vec}} is given, folds {{kons}} over the elements of {{s32vec}} in increasing/decreasing order using {{knil}} as the initial value. The {{kons}} procedure is called with the state first and the element second, as in SRFIs 43 and 133 (heterogeneous vectors). This is the opposite order to that used in SRFI 1 (lists) and the various string SRFIs.

When multiple {{s32vector}} arguments are given, {{kons}} is called with the current state value and each value from all the vectors; {{s32vector-fold}} scans elements from left to right, while {{s32vector-fold-right}} does from right to left. If the lengths of vectors differ, only the portion of each vector up to the length of the shortest vector is scanned.

<procedure>(s32vector-map f s32vec s32vec2 ...) -> s32vector</procedure>

<procedure>(s32vector-map! f s32vec s32vec2 ...) -> unspecified</procedure>

<procedure>(s32vector-for-each f s32vec s32vec2 ...) -> unspecified</procedure>

Iterate over the elements of {{s32vec}} and apply {{f}} to each, returning respectively a {{s32vector}} of the results, an undefined value with the results placed back in {{s32vec}}, and an undefined value with no change to {{s32vec}}.

If more than one vector is passed, {{f}} gets one element from each vector as arguments. If the lengths of the vectors differ, iteration stops at the end of the shortest vector. For {{s32vector-map!}}, only {{s32vec}} is modified even when multiple vectors are passed.

If {{s32vector-map}} or {{s32vector-map!}} returns more than once (i.e. because of a continuation captured by {{f}}), the values returned or stored by earlier returns may be mutated.

<procedure>(s32vector-count pred? s32vec s32vec2 ...) -> exact nonnegative integer</procedure>

Call {{pred?}} on each element of {{s32vec}} and return the number of calls that return true.

When multiple vectors are given, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are given for each iteration, which stops at the end of the shortest vector.

<procedure>(s32vector-cumulate f knil s32vec) -> s32vector</procedure>

Like {{s32vector-fold}}, but returns an {{s32vector}} of partial results rather than just the final result.
==== Searching
<procedure>(s32vector-take-while pred? s32vec) -> s32vector [SRFI 152]</procedure>

<procedure>(s32vector-take-while-right pred? s32vec) -> s32vector [SRFI 152]</procedure>

Return the shortest prefix/suffix of {{s32vec}} all of whose elements satisfy {{pred?}}.

<procedure>(s32vector-drop-while pred? s32vec) -> s32vector [SRFI 152]</procedure>

<procedure>(s32vector-drop-while-right pred? s32vec) -> s32vector [SRFI 152]</procedure>

Drops the longest initial prefix/suffix of {{s32vec}} such that all its elements satisfy pred.

<procedure>(s32vector-index pred? s32vec s32vec2 ...) -> exact nonnegative integer or #f</procedure>

<procedure>(s32vector-index-right pred? s32vec s32vec2 ...) -> exact nonnegative integer or #f</procedure>

Return the index of the first/last element of {{s32vec}} that satisfies {{pred?}}.

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are passed for each iteration. If the lengths of vectors differ, {{s32vector-index}} stops iteration at the end of the shortest one. Lengths of vectors must be the same for {{s32vector-index-right}}.

<procedure>(s32vector-skip pred? s32vec s32vec2 ...) -> exact nonnegative integer or #f</procedure>

<procedure>(s32vector-skip-right pred? s32vec s32vec2 ...) -> exact nonnegative integer or #f</procedure>

Returns the index of the first/last element of {{s32vec}} that does not satisfy {{pred?}}.

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are passed for each iteration. If the lengths of vectors differ, {{s32vector-skip}} stops iteration at the end of the shortest one. Lengths of vectors must be the same for {{s32vector-skip-right}}.

<procedure>(s32vector-any pred? s32vec s32vec2 ...) -> value or boolean</procedure>

Returns first non-false result of applying {{pred?}} on a element from the {{s32vec}}, or {{#f}} if there is no such element. If {{s32vec}} is empty, returns #t

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are passed for each iteration. If the lengths of vectors differ, it stops at the end of the shortest one.

<procedure>(s32vector-every pred? s32vec s32vec2 ...) -> value or boolean</procedure>

If all elements from {{s32vec}} satisfy {{pred?}}, return the last result of {{pred?}}. If not all do, return {{#f}}. If {{s32vec}} is empty, return #t

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector is passed for each iteration. If the lengths of vectors differ, it stops at the end of the shortest one.

<procedure>(s32vector-partition pred? s32vec) -> s32vector and integer</procedure>

Returns an {{s32vector}} of the same type as {{s32vec}}, but with all elements satisfying {{pred?}} in the leftmost part of the vector and the other elements in the remaining part. The order of elements is otherwise preserved. Returns two values, the new {{s32vector}} and the number of elements satisfying {{pred?}}.

<procedure>(s32vector-filter pred? s32vec) -> s32vector [SRFI 152]</procedure>

<procedure>(s32vector-remove pred? s32vec) -> s32vector [SRFI 152]</procedure>

Return an {{s32vector}} containing the elements of {{s32vec}} that satisfy / do not satisfy {{pred?}}.
==== Mutators
<procedure>(s32vector-set! s32vec i value) -> unspecified</procedure>

Sets the ith element of {{s32vec}} to value.

<procedure>(s32vector-swap! s32vec i j) -> unspecified</procedure>

Interchanges the ith and jth elements of {{s32vec}}.

<procedure>(s32vector-fill! s32vec fill [start [end]]) -> unspecified</procedure>

Fills the portion of {{s32vec}} from {{start}} to {{end}} with the value fill.

<procedure>(s32vector-reverse! s32vec [start [end]]) -> unspecified</procedure>

Reverses the portion of {{s32vec}} from {{start}} to {{end}}.

<procedure>(s32vector-copy! s32to at s32from [start [end]]) -> unspecified</procedure>

Copies the portion of {{s32from}} from {{start}} to {{end}} onto {{s32to}}, starting at index at.

<procedure>(s32vector-reverse-copy! s32to at s32from [start [end]]) -> unspecified</procedure>

The same as {{s32vector-copy!}}, but copies in reverse.

<procedure>(s32vector-unfold! f s32vec start end seed) -> s32vector</procedure>

Like vector-unfold, but the elements are copied into the vector {{s32vec}} starting at element {{start}} rather than into a newly allocated vector. Terminates when {{end}} - {{start}} elements have been generated.

<procedure>(s32vector-unfold-right! f s32vec start end seed) -> s32vector</procedure>

The same as {{s32vector-unfold!}}, but initializes the {{s32vector}} from right to left.
==== Conversion
<procedure>(s32vector->list s32vec [start [end]]) -> proper-list</procedure>

<procedure>(reverse-s32vector->list s32vec [start [end]]) -> proper-list</procedure>

<procedure>(list->s32vector proper-list) -> s32vector</procedure>

<procedure>(reverse-list->s32vector proper-list) -> s32vector</procedure>

<procedure>(s32vector->vector s32vec [start [end]]) -> vector</procedure>

<procedure>(vector->s32vector vec [start [end]]) -> s32vector</procedure>

Returns a list, {{s32vector}}, or heterogeneous vector with the same elements as the argument, in reverse order where specified.
==== Generators
<procedure>(make-s32vector-generator s32vector)</procedure>

Returns a [[https://srfi.schemers.org/srfi-121/srfi-121.html][SRFI 121]] generator that generates all the values of {{s32vector}} in order. Note that the generator is finite.
==== Comparators
{{s32vector-comparator}}

Variable containing a [[https://srfi.schemers.org/srfi-128/srfi-128.html][SRFI 128]] comparator whose components provide ordering and hashing of {{s32vectors}}.
==== Output
<procedure>(write-s32vector s32vec [ port ] ) -> unspecified</procedure>

Prints to port (the current output port by default) a representation of {{s32vec}} in the lexical syntax explained below.
=== Module (srfi 160 u64)
==== Constructors
<procedure>(make-u64vector size [fill]) -> u64vector</procedure>

Returns a {{u64vector}} whose length is size. If fill is provided, all the elements of the {{u64vector}} are initialized to it.

<procedure>(u64vector value ...) -> u64vector</procedure>

Returns a {{u64vector}} initialized with values.

<procedure>(u64vector-unfold f length seed) -> u64vector</procedure>

Creates a vector whose length is length and iterates across each index {{k}} between 0 and {{length - 1}}, applying {{f}} at each iteration to the current index and current state, in that order, to receive two values: the element to put in the kth slot of the new vector and a new state for the next iteration. On the first call to {{f}}, the state's value is seed.

<procedure>(u64vector-unfold-right f length seed) -> u64vector</procedure>

The same as u64vector-unfold, but initializes the {{u64vector}} from right to left.

<procedure>(u64vector-copy u64vec [start [end]]) -> u64vector</procedure>

Makes a copy of the portion of {{u64vec}} from {{start}} to {{end}} and returns it.

<procedure>(u64vector-reverse-copy u64vec [start [end]]) -> u64vector</procedure>

The same as {{u64vector-copy}}, but in reverse order.

<procedure>(u64vector-append u64vec ...) -> u64vector</procedure>

Returns a {{u64vector}} containing all the elements of the {{u64vecs}} in order.

<procedure>(u64vector-concatenate list-of-u64vectors) -> u64vector</procedure>

The same as {{u64vector-append}}, but takes a list of {{u64vectors}} rather than multiple arguments.

<procedure>(u64vector-append-subvectors [u64vec start end] ...) -> u64vector</procedure>

Concatenates the result of applying {{u64vector-copy}} to each triplet of {{u64vec}}, {{start}}, {{end}} arguments, but may be implemented more efficiently.
==== Predicates
<procedure>(u64? obj) -> boolean</procedure>

Returns {{#t}} if obj is a valid element of an {{u64vector}}, and {{#f}} otherwise.

<procedure>(u64vector? obj) -> boolean</procedure>

Returns {{#t}} if obj is a {{u64vector}}, and {{#f}} otherwise.

<procedure>(u64vector-empty? u64vec) -> boolean</procedure>

Returns {{#t}} if {{u64vec}} has a length of zero, and {{#f}} otherwise.

<procedure>(u64vector= u64vec ...) -> boolean</procedure>

Compares the {{u64vecs}} for elementwise equality, using = to do the comparisons. Returns {{#f}} unless all {{u64vectors}} are the same length.
==== Selectors
<procedure>(u64vector-ref u64vec i) -> value</procedure>

Returns the ith element of {{u64vec}}.

<procedure>(u64vector-length u64vec) -> exact nonnegative integer</procedure>

Returns the length of {{u64vec}}
==== Iteration
<procedure>(u64vector-take u64vec n) -> u64vector] [SRFI 152]</procedure>

<procedure>(u64vector-take-right u64vec n) -> u64vector [SRFI 152]</procedure>

Returns a {{u64vector}} containing the first/last {{n}} elements of {{u64vec}}.

<procedure>(u64vector-drop u64vec n) -> u64vector [SRFI 152]</procedure>

<procedure>(u64vector-drop-right u64vec n) -> u64vector [SRFI 152]</procedure>

Returns a {{u64vector}} containing all except the first/last {{n}} elements of {{u64vec}}.

<procedure>(u64vector-segment u64vec n) -> list [SRFI 152]</procedure>

Returns a list of {{u64vectors}}, each of which contains n consecutive elements of {{u64vec}}. The last {{u64vector}} may be shorter than {{n}}.

<procedure>(u64vector-fold kons knil u64vec u64vec2 ...) -> object</procedure>

<procedure>(u64vector-fold-right kons knil u64vec u64vec2 ...) -> object</procedure>

When one {{u64vector}} argument {{u64vec}} is given, folds {{kons}} over the elements of {{u64vec}} in increasing/decreasing order using {{knil}} as the initial value. The {{kons}} procedure is called with the state first and the element second, as in SRFIs 43 and 133 (heterogeneous vectors). This is the opposite order to that used in SRFI 1 (lists) and the various string SRFIs.

When multiple {{u64vector}} arguments are given, {{kons}} is called with the current state value and each value from all the vectors; {{u64vector-fold}} scans elements from left to right, while {{u64vector-fold-right}} does from right to left. If the lengths of vectors differ, only the portion of each vector up to the length of the shortest vector is scanned.

<procedure>(u64vector-map f u64vec u64vec2 ...) -> u64vector</procedure>

<procedure>(u64vector-map! f u64vec u64vec2 ...) -> unspecified</procedure>

<procedure>(u64vector-for-each f u64vec u64vec2 ...) -> unspecified</procedure>

Iterate over the elements of {{u64vec}} and apply {{f}} to each, returning respectively a {{u64vector}} of the results, an undefined value with the results placed back in {{u64vec}}, and an undefined value with no change to {{u64vec}}.

If more than one vector is passed, {{f}} gets one element from each vector as arguments. If the lengths of the vectors differ, iteration stops at the end of the shortest vector. For {{u64vector-map!}}, only {{u64vec}} is modified even when multiple vectors are passed.

If {{u64vector-map}} or {{u64vector-map!}} returns more than once (i.e. because of a continuation captured by {{f}}), the values returned or stored by earlier returns may be mutated.

<procedure>(u64vector-count pred? u64vec u64vec2 ...) -> exact nonnegative integer</procedure>

Call {{pred?}} on each element of {{u64vec}} and return the number of calls that return true.

When multiple vectors are given, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are given for each iteration, which stops at the end of the shortest vector.

<procedure>(u64vector-cumulate f knil u64vec) -> u64vector</procedure>

Like {{u64vector-fold}}, but returns an {{u64vector}} of partial results rather than just the final result.
==== Searching
<procedure>(u64vector-take-while pred? u64vec) -> u64vector [SRFI 152]</procedure>

<procedure>(u64vector-take-while-right pred? u64vec) -> u64vector [SRFI 152]</procedure>

Return the shortest prefix/suffix of {{u64vec}} all of whose elements satisfy {{pred?}}.

<procedure>(u64vector-drop-while pred? u64vec) -> u64vector [SRFI 152]</procedure>

<procedure>(u64vector-drop-while-right pred? u64vec) -> u64vector [SRFI 152]</procedure>

Drops the longest initial prefix/suffix of {{u64vec}} such that all its elements satisfy pred.

<procedure>(u64vector-index pred? u64vec u64vec2 ...) -> exact nonnegative integer or #f</procedure>

<procedure>(u64vector-index-right pred? u64vec u64vec2 ...) -> exact nonnegative integer or #f</procedure>

Return the index of the first/last element of {{u64vec}} that satisfies {{pred?}}.

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are passed for each iteration. If the lengths of vectors differ, {{u64vector-index}} stops iteration at the end of the shortest one. Lengths of vectors must be the same for {{u64vector-index-right}}.

<procedure>(u64vector-skip pred? u64vec u64vec2 ...) -> exact nonnegative integer or #f</procedure>

<procedure>(u64vector-skip-right pred? u64vec u64vec2 ...) -> exact nonnegative integer or #f</procedure>

Returns the index of the first/last element of {{u64vec}} that does not satisfy {{pred?}}.

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are passed for each iteration. If the lengths of vectors differ, {{u64vector-skip}} stops iteration at the end of the shortest one. Lengths of vectors must be the same for {{u64vector-skip-right}}.

<procedure>(u64vector-any pred? u64vec u64vec2 ...) -> value or boolean</procedure>

Returns first non-false result of applying {{pred?}} on a element from the {{u64vec}}, or {{#f}} if there is no such element. If {{u64vec}} is empty, returns #t

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are passed for each iteration. If the lengths of vectors differ, it stops at the end of the shortest one.

<procedure>(u64vector-every pred? u64vec u64vec2 ...) -> value or boolean</procedure>

If all elements from {{u64vec}} satisfy {{pred?}}, return the last result of {{pred?}}. If not all do, return {{#f}}. If {{u64vec}} is empty, return #t

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector is passed for each iteration. If the lengths of vectors differ, it stops at the end of the shortest one.

<procedure>(u64vector-partition pred? u64vec) -> u64vector and integer</procedure>

Returns an {{u64vector}} of the same type as {{u64vec}}, but with all elements satisfying {{pred?}} in the leftmost part of the vector and the other elements in the remaining part. The order of elements is otherwise preserved. Returns two values, the new {{u64vector}} and the number of elements satisfying {{pred?}}.

<procedure>(u64vector-filter pred? u64vec) -> u64vector [SRFI 152]</procedure>

<procedure>(u64vector-remove pred? u64vec) -> u64vector [SRFI 152]</procedure>

Return an {{u64vector}} containing the elements of {{u64vec}} that satisfy / do not satisfy {{pred?}}.
==== Mutators
<procedure>(u64vector-set! u64vec i value) -> unspecified</procedure>

Sets the ith element of {{u64vec}} to value.

<procedure>(u64vector-swap! u64vec i j) -> unspecified</procedure>

Interchanges the ith and jth elements of {{u64vec}}.

<procedure>(u64vector-fill! u64vec fill [start [end]]) -> unspecified</procedure>

Fills the portion of {{u64vec}} from {{start}} to {{end}} with the value fill.

<procedure>(u64vector-reverse! u64vec [start [end]]) -> unspecified</procedure>

Reverses the portion of {{u64vec}} from {{start}} to {{end}}.

<procedure>(u64vector-copy! u64to at u64from [start [end]]) -> unspecified</procedure>

Copies the portion of {{u64from}} from {{start}} to {{end}} onto {{u64to}}, starting at index at.

<procedure>(u64vector-reverse-copy! u64to at u64from [start [end]]) -> unspecified</procedure>

The same as {{u64vector-copy!}}, but copies in reverse.

<procedure>(u64vector-unfold! f u64vec start end seed) -> u64vector</procedure>

Like vector-unfold, but the elements are copied into the vector {{u64vec}} starting at element {{start}} rather than into a newly allocated vector. Terminates when {{end}} - {{start}} elements have been generated.

<procedure>(u64vector-unfold-right! f u64vec start end seed) -> u64vector</procedure>

The same as {{u64vector-unfold!}}, but initializes the {{u64vector}} from right to left.
==== Conversion
<procedure>(u64vector->list u64vec [start [end]]) -> proper-list</procedure>

<procedure>(reverse-u64vector->list u64vec [start [end]]) -> proper-list</procedure>

<procedure>(list->u64vector proper-list) -> u64vector</procedure>

<procedure>(reverse-list->u64vector proper-list) -> u64vector</procedure>

<procedure>(u64vector->vector u64vec [start [end]]) -> vector</procedure>

<procedure>(vector->u64vector vec [start [end]]) -> u64vector</procedure>

Returns a list, {{u64vector}}, or heterogeneous vector with the same elements as the argument, in reverse order where specified.
==== Generators
<procedure>(make-u64vector-generator u64vector)</procedure>

Returns a [[https://srfi.schemers.org/srfi-121/srfi-121.html][SRFI 121]] generator that generates all the values of {{u64vector}} in order. Note that the generator is finite.
==== Comparators
{{u64vector-comparator}}

Variable containing a [[https://srfi.schemers.org/srfi-128/srfi-128.html][SRFI 128]] comparator whose components provide ordering and hashing of {{u64vectors}}.
==== Output
<procedure>(write-u64vector u64vec [ port ] ) -> unspecified</procedure>

Prints to port (the current output port by default) a representation of {{u64vec}} in the lexical syntax explained below.
=== Module (srfi 160 s64)
==== Constructors
<procedure>(make-s64vector size [fill]) -> s64vector</procedure>

Returns a {{s64vector}} whose length is size. If fill is provided, all the elements of the {{s64vector}} are initialized to it.

<procedure>(s64vector value ...) -> s64vector</procedure>

Returns a {{s64vector}} initialized with values.

<procedure>(s64vector-unfold f length seed) -> s64vector</procedure>

Creates a vector whose length is length and iterates across each index {{k}} between 0 and {{length - 1}}, applying {{f}} at each iteration to the current index and current state, in that order, to receive two values: the element to put in the kth slot of the new vector and a new state for the next iteration. On the first call to {{f}}, the state's value is seed.

<procedure>(s64vector-unfold-right f length seed) -> s64vector</procedure>

The same as s64vector-unfold, but initializes the {{s64vector}} from right to left.

<procedure>(s64vector-copy s64vec [start [end]]) -> s64vector</procedure>

Makes a copy of the portion of {{s64vec}} from {{start}} to {{end}} and returns it.

<procedure>(s64vector-reverse-copy s64vec [start [end]]) -> s64vector</procedure>

The same as {{s64vector-copy}}, but in reverse order.

<procedure>(s64vector-append s64vec ...) -> s64vector</procedure>

Returns a {{s64vector}} containing all the elements of the {{s64vecs}} in order.

<procedure>(s64vector-concatenate list-of-s64vectors) -> s64vector</procedure>

The same as {{s64vector-append}}, but takes a list of {{s64vectors}} rather than multiple arguments.

<procedure>(s64vector-append-subvectors [s64vec start end] ...) -> s64vector</procedure>

Concatenates the result of applying {{s64vector-copy}} to each triplet of {{s64vec}}, {{start}}, {{end}} arguments, but may be implemented more efficiently.
==== Predicates
<procedure>(s64? obj) -> boolean</procedure>

Returns {{#t}} if obj is a valid element of an {{s64vector}}, and {{#f}} otherwise.

<procedure>(s64vector? obj) -> boolean</procedure>

Returns {{#t}} if obj is a {{s64vector}}, and {{#f}} otherwise.

<procedure>(s64vector-empty? s64vec) -> boolean</procedure>

Returns {{#t}} if {{s64vec}} has a length of zero, and {{#f}} otherwise.

<procedure>(s64vector= s64vec ...) -> boolean</procedure>

Compares the {{s64vecs}} for elementwise equality, using = to do the comparisons. Returns {{#f}} unless all {{s64vectors}} are the same length.
==== Selectors
<procedure>(s64vector-ref s64vec i) -> value</procedure>

Returns the ith element of {{s64vec}}.

<procedure>(s64vector-length s64vec) -> exact nonnegative integer</procedure>

Returns the length of {{s64vec}}
==== Iteration
<procedure>(s64vector-take s64vec n) -> s64vector] [SRFI 152]</procedure>

<procedure>(s64vector-take-right s64vec n) -> s64vector [SRFI 152]</procedure>

Returns a {{s64vector}} containing the first/last {{n}} elements of {{s64vec}}.

<procedure>(s64vector-drop s64vec n) -> s64vector [SRFI 152]</procedure>

<procedure>(s64vector-drop-right s64vec n) -> s64vector [SRFI 152]</procedure>

Returns a {{s64vector}} containing all except the first/last {{n}} elements of {{s64vec}}.

<procedure>(s64vector-segment s64vec n) -> list [SRFI 152]</procedure>

Returns a list of {{s64vectors}}, each of which contains n consecutive elements of {{s64vec}}. The last {{s64vector}} may be shorter than {{n}}.

<procedure>(s64vector-fold kons knil s64vec s64vec2 ...) -> object</procedure>

<procedure>(s64vector-fold-right kons knil s64vec s64vec2 ...) -> object</procedure>

When one {{s64vector}} argument {{s64vec}} is given, folds {{kons}} over the elements of {{s64vec}} in increasing/decreasing order using {{knil}} as the initial value. The {{kons}} procedure is called with the state first and the element second, as in SRFIs 43 and 133 (heterogeneous vectors). This is the opposite order to that used in SRFI 1 (lists) and the various string SRFIs.

When multiple {{s64vector}} arguments are given, {{kons}} is called with the current state value and each value from all the vectors; {{s64vector-fold}} scans elements from left to right, while {{s64vector-fold-right}} does from right to left. If the lengths of vectors differ, only the portion of each vector up to the length of the shortest vector is scanned.

<procedure>(s64vector-map f s64vec s64vec2 ...) -> s64vector</procedure>

<procedure>(s64vector-map! f s64vec s64vec2 ...) -> unspecified</procedure>

<procedure>(s64vector-for-each f s64vec s64vec2 ...) -> unspecified</procedure>

Iterate over the elements of {{s64vec}} and apply {{f}} to each, returning respectively a {{s64vector}} of the results, an undefined value with the results placed back in {{s64vec}}, and an undefined value with no change to {{s64vec}}.

If more than one vector is passed, {{f}} gets one element from each vector as arguments. If the lengths of the vectors differ, iteration stops at the end of the shortest vector. For {{s64vector-map!}}, only {{s64vec}} is modified even when multiple vectors are passed.

If {{s64vector-map}} or {{s64vector-map!}} returns more than once (i.e. because of a continuation captured by {{f}}), the values returned or stored by earlier returns may be mutated.

<procedure>(s64vector-count pred? s64vec s64vec2 ...) -> exact nonnegative integer</procedure>

Call {{pred?}} on each element of {{s64vec}} and return the number of calls that return true.

When multiple vectors are given, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are given for each iteration, which stops at the end of the shortest vector.

<procedure>(s64vector-cumulate f knil s64vec) -> s64vector</procedure>

Like {{s64vector-fold}}, but returns an {{s64vector}} of partial results rather than just the final result.
==== Searching
<procedure>(s64vector-take-while pred? s64vec) -> s64vector [SRFI 152]</procedure>

<procedure>(s64vector-take-while-right pred? s64vec) -> s64vector [SRFI 152]</procedure>

Return the shortest prefix/suffix of {{s64vec}} all of whose elements satisfy {{pred?}}.

<procedure>(s64vector-drop-while pred? s64vec) -> s64vector [SRFI 152]</procedure>

<procedure>(s64vector-drop-while-right pred? s64vec) -> s64vector [SRFI 152]</procedure>

Drops the longest initial prefix/suffix of {{s64vec}} such that all its elements satisfy pred.

<procedure>(s64vector-index pred? s64vec s64vec2 ...) -> exact nonnegative integer or #f</procedure>

<procedure>(s64vector-index-right pred? s64vec s64vec2 ...) -> exact nonnegative integer or #f</procedure>

Return the index of the first/last element of {{s64vec}} that satisfies {{pred?}}.

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are passed for each iteration. If the lengths of vectors differ, {{s64vector-index}} stops iteration at the end of the shortest one. Lengths of vectors must be the same for {{s64vector-index-right}}.

<procedure>(s64vector-skip pred? s64vec s64vec2 ...) -> exact nonnegative integer or #f</procedure>

<procedure>(s64vector-skip-right pred? s64vec s64vec2 ...) -> exact nonnegative integer or #f</procedure>

Returns the index of the first/last element of {{s64vec}} that does not satisfy {{pred?}}.

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are passed for each iteration. If the lengths of vectors differ, {{s64vector-skip}} stops iteration at the end of the shortest one. Lengths of vectors must be the same for {{s64vector-skip-right}}.

<procedure>(s64vector-any pred? s64vec s64vec2 ...) -> value or boolean</procedure>

Returns first non-false result of applying {{pred?}} on a element from the {{s64vec}}, or {{#f}} if there is no such element. If {{s64vec}} is empty, returns #t

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are passed for each iteration. If the lengths of vectors differ, it stops at the end of the shortest one.

<procedure>(s64vector-every pred? s64vec s64vec2 ...) -> value or boolean</procedure>

If all elements from {{s64vec}} satisfy {{pred?}}, return the last result of {{pred?}}. If not all do, return {{#f}}. If {{s64vec}} is empty, return #t

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector is passed for each iteration. If the lengths of vectors differ, it stops at the end of the shortest one.

<procedure>(s64vector-partition pred? s64vec) -> s64vector and integer</procedure>

Returns an {{s64vector}} of the same type as {{s64vec}}, but with all elements satisfying {{pred?}} in the leftmost part of the vector and the other elements in the remaining part. The order of elements is otherwise preserved. Returns two values, the new {{s64vector}} and the number of elements satisfying {{pred?}}.

<procedure>(s64vector-filter pred? s64vec) -> s64vector [SRFI 152]</procedure>

<procedure>(s64vector-remove pred? s64vec) -> s64vector [SRFI 152]</procedure>

Return an {{s64vector}} containing the elements of {{s64vec}} that satisfy / do not satisfy {{pred?}}.
==== Mutators
<procedure>(s64vector-set! s64vec i value) -> unspecified</procedure>

Sets the ith element of {{s64vec}} to value.

<procedure>(s64vector-swap! s64vec i j) -> unspecified</procedure>

Interchanges the ith and jth elements of {{s64vec}}.

<procedure>(s64vector-fill! s64vec fill [start [end]]) -> unspecified</procedure>

Fills the portion of {{s64vec}} from {{start}} to {{end}} with the value fill.

<procedure>(s64vector-reverse! s64vec [start [end]]) -> unspecified</procedure>

Reverses the portion of {{s64vec}} from {{start}} to {{end}}.

<procedure>(s64vector-copy! s64to at s64from [start [end]]) -> unspecified</procedure>

Copies the portion of {{s64from}} from {{start}} to {{end}} onto {{s64to}}, starting at index at.

<procedure>(s64vector-reverse-copy! s64to at s64from [start [end]]) -> unspecified</procedure>

The same as {{s64vector-copy!}}, but copies in reverse.

<procedure>(s64vector-unfold! f s64vec start end seed) -> s64vector</procedure>

Like vector-unfold, but the elements are copied into the vector {{s64vec}} starting at element {{start}} rather than into a newly allocated vector. Terminates when {{end}} - {{start}} elements have been generated.

<procedure>(s64vector-unfold-right! f s64vec start end seed) -> s64vector</procedure>

The same as {{s64vector-unfold!}}, but initializes the {{s64vector}} from right to left.
==== Conversion
<procedure>(s64vector->list s64vec [start [end]]) -> proper-list</procedure>

<procedure>(reverse-s64vector->list s64vec [start [end]]) -> proper-list</procedure>

<procedure>(list->s64vector proper-list) -> s64vector</procedure>

<procedure>(reverse-list->s64vector proper-list) -> s64vector</procedure>

<procedure>(s64vector->vector s64vec [start [end]]) -> vector</procedure>

<procedure>(vector->s64vector vec [start [end]]) -> s64vector</procedure>

Returns a list, {{s64vector}}, or heterogeneous vector with the same elements as the argument, in reverse order where specified.
==== Generators
<procedure>(make-s64vector-generator s64vector)</procedure>

Returns a [[https://srfi.schemers.org/srfi-121/srfi-121.html][SRFI 121]] generator that generates all the values of {{s64vector}} in order. Note that the generator is finite.
==== Comparators
{{s64vector-comparator}}

Variable containing a [[https://srfi.schemers.org/srfi-128/srfi-128.html][SRFI 128]] comparator whose components provide ordering and hashing of {{s64vectors}}.
==== Output
<procedure>(write-s64vector s64vec [ port ] ) -> unspecified</procedure>

Prints to port (the current output port by default) a representation of {{s64vec}} in the lexical syntax explained below.
=== Module (srfi 160 f32)
==== Constructors
<procedure>(make-f32vector size [fill]) -> f32vector</procedure>

Returns a {{f32vector}} whose length is size. If fill is provided, all the elements of the {{f32vector}} are initialized to it.

<procedure>(f32vector value ...) -> f32vector</procedure>

Returns a {{f32vector}} initialized with values.

<procedure>(f32vector-unfold f length seed) -> f32vector</procedure>

Creates a vector whose length is length and iterates across each index {{k}} between 0 and {{length - 1}}, applying {{f}} at each iteration to the current index and current state, in that order, to receive two values: the element to put in the kth slot of the new vector and a new state for the next iteration. On the first call to {{f}}, the state's value is seed.

<procedure>(f32vector-unfold-right f length seed) -> f32vector</procedure>

The same as f32vector-unfold, but initializes the {{f32vector}} from right to left.

<procedure>(f32vector-copy f32vec [start [end]]) -> f32vector</procedure>

Makes a copy of the portion of {{f32vec}} from {{start}} to {{end}} and returns it.

<procedure>(f32vector-reverse-copy f32vec [start [end]]) -> f32vector</procedure>

The same as {{f32vector-copy}}, but in reverse order.

<procedure>(f32vector-append f32vec ...) -> f32vector</procedure>

Returns a {{f32vector}} containing all the elements of the {{f32vecs}} in order.

<procedure>(f32vector-concatenate list-of-f32vectors) -> f32vector</procedure>

The same as {{f32vector-append}}, but takes a list of {{f32vectors}} rather than multiple arguments.

<procedure>(f32vector-append-subvectors [f32vec start end] ...) -> f32vector</procedure>

Concatenates the result of applying {{f32vector-copy}} to each triplet of {{f32vec}}, {{start}}, {{end}} arguments, but may be implemented more efficiently.
==== Predicates
<procedure>(f32? obj) -> boolean</procedure>

Returns {{#t}} if obj is a valid element of an {{f32vector}}, and {{#f}} otherwise.

<procedure>(f32vector? obj) -> boolean</procedure>

Returns {{#t}} if obj is a {{f32vector}}, and {{#f}} otherwise.

<procedure>(f32vector-empty? f32vec) -> boolean</procedure>

Returns {{#t}} if {{f32vec}} has a length of zero, and {{#f}} otherwise.

<procedure>(f32vector= f32vec ...) -> boolean</procedure>

Compares the {{f32vecs}} for elementwise equality, using = to do the comparisons. Returns {{#f}} unless all {{f32vectors}} are the same length.
==== Selectors
<procedure>(f32vector-ref f32vec i) -> value</procedure>

Returns the ith element of {{f32vec}}.

<procedure>(f32vector-length f32vec) -> exact nonnegative integer</procedure>

Returns the length of {{f32vec}}
==== Iteration
<procedure>(f32vector-take f32vec n) -> f32vector] [SRFI 152]</procedure>

<procedure>(f32vector-take-right f32vec n) -> f32vector [SRFI 152]</procedure>

Returns a {{f32vector}} containing the first/last {{n}} elements of {{f32vec}}.

<procedure>(f32vector-drop f32vec n) -> f32vector [SRFI 152]</procedure>

<procedure>(f32vector-drop-right f32vec n) -> f32vector [SRFI 152]</procedure>

Returns a {{f32vector}} containing all except the first/last {{n}} elements of {{f32vec}}.

<procedure>(f32vector-segment f32vec n) -> list [SRFI 152]</procedure>

Returns a list of {{f32vectors}}, each of which contains n consecutive elements of {{f32vec}}. The last {{f32vector}} may be shorter than {{n}}.

<procedure>(f32vector-fold kons knil f32vec f32vec2 ...) -> object</procedure>

<procedure>(f32vector-fold-right kons knil f32vec f32vec2 ...) -> object</procedure>

When one {{f32vector}} argument {{f32vec}} is given, folds {{kons}} over the elements of {{f32vec}} in increasing/decreasing order using {{knil}} as the initial value. The {{kons}} procedure is called with the state first and the element second, as in SRFIs 43 and 133 (heterogeneous vectors). This is the opposite order to that used in SRFI 1 (lists) and the various string SRFIs.

When multiple {{f32vector}} arguments are given, {{kons}} is called with the current state value and each value from all the vectors; {{f32vector-fold}} scans elements from left to right, while {{f32vector-fold-right}} does from right to left. If the lengths of vectors differ, only the portion of each vector up to the length of the shortest vector is scanned.

<procedure>(f32vector-map f f32vec f32vec2 ...) -> f32vector</procedure>

<procedure>(f32vector-map! f f32vec f32vec2 ...) -> unspecified</procedure>

<procedure>(f32vector-for-each f f32vec f32vec2 ...) -> unspecified</procedure>

Iterate over the elements of {{f32vec}} and apply {{f}} to each, returning respectively a {{f32vector}} of the results, an undefined value with the results placed back in {{f32vec}}, and an undefined value with no change to {{f32vec}}.

If more than one vector is passed, {{f}} gets one element from each vector as arguments. If the lengths of the vectors differ, iteration stops at the end of the shortest vector. For {{f32vector-map!}}, only {{f32vec}} is modified even when multiple vectors are passed.

If {{f32vector-map}} or {{f32vector-map!}} returns more than once (i.e. because of a continuation captured by {{f}}), the values returned or stored by earlier returns may be mutated.

<procedure>(f32vector-count pred? f32vec f32vec2 ...) -> exact nonnegative integer</procedure>

Call {{pred?}} on each element of {{f32vec}} and return the number of calls that return true.

When multiple vectors are given, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are given for each iteration, which stops at the end of the shortest vector.

<procedure>(f32vector-cumulate f knil f32vec) -> f32vector</procedure>

Like {{f32vector-fold}}, but returns an {{f32vector}} of partial results rather than just the final result.
==== Searching
<procedure>(f32vector-take-while pred? f32vec) -> f32vector [SRFI 152]</procedure>

<procedure>(f32vector-take-while-right pred? f32vec) -> f32vector [SRFI 152]</procedure>

Return the shortest prefix/suffix of {{f32vec}} all of whose elements satisfy {{pred?}}.

<procedure>(f32vector-drop-while pred? f32vec) -> f32vector [SRFI 152]</procedure>

<procedure>(f32vector-drop-while-right pred? f32vec) -> f32vector [SRFI 152]</procedure>

Drops the longest initial prefix/suffix of {{f32vec}} such that all its elements satisfy pred.

<procedure>(f32vector-index pred? f32vec f32vec2 ...) -> exact nonnegative integer or #f</procedure>

<procedure>(f32vector-index-right pred? f32vec f32vec2 ...) -> exact nonnegative integer or #f</procedure>

Return the index of the first/last element of {{f32vec}} that satisfies {{pred?}}.

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are passed for each iteration. If the lengths of vectors differ, {{f32vector-index}} stops iteration at the end of the shortest one. Lengths of vectors must be the same for {{f32vector-index-right}}.

<procedure>(f32vector-skip pred? f32vec f32vec2 ...) -> exact nonnegative integer or #f</procedure>

<procedure>(f32vector-skip-right pred? f32vec f32vec2 ...) -> exact nonnegative integer or #f</procedure>

Returns the index of the first/last element of {{f32vec}} that does not satisfy {{pred?}}.

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are passed for each iteration. If the lengths of vectors differ, {{f32vector-skip}} stops iteration at the end of the shortest one. Lengths of vectors must be the same for {{f32vector-skip-right}}.

<procedure>(f32vector-any pred? f32vec f32vec2 ...) -> value or boolean</procedure>

Returns first non-false result of applying {{pred?}} on a element from the {{f32vec}}, or {{#f}} if there is no such element. If {{f32vec}} is empty, returns #t

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are passed for each iteration. If the lengths of vectors differ, it stops at the end of the shortest one.

<procedure>(f32vector-every pred? f32vec f32vec2 ...) -> value or boolean</procedure>

If all elements from {{f32vec}} satisfy {{pred?}}, return the last result of {{pred?}}. If not all do, return {{#f}}. If {{f32vec}} is empty, return #t

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector is passed for each iteration. If the lengths of vectors differ, it stops at the end of the shortest one.

<procedure>(f32vector-partition pred? f32vec) -> f32vector and integer</procedure>

Returns an {{f32vector}} of the same type as {{f32vec}}, but with all elements satisfying {{pred?}} in the leftmost part of the vector and the other elements in the remaining part. The order of elements is otherwise preserved. Returns two values, the new {{f32vector}} and the number of elements satisfying {{pred?}}.

<procedure>(f32vector-filter pred? f32vec) -> f32vector [SRFI 152]</procedure>

<procedure>(f32vector-remove pred? f32vec) -> f32vector [SRFI 152]</procedure>

Return an {{f32vector}} containing the elements of {{f32vec}} that satisfy / do not satisfy {{pred?}}.
==== Mutators
<procedure>(f32vector-set! f32vec i value) -> unspecified</procedure>

Sets the ith element of {{f32vec}} to value.

<procedure>(f32vector-swap! f32vec i j) -> unspecified</procedure>

Interchanges the ith and jth elements of {{f32vec}}.

<procedure>(f32vector-fill! f32vec fill [start [end]]) -> unspecified</procedure>

Fills the portion of {{f32vec}} from {{start}} to {{end}} with the value fill.

<procedure>(f32vector-reverse! f32vec [start [end]]) -> unspecified</procedure>

Reverses the portion of {{f32vec}} from {{start}} to {{end}}.

<procedure>(f32vector-copy! f32to at f32from [start [end]]) -> unspecified</procedure>

Copies the portion of {{f32from}} from {{start}} to {{end}} onto {{f32to}}, starting at index at.

<procedure>(f32vector-reverse-copy! f32to at f32from [start [end]]) -> unspecified</procedure>

The same as {{f32vector-copy!}}, but copies in reverse.

<procedure>(f32vector-unfold! f f32vec start end seed) -> f32vector</procedure>

Like vector-unfold, but the elements are copied into the vector {{f32vec}} starting at element {{start}} rather than into a newly allocated vector. Terminates when {{end}} - {{start}} elements have been generated.

<procedure>(f32vector-unfold-right! f f32vec start end seed) -> f32vector</procedure>

The same as {{f32vector-unfold!}}, but initializes the {{f32vector}} from right to left.
==== Conversion
<procedure>(f32vector->list f32vec [start [end]]) -> proper-list</procedure>

<procedure>(reverse-f32vector->list f32vec [start [end]]) -> proper-list</procedure>

<procedure>(list->f32vector proper-list) -> f32vector</procedure>

<procedure>(reverse-list->f32vector proper-list) -> f32vector</procedure>

<procedure>(f32vector->vector f32vec [start [end]]) -> vector</procedure>

<procedure>(vector->f32vector vec [start [end]]) -> f32vector</procedure>

Returns a list, {{f32vector}}, or heterogeneous vector with the same elements as the argument, in reverse order where specified.
==== Generators
<procedure>(make-f32vector-generator f32vector)</procedure>

Returns a [[https://srfi.schemers.org/srfi-121/srfi-121.html][SRFI 121]] generator that generates all the values of {{f32vector}} in order. Note that the generator is finite.
==== Comparators
{{f32vector-comparator}}

Variable containing a [[https://srfi.schemers.org/srfi-128/srfi-128.html][SRFI 128]] comparator whose components provide ordering and hashing of {{f32vectors}}.
==== Output
<procedure>(write-f32vector f32vec [ port ] ) -> unspecified</procedure>

Prints to port (the current output port by default) a representation of {{f32vec}} in the lexical syntax explained below.
=== Module (srfi 160 f64)
==== Constructors
<procedure>(make-f64vector size [fill]) -> f64vector</procedure>

Returns a {{f64vector}} whose length is size. If fill is provided, all the elements of the {{f64vector}} are initialized to it.

<procedure>(f64vector value ...) -> f64vector</procedure>

Returns a {{f64vector}} initialized with values.

<procedure>(f64vector-unfold f length seed) -> f64vector</procedure>

Creates a vector whose length is length and iterates across each index {{k}} between 0 and {{length - 1}}, applying {{f}} at each iteration to the current index and current state, in that order, to receive two values: the element to put in the kth slot of the new vector and a new state for the next iteration. On the first call to {{f}}, the state's value is seed.

<procedure>(f64vector-unfold-right f length seed) -> f64vector</procedure>

The same as f64vector-unfold, but initializes the {{f64vector}} from right to left.

<procedure>(f64vector-copy f64vec [start [end]]) -> f64vector</procedure>

Makes a copy of the portion of {{f64vec}} from {{start}} to {{end}} and returns it.

<procedure>(f64vector-reverse-copy f64vec [start [end]]) -> f64vector</procedure>

The same as {{f64vector-copy}}, but in reverse order.

<procedure>(f64vector-append f64vec ...) -> f64vector</procedure>

Returns a {{f64vector}} containing all the elements of the {{f64vecs}} in order.

<procedure>(f64vector-concatenate list-of-f64vectors) -> f64vector</procedure>

The same as {{f64vector-append}}, but takes a list of {{f64vectors}} rather than multiple arguments.

<procedure>(f64vector-append-subvectors [f64vec start end] ...) -> f64vector</procedure>

Concatenates the result of applying {{f64vector-copy}} to each triplet of {{f64vec}}, {{start}}, {{end}} arguments, but may be implemented more efficiently.
==== Predicates
<procedure>(f64? obj) -> boolean</procedure>

Returns {{#t}} if obj is a valid element of an {{f64vector}}, and {{#f}} otherwise.

<procedure>(f64vector? obj) -> boolean</procedure>

Returns {{#t}} if obj is a {{f64vector}}, and {{#f}} otherwise.

<procedure>(f64vector-empty? f64vec) -> boolean</procedure>

Returns {{#t}} if {{f64vec}} has a length of zero, and {{#f}} otherwise.

<procedure>(f64vector= f64vec ...) -> boolean</procedure>

Compares the {{f64vecs}} for elementwise equality, using = to do the comparisons. Returns {{#f}} unless all {{f64vectors}} are the same length.
==== Selectors
<procedure>(f64vector-ref f64vec i) -> value</procedure>

Returns the ith element of {{f64vec}}.

<procedure>(f64vector-length f64vec) -> exact nonnegative integer</procedure>

Returns the length of {{f64vec}}
==== Iteration
<procedure>(f64vector-take f64vec n) -> f64vector] [SRFI 152]</procedure>

<procedure>(f64vector-take-right f64vec n) -> f64vector [SRFI 152]</procedure>

Returns a {{f64vector}} containing the first/last {{n}} elements of {{f64vec}}.

<procedure>(f64vector-drop f64vec n) -> f64vector [SRFI 152]</procedure>

<procedure>(f64vector-drop-right f64vec n) -> f64vector [SRFI 152]</procedure>

Returns a {{f64vector}} containing all except the first/last {{n}} elements of {{f64vec}}.

<procedure>(f64vector-segment f64vec n) -> list [SRFI 152]</procedure>

Returns a list of {{f64vectors}}, each of which contains n consecutive elements of {{f64vec}}. The last {{f64vector}} may be shorter than {{n}}.

<procedure>(f64vector-fold kons knil f64vec f64vec2 ...) -> object</procedure>

<procedure>(f64vector-fold-right kons knil f64vec f64vec2 ...) -> object</procedure>

When one {{f64vector}} argument {{f64vec}} is given, folds {{kons}} over the elements of {{f64vec}} in increasing/decreasing order using {{knil}} as the initial value. The {{kons}} procedure is called with the state first and the element second, as in SRFIs 43 and 133 (heterogeneous vectors). This is the opposite order to that used in SRFI 1 (lists) and the various string SRFIs.

When multiple {{f64vector}} arguments are given, {{kons}} is called with the current state value and each value from all the vectors; {{f64vector-fold}} scans elements from left to right, while {{f64vector-fold-right}} does from right to left. If the lengths of vectors differ, only the portion of each vector up to the length of the shortest vector is scanned.

<procedure>(f64vector-map f f64vec f64vec2 ...) -> f64vector</procedure>

<procedure>(f64vector-map! f f64vec f64vec2 ...) -> unspecified</procedure>

<procedure>(f64vector-for-each f f64vec f64vec2 ...) -> unspecified</procedure>

Iterate over the elements of {{f64vec}} and apply {{f}} to each, returning respectively a {{f64vector}} of the results, an undefined value with the results placed back in {{f64vec}}, and an undefined value with no change to {{f64vec}}.

If more than one vector is passed, {{f}} gets one element from each vector as arguments. If the lengths of the vectors differ, iteration stops at the end of the shortest vector. For {{f64vector-map!}}, only {{f64vec}} is modified even when multiple vectors are passed.

If {{f64vector-map}} or {{f64vector-map!}} returns more than once (i.e. because of a continuation captured by {{f}}), the values returned or stored by earlier returns may be mutated.

<procedure>(f64vector-count pred? f64vec f64vec2 ...) -> exact nonnegative integer</procedure>

Call {{pred?}} on each element of {{f64vec}} and return the number of calls that return true.

When multiple vectors are given, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are given for each iteration, which stops at the end of the shortest vector.

<procedure>(f64vector-cumulate f knil f64vec) -> f64vector</procedure>

Like {{f64vector-fold}}, but returns an {{f64vector}} of partial results rather than just the final result.
==== Searching
<procedure>(f64vector-take-while pred? f64vec) -> f64vector [SRFI 152]</procedure>

<procedure>(f64vector-take-while-right pred? f64vec) -> f64vector [SRFI 152]</procedure>

Return the shortest prefix/suffix of {{f64vec}} all of whose elements satisfy {{pred?}}.

<procedure>(f64vector-drop-while pred? f64vec) -> f64vector [SRFI 152]</procedure>

<procedure>(f64vector-drop-while-right pred? f64vec) -> f64vector [SRFI 152]</procedure>

Drops the longest initial prefix/suffix of {{f64vec}} such that all its elements satisfy pred.

<procedure>(f64vector-index pred? f64vec f64vec2 ...) -> exact nonnegative integer or #f</procedure>

<procedure>(f64vector-index-right pred? f64vec f64vec2 ...) -> exact nonnegative integer or #f</procedure>

Return the index of the first/last element of {{f64vec}} that satisfies {{pred?}}.

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are passed for each iteration. If the lengths of vectors differ, {{f64vector-index}} stops iteration at the end of the shortest one. Lengths of vectors must be the same for {{f64vector-index-right}}.

<procedure>(f64vector-skip pred? f64vec f64vec2 ...) -> exact nonnegative integer or #f</procedure>

<procedure>(f64vector-skip-right pred? f64vec f64vec2 ...) -> exact nonnegative integer or #f</procedure>

Returns the index of the first/last element of {{f64vec}} that does not satisfy {{pred?}}.

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are passed for each iteration. If the lengths of vectors differ, {{f64vector-skip}} stops iteration at the end of the shortest one. Lengths of vectors must be the same for {{f64vector-skip-right}}.

<procedure>(f64vector-any pred? f64vec f64vec2 ...) -> value or boolean</procedure>

Returns first non-false result of applying {{pred?}} on a element from the {{f64vec}}, or {{#f}} if there is no such element. If {{f64vec}} is empty, returns #t

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are passed for each iteration. If the lengths of vectors differ, it stops at the end of the shortest one.

<procedure>(f64vector-every pred? f64vec f64vec2 ...) -> value or boolean</procedure>

If all elements from {{f64vec}} satisfy {{pred?}}, return the last result of {{pred?}}. If not all do, return {{#f}}. If {{f64vec}} is empty, return #t

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector is passed for each iteration. If the lengths of vectors differ, it stops at the end of the shortest one.

<procedure>(f64vector-partition pred? f64vec) -> f64vector and integer</procedure>

Returns an {{f64vector}} of the same type as {{f64vec}}, but with all elements satisfying {{pred?}} in the leftmost part of the vector and the other elements in the remaining part. The order of elements is otherwise preserved. Returns two values, the new {{f64vector}} and the number of elements satisfying {{pred?}}.

<procedure>(f64vector-filter pred? f64vec) -> f64vector [SRFI 152]</procedure>

<procedure>(f64vector-remove pred? f64vec) -> f64vector [SRFI 152]</procedure>

Return an {{f64vector}} containing the elements of {{f64vec}} that satisfy / do not satisfy {{pred?}}.
==== Mutators
<procedure>(f64vector-set! f64vec i value) -> unspecified</procedure>

Sets the ith element of {{f64vec}} to value.

<procedure>(f64vector-swap! f64vec i j) -> unspecified</procedure>

Interchanges the ith and jth elements of {{f64vec}}.

<procedure>(f64vector-fill! f64vec fill [start [end]]) -> unspecified</procedure>

Fills the portion of {{f64vec}} from {{start}} to {{end}} with the value fill.

<procedure>(f64vector-reverse! f64vec [start [end]]) -> unspecified</procedure>

Reverses the portion of {{f64vec}} from {{start}} to {{end}}.

<procedure>(f64vector-copy! f64to at f64from [start [end]]) -> unspecified</procedure>

Copies the portion of {{f64from}} from {{start}} to {{end}} onto {{f64to}}, starting at index at.

<procedure>(f64vector-reverse-copy! f64to at f64from [start [end]]) -> unspecified</procedure>

The same as {{f64vector-copy!}}, but copies in reverse.

<procedure>(f64vector-unfold! f f64vec start end seed) -> f64vector</procedure>

Like vector-unfold, but the elements are copied into the vector {{f64vec}} starting at element {{start}} rather than into a newly allocated vector. Terminates when {{end}} - {{start}} elements have been generated.

<procedure>(f64vector-unfold-right! f f64vec start end seed) -> f64vector</procedure>

The same as {{f64vector-unfold!}}, but initializes the {{f64vector}} from right to left.
==== Conversion
<procedure>(f64vector->list f64vec [start [end]]) -> proper-list</procedure>

<procedure>(reverse-f64vector->list f64vec [start [end]]) -> proper-list</procedure>

<procedure>(list->f64vector proper-list) -> f64vector</procedure>

<procedure>(reverse-list->f64vector proper-list) -> f64vector</procedure>

<procedure>(f64vector->vector f64vec [start [end]]) -> vector</procedure>

<procedure>(vector->f64vector vec [start [end]]) -> f64vector</procedure>

Returns a list, {{f64vector}}, or heterogeneous vector with the same elements as the argument, in reverse order where specified.
==== Generators
<procedure>(make-f64vector-generator f64vector)</procedure>

Returns a [[https://srfi.schemers.org/srfi-121/srfi-121.html][SRFI 121]] generator that generates all the values of {{f64vector}} in order. Note that the generator is finite.
==== Comparators
{{f64vector-comparator}}

Variable containing a [[https://srfi.schemers.org/srfi-128/srfi-128.html][SRFI 128]] comparator whose components provide ordering and hashing of {{f64vectors}}.
==== Output
<procedure>(write-f64vector f64vec [ port ] ) -> unspecified</procedure>

Prints to port (the current output port by default) a representation of {{f64vec}} in the lexical syntax explained below.
=== Module (srfi 160 c64)
==== Constructors
<procedure>(make-c64vector size [fill]) -> c64vector</procedure>

Returns a {{c64vector}} whose length is size. If fill is provided, all the elements of the {{c64vector}} are initialized to it.

<procedure>(c64vector value ...) -> c64vector</procedure>

Returns a {{c64vector}} initialized with values.

<procedure>(c64vector-unfold f length seed) -> c64vector</procedure>

Creates a vector whose length is length and iterates across each index {{k}} between 0 and {{length - 1}}, applying {{f}} at each iteration to the current index and current state, in that order, to receive two values: the element to put in the kth slot of the new vector and a new state for the next iteration. On the first call to {{f}}, the state's value is seed.

<procedure>(c64vector-unfold-right f length seed) -> c64vector</procedure>

The same as c64vector-unfold, but initializes the {{c64vector}} from right to left.

<procedure>(c64vector-copy c64vec [start [end]]) -> c64vector</procedure>

Makes a copy of the portion of {{c64vec}} from {{start}} to {{end}} and returns it.

<procedure>(c64vector-reverse-copy c64vec [start [end]]) -> c64vector</procedure>

The same as {{c64vector-copy}}, but in reverse order.

<procedure>(c64vector-append c64vec ...) -> c64vector</procedure>

Returns a {{c64vector}} containing all the elements of the {{c64vecs}} in order.

<procedure>(c64vector-concatenate list-of-c64vectors) -> c64vector</procedure>

The same as {{c64vector-append}}, but takes a list of {{c64vectors}} rather than multiple arguments.

<procedure>(c64vector-append-subvectors [c64vec start end] ...) -> c64vector</procedure>

Concatenates the result of applying {{c64vector-copy}} to each triplet of {{c64vec}}, {{start}}, {{end}} arguments, but may be implemented more efficiently.
==== Predicates
<procedure>(c64? obj) -> boolean</procedure>

Returns {{#t}} if obj is a valid element of an {{c64vector}}, and {{#f}} otherwise.

<procedure>(c64vector? obj) -> boolean</procedure>

Returns {{#t}} if obj is a {{c64vector}}, and {{#f}} otherwise.

<procedure>(c64vector-empty? c64vec) -> boolean</procedure>

Returns {{#t}} if {{c64vec}} has a length of zero, and {{#f}} otherwise.

<procedure>(c64vector= c64vec ...) -> boolean</procedure>

Compares the {{c64vecs}} for elementwise equality, using = to do the comparisons. Returns {{#f}} unless all {{c64vectors}} are the same length.
==== Selectors
<procedure>(c64vector-ref c64vec i) -> value</procedure>

Returns the ith element of {{c64vec}}.

<procedure>(c64vector-length c64vec) -> exact nonnegative integer</procedure>

Returns the length of {{c64vec}}
==== Iteration
<procedure>(c64vector-take c64vec n) -> c64vector] [SRFI 152]</procedure>

<procedure>(c64vector-take-right c64vec n) -> c64vector [SRFI 152]</procedure>

Returns a {{c64vector}} containing the first/last {{n}} elements of {{c64vec}}.

<procedure>(c64vector-drop c64vec n) -> c64vector [SRFI 152]</procedure>

<procedure>(c64vector-drop-right c64vec n) -> c64vector [SRFI 152]</procedure>

Returns a {{c64vector}} containing all except the first/last {{n}} elements of {{c64vec}}.

<procedure>(c64vector-segment c64vec n) -> list [SRFI 152]</procedure>

Returns a list of {{c64vectors}}, each of which contains n consecutive elements of {{c64vec}}. The last {{c64vector}} may be shorter than {{n}}.

<procedure>(c64vector-fold kons knil c64vec c64vec2 ...) -> object</procedure>

<procedure>(c64vector-fold-right kons knil c64vec c64vec2 ...) -> object</procedure>

When one {{c64vector}} argument {{c64vec}} is given, folds {{kons}} over the elements of {{c64vec}} in increasing/decreasing order using {{knil}} as the initial value. The {{kons}} procedure is called with the state first and the element second, as in SRFIs 43 and 133 (heterogeneous vectors). This is the opposite order to that used in SRFI 1 (lists) and the various string SRFIs.

When multiple {{c64vector}} arguments are given, {{kons}} is called with the current state value and each value from all the vectors; {{c64vector-fold}} scans elements from left to right, while {{c64vector-fold-right}} does from right to left. If the lengths of vectors differ, only the portion of each vector up to the length of the shortest vector is scanned.

<procedure>(c64vector-map f c64vec c64vec2 ...) -> c64vector</procedure>

<procedure>(c64vector-map! f c64vec c64vec2 ...) -> unspecified</procedure>

<procedure>(c64vector-for-each f c64vec c64vec2 ...) -> unspecified</procedure>

Iterate over the elements of {{c64vec}} and apply {{f}} to each, returning respectively a {{c64vector}} of the results, an undefined value with the results placed back in {{c64vec}}, and an undefined value with no change to {{c64vec}}.

If more than one vector is passed, {{f}} gets one element from each vector as arguments. If the lengths of the vectors differ, iteration stops at the end of the shortest vector. For {{c64vector-map!}}, only {{c64vec}} is modified even when multiple vectors are passed.

If {{c64vector-map}} or {{c64vector-map!}} returns more than once (i.e. because of a continuation captured by {{f}}), the values returned or stored by earlier returns may be mutated.

<procedure>(c64vector-count pred? c64vec c64vec2 ...) -> exact nonnegative integer</procedure>

Call {{pred?}} on each element of {{c64vec}} and return the number of calls that return true.

When multiple vectors are given, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are given for each iteration, which stops at the end of the shortest vector.

<procedure>(c64vector-cumulate f knil c64vec) -> c64vector</procedure>

Like {{c64vector-fold}}, but returns an {{c64vector}} of partial results rather than just the final result.
==== Searching
<procedure>(c64vector-take-while pred? c64vec) -> c64vector [SRFI 152]</procedure>

<procedure>(c64vector-take-while-right pred? c64vec) -> c64vector [SRFI 152]</procedure>

Return the shortest prefix/suffix of {{c64vec}} all of whose elements satisfy {{pred?}}.

<procedure>(c64vector-drop-while pred? c64vec) -> c64vector [SRFI 152]</procedure>

<procedure>(c64vector-drop-while-right pred? c64vec) -> c64vector [SRFI 152]</procedure>

Drops the longest initial prefix/suffix of {{c64vec}} such that all its elements satisfy pred.

<procedure>(c64vector-index pred? c64vec c64vec2 ...) -> exact nonnegative integer or #f</procedure>

<procedure>(c64vector-index-right pred? c64vec c64vec2 ...) -> exact nonnegative integer or #f</procedure>

Return the index of the first/last element of {{c64vec}} that satisfies {{pred?}}.

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are passed for each iteration. If the lengths of vectors differ, {{c64vector-index}} stops iteration at the end of the shortest one. Lengths of vectors must be the same for {{c64vector-index-right}}.

<procedure>(c64vector-skip pred? c64vec c64vec2 ...) -> exact nonnegative integer or #f</procedure>

<procedure>(c64vector-skip-right pred? c64vec c64vec2 ...) -> exact nonnegative integer or #f</procedure>

Returns the index of the first/last element of {{c64vec}} that does not satisfy {{pred?}}.

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are passed for each iteration. If the lengths of vectors differ, {{c64vector-skip}} stops iteration at the end of the shortest one. Lengths of vectors must be the same for {{c64vector-skip-right}}.

<procedure>(c64vector-any pred? c64vec c64vec2 ...) -> value or boolean</procedure>

Returns first non-false result of applying {{pred?}} on a element from the {{c64vec}}, or {{#f}} if there is no such element. If {{c64vec}} is empty, returns #t

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are passed for each iteration. If the lengths of vectors differ, it stops at the end of the shortest one.

<procedure>(c64vector-every pred? c64vec c64vec2 ...) -> value or boolean</procedure>

If all elements from {{c64vec}} satisfy {{pred?}}, return the last result of {{pred?}}. If not all do, return {{#f}}. If {{c64vec}} is empty, return #t

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector is passed for each iteration. If the lengths of vectors differ, it stops at the end of the shortest one.

<procedure>(c64vector-partition pred? c64vec) -> c64vector and integer</procedure>

Returns an {{c64vector}} of the same type as {{c64vec}}, but with all elements satisfying {{pred?}} in the leftmost part of the vector and the other elements in the remaining part. The order of elements is otherwise preserved. Returns two values, the new {{c64vector}} and the number of elements satisfying {{pred?}}.

<procedure>(c64vector-filter pred? c64vec) -> c64vector [SRFI 152]</procedure>

<procedure>(c64vector-remove pred? c64vec) -> c64vector [SRFI 152]</procedure>

Return an {{c64vector}} containing the elements of {{c64vec}} that satisfy / do not satisfy {{pred?}}.
==== Mutators
<procedure>(c64vector-set! c64vec i value) -> unspecified</procedure>

Sets the ith element of {{c64vec}} to value.

<procedure>(c64vector-swap! c64vec i j) -> unspecified</procedure>

Interchanges the ith and jth elements of {{c64vec}}.

<procedure>(c64vector-fill! c64vec fill [start [end]]) -> unspecified</procedure>

Fills the portion of {{c64vec}} from {{start}} to {{end}} with the value fill.

<procedure>(c64vector-reverse! c64vec [start [end]]) -> unspecified</procedure>

Reverses the portion of {{c64vec}} from {{start}} to {{end}}.

<procedure>(c64vector-copy! c64to at c64from [start [end]]) -> unspecified</procedure>

Copies the portion of {{c64from}} from {{start}} to {{end}} onto {{c64to}}, starting at index at.

<procedure>(c64vector-reverse-copy! c64to at c64from [start [end]]) -> unspecified</procedure>

The same as {{c64vector-copy!}}, but copies in reverse.

<procedure>(c64vector-unfold! f c64vec start end seed) -> c64vector</procedure>

Like vector-unfold, but the elements are copied into the vector {{c64vec}} starting at element {{start}} rather than into a newly allocated vector. Terminates when {{end}} - {{start}} elements have been generated.

<procedure>(c64vector-unfold-right! f c64vec start end seed) -> c64vector</procedure>

The same as {{c64vector-unfold!}}, but initializes the {{c64vector}} from right to left.
==== Conversion
<procedure>(c64vector->list c64vec [start [end]]) -> proper-list</procedure>

<procedure>(reverse-c64vector->list c64vec [start [end]]) -> proper-list</procedure>

<procedure>(list->c64vector proper-list) -> c64vector</procedure>

<procedure>(reverse-list->c64vector proper-list) -> c64vector</procedure>

<procedure>(c64vector->vector c64vec [start [end]]) -> vector</procedure>

<procedure>(vector->c64vector vec [start [end]]) -> c64vector</procedure>

Returns a list, {{c64vector}}, or heterogeneous vector with the same elements as the argument, in reverse order where specified.
==== Generators
<procedure>(make-c64vector-generator c64vector)</procedure>

Returns a [[https://srfi.schemers.org/srfi-121/srfi-121.html][SRFI 121]] generator that generates all the values of {{c64vector}} in order. Note that the generator is finite.
==== Comparators
{{c64vector-comparator}}

Variable containing a [[https://srfi.schemers.org/srfi-128/srfi-128.html][SRFI 128]] comparator whose components provide ordering and hashing of {{c64vectors}}.
==== Output
<procedure>(write-c64vector c64vec [ port ] ) -> unspecified</procedure>

Prints to port (the current output port by default) a representation of {{c64vec}} in the lexical syntax explained below.
=== Module (srfi 160 c128)
==== Constructors
<procedure>(make-c128vector size [fill]) -> c128vector</procedure>

Returns a {{c128vector}} whose length is size. If fill is provided, all the elements of the {{c128vector}} are initialized to it.

<procedure>(c128vector value ...) -> c128vector</procedure>

Returns a {{c128vector}} initialized with values.

<procedure>(c128vector-unfold f length seed) -> c128vector</procedure>

Creates a vector whose length is length and iterates across each index {{k}} between 0 and {{length - 1}}, applying {{f}} at each iteration to the current index and current state, in that order, to receive two values: the element to put in the kth slot of the new vector and a new state for the next iteration. On the first call to {{f}}, the state's value is seed.

<procedure>(c128vector-unfold-right f length seed) -> c128vector</procedure>

The same as c128vector-unfold, but initializes the {{c128vector}} from right to left.

<procedure>(c128vector-copy c128vec [start [end]]) -> c128vector</procedure>

Makes a copy of the portion of {{c128vec}} from {{start}} to {{end}} and returns it.

<procedure>(c128vector-reverse-copy c128vec [start [end]]) -> c128vector</procedure>

The same as {{c128vector-copy}}, but in reverse order.

<procedure>(c128vector-append c128vec ...) -> c128vector</procedure>

Returns a {{c128vector}} containing all the elements of the {{c128vecs}} in order.

<procedure>(c128vector-concatenate list-of-c128vectors) -> c128vector</procedure>

The same as {{c128vector-append}}, but takes a list of {{c128vectors}} rather than multiple arguments.

<procedure>(c128vector-append-subvectors [c128vec start end] ...) -> c128vector</procedure>

Concatenates the result of applying {{c128vector-copy}} to each triplet of {{c128vec}}, {{start}}, {{end}} arguments, but may be implemented more efficiently.
==== Predicates
<procedure>(c128? obj) -> boolean</procedure>

Returns {{#t}} if obj is a valid element of an {{c128vector}}, and {{#f}} otherwise.

<procedure>(c128vector? obj) -> boolean</procedure>

Returns {{#t}} if obj is a {{c128vector}}, and {{#f}} otherwise.

<procedure>(c128vector-empty? c128vec) -> boolean</procedure>

Returns {{#t}} if {{c128vec}} has a length of zero, and {{#f}} otherwise.

<procedure>(c128vector= c128vec ...) -> boolean</procedure>

Compares the {{c128vecs}} for elementwise equality, using = to do the comparisons. Returns {{#f}} unless all {{c128vectors}} are the same length.
==== Selectors
<procedure>(c128vector-ref c128vec i) -> value</procedure>

Returns the ith element of {{c128vec}}.

<procedure>(c128vector-length c128vec) -> exact nonnegative integer</procedure>

Returns the length of {{c128vec}}
==== Iteration
<procedure>(c128vector-take c128vec n) -> c128vector] [SRFI 152]</procedure>

<procedure>(c128vector-take-right c128vec n) -> c128vector [SRFI 152]</procedure>

Returns a {{c128vector}} containing the first/last {{n}} elements of {{c128vec}}.

<procedure>(c128vector-drop c128vec n) -> c128vector [SRFI 152]</procedure>

<procedure>(c128vector-drop-right c128vec n) -> c128vector [SRFI 152]</procedure>

Returns a {{c128vector}} containing all except the first/last {{n}} elements of {{c128vec}}.

<procedure>(c128vector-segment c128vec n) -> list [SRFI 152]</procedure>

Returns a list of {{c128vectors}}, each of which contains n consecutive elements of {{c128vec}}. The last {{c128vector}} may be shorter than {{n}}.

<procedure>(c128vector-fold kons knil c128vec c128vec2 ...) -> object</procedure>

<procedure>(c128vector-fold-right kons knil c128vec c128vec2 ...) -> object</procedure>

When one {{c128vector}} argument {{c128vec}} is given, folds {{kons}} over the elements of {{c128vec}} in increasing/decreasing order using {{knil}} as the initial value. The {{kons}} procedure is called with the state first and the element second, as in SRFIs 43 and 133 (heterogeneous vectors). This is the opposite order to that used in SRFI 1 (lists) and the various string SRFIs.

When multiple {{c128vector}} arguments are given, {{kons}} is called with the current state value and each value from all the vectors; {{c128vector-fold}} scans elements from left to right, while {{c128vector-fold-right}} does from right to left. If the lengths of vectors differ, only the portion of each vector up to the length of the shortest vector is scanned.

<procedure>(c128vector-map f c128vec c128vec2 ...) -> c128vector</procedure>

<procedure>(c128vector-map! f c128vec c128vec2 ...) -> unspecified</procedure>

<procedure>(c128vector-for-each f c128vec c128vec2 ...) -> unspecified</procedure>

Iterate over the elements of {{c128vec}} and apply {{f}} to each, returning respectively a {{c128vector}} of the results, an undefined value with the results placed back in {{c128vec}}, and an undefined value with no change to {{c128vec}}.

If more than one vector is passed, {{f}} gets one element from each vector as arguments. If the lengths of the vectors differ, iteration stops at the end of the shortest vector. For {{c128vector-map!}}, only {{c128vec}} is modified even when multiple vectors are passed.

If {{c128vector-map}} or {{c128vector-map!}} returns more than once (i.e. because of a continuation captured by {{f}}), the values returned or stored by earlier returns may be mutated.

<procedure>(c128vector-count pred? c128vec c128vec2 ...) -> exact nonnegative integer</procedure>

Call {{pred?}} on each element of {{c128vec}} and return the number of calls that return true.

When multiple vectors are given, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are given for each iteration, which stops at the end of the shortest vector.

<procedure>(c128vector-cumulate f knil c128vec) -> c128vector</procedure>

Like {{c128vector-fold}}, but returns an {{c128vector}} of partial results rather than just the final result.
==== Searching
<procedure>(c128vector-take-while pred? c128vec) -> c128vector [SRFI 152]</procedure>

<procedure>(c128vector-take-while-right pred? c128vec) -> c128vector [SRFI 152]</procedure>

Return the shortest prefix/suffix of {{c128vec}} all of whose elements satisfy {{pred?}}.

<procedure>(c128vector-drop-while pred? c128vec) -> c128vector [SRFI 152]</procedure>

<procedure>(c128vector-drop-while-right pred? c128vec) -> c128vector [SRFI 152]</procedure>

Drops the longest initial prefix/suffix of {{c128vec}} such that all its elements satisfy pred.

<procedure>(c128vector-index pred? c128vec c128vec2 ...) -> exact nonnegative integer or #f</procedure>

<procedure>(c128vector-index-right pred? c128vec c128vec2 ...) -> exact nonnegative integer or #f</procedure>

Return the index of the first/last element of {{c128vec}} that satisfies {{pred?}}.

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are passed for each iteration. If the lengths of vectors differ, {{c128vector-index}} stops iteration at the end of the shortest one. Lengths of vectors must be the same for {{c128vector-index-right}}.

<procedure>(c128vector-skip pred? c128vec c128vec2 ...) -> exact nonnegative integer or #f</procedure>

<procedure>(c128vector-skip-right pred? c128vec c128vec2 ...) -> exact nonnegative integer or #f</procedure>

Returns the index of the first/last element of {{c128vec}} that does not satisfy {{pred?}}.

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are passed for each iteration. If the lengths of vectors differ, {{c128vector-skip}} stops iteration at the end of the shortest one. Lengths of vectors must be the same for {{c128vector-skip-right}}.

<procedure>(c128vector-any pred? c128vec c128vec2 ...) -> value or boolean</procedure>

Returns first non-false result of applying {{pred?}} on a element from the {{c128vec}}, or {{#f}} if there is no such element. If {{c128vec}} is empty, returns #t

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are passed for each iteration. If the lengths of vectors differ, it stops at the end of the shortest one.

<procedure>(c128vector-every pred? c128vec c128vec2 ...) -> value or boolean</procedure>

If all elements from {{c128vec}} satisfy {{pred?}}, return the last result of {{pred?}}. If not all do, return {{#f}}. If {{c128vec}} is empty, return #t

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector is passed for each iteration. If the lengths of vectors differ, it stops at the end of the shortest one.

<procedure>(c128vector-partition pred? c128vec) -> c128vector and integer</procedure>

Returns an {{c128vector}} of the same type as {{c128vec}}, but with all elements satisfying {{pred?}} in the leftmost part of the vector and the other elements in the remaining part. The order of elements is otherwise preserved. Returns two values, the new {{c128vector}} and the number of elements satisfying {{pred?}}.

<procedure>(c128vector-filter pred? c128vec) -> c128vector [SRFI 152]</procedure>

<procedure>(c128vector-remove pred? c128vec) -> c128vector [SRFI 152]</procedure>

Return an {{c128vector}} containing the elements of {{c128vec}} that satisfy / do not satisfy {{pred?}}.
==== Mutators
<procedure>(c128vector-set! c128vec i value) -> unspecified</procedure>

Sets the ith element of {{c128vec}} to value.

<procedure>(c128vector-swap! c128vec i j) -> unspecified</procedure>

Interchanges the ith and jth elements of {{c128vec}}.

<procedure>(c128vector-fill! c128vec fill [start [end]]) -> unspecified</procedure>

Fills the portion of {{c128vec}} from {{start}} to {{end}} with the value fill.

<procedure>(c128vector-reverse! c128vec [start [end]]) -> unspecified</procedure>

Reverses the portion of {{c128vec}} from {{start}} to {{end}}.

<procedure>(c128vector-copy! c128to at c128from [start [end]]) -> unspecified</procedure>

Copies the portion of {{c128from}} from {{start}} to {{end}} onto {{c128to}}, starting at index at.

<procedure>(c128vector-reverse-copy! c128to at c128from [start [end]]) -> unspecified</procedure>

The same as {{c128vector-copy!}}, but copies in reverse.

<procedure>(c128vector-unfold! f c128vec start end seed) -> c128vector</procedure>

Like vector-unfold, but the elements are copied into the vector {{c128vec}} starting at element {{start}} rather than into a newly allocated vector. Terminates when {{end}} - {{start}} elements have been generated.

<procedure>(c128vector-unfold-right! f c128vec start end seed) -> c128vector</procedure>

The same as {{c128vector-unfold!}}, but initializes the {{c128vector}} from right to left.
==== Conversion
<procedure>(c128vector->list c128vec [start [end]]) -> proper-list</procedure>

<procedure>(reverse-c128vector->list c128vec [start [end]]) -> proper-list</procedure>

<procedure>(list->c128vector proper-list) -> c128vector</procedure>

<procedure>(reverse-list->c128vector proper-list) -> c128vector</procedure>

<procedure>(c128vector->vector c128vec [start [end]]) -> vector</procedure>

<procedure>(vector->c128vector vec [start [end]]) -> c128vector</procedure>

Returns a list, {{c128vector}}, or heterogeneous vector with the same elements as the argument, in reverse order where specified.
==== Generators
<procedure>(make-c128vector-generator c128vector)</procedure>

Returns a [[https://srfi.schemers.org/srfi-121/srfi-121.html][SRFI 121]] generator that generates all the values of {{c128vector}} in order. Note that the generator is finite.
==== Comparators
{{c128vector-comparator}}

Variable containing a [[https://srfi.schemers.org/srfi-128/srfi-128.html][SRFI 128]] comparator whose components provide ordering and hashing of {{c128vectors}}.
==== Output
<procedure>(write-c128vector c128vec [ port ] ) -> unspecified</procedure>

Prints to port (the current output port by default) a representation of {{c128vec}} in the lexical syntax explained below.
=== Optional lexical syntax

Each homogeneous vector datatype has an external representation which may be supported by the read and write procedures and by the program parser. Conformance to this SRFI does not in itself require support for these external representations.

For each value of {{@}} in { {{s8, u8, s16, u16, s32, u32, s64, u64, f32, f64, c64, c128}} }, if the datatype {{@vector}} is supported, then the external representation of instances of the datatype {{@vector}} is #@( ...elements... ).

For example, {{#u8(0 #e1e2 #xff)}} is a {{u8vector}} of length 3 containing 0, 100 and 255; {{#f64(-1.5)}} is an {{f64vector}} of length 1 containing -1.5.

Note that the syntax for float vectors conflicts with R5RS, which parses {{#f32()}} as 3 objects: {{#f}}, {{32}} and {{()}}. For this reason, conformance to this SRFI implies this minor nonconformance to R5RS.

This external representation is also available in program source code. For example, {{(set! x '#u8(1 2 3))}} will set x to the object {{#u8(1 2 3)}}. Literal homogeneous vectors, like heterogeneous vectors, are self-evaluating; they do not need to be quoted. Homogeneous vectors can appear in quasiquotations but must not contain unquote or unquote-splicing forms (i.e. {{`(,x #u8(1 2))}} is legal but {{`#u8(1 ,x 2)}} is not). This restriction is to accommodate the many Scheme systems that use the read procedure to parse programs.
=== Implementation
This implementation was developed on Chicken 5 and Chibi, and directly supports those two systems. There is support for Gauche as well. It should be easy to adapt to other implementations.

After downloading the source, it is necessary to run the atexpander.sh shell script in order to generate the individual files for the different types. This will take a skeleton file like at.sld and create the files u8.sld, s8.sld, ... c128.sld. The unexpander.sh script safely undoes the effects of atexpander.sh. The heavy lifting is done by sed.

Making this SRFI available on R6RS systems is straightforward, requiring only a replacement library file that includes the implementation files in the srfi/160/base directory and the srfi/160 directories. The file include.scm contains an R6RS (include) library that will be useful for systems that don't provide it.
=== The SRFI 160 base library
The library (srfi 160 base) is in the repository of this SRFI. It supports the eight procedures of SRFI 4, namely make-@vector, {{@vector}}, {{@vector?}}, {{@vector-length}}, {{@vector-ref}}, {{@vector-set!}}, {{@vector->list}}, and {{list->@vector}}, not only for the ten homogeneous vector types supported by SRFI 4, but also for the two homogeneous vector types beyond the scope of SRFI 4, namely {{c64vectors}} and {{c128vectors}}. In addition, the {{@?}} procedure, which is not in SRFI 4, is available for all types.

The implementation depends on SRFI 4. For systems that do not have a native SRFI 4 implementation, the version in the contrib/cowan directory of the SRFI 4 repository may be used; it depends only on a minimal implementation of {{bytevectors}}.

The tests are for the c64 and c128 procedures and the @? procedures only. The assumption is that tests for the underlying SRFI 4 procedures suffice for everything else.
=== The following files are provided:
* srfi.160.base.scm - Chicken 5 (srfi 160 base) library.
* srfi/160/base.sld - R7RS (srfi 160 base) library.
* srfi/160/base/complex.scm - Complex number implementation on top of SRFI 4.
* srfi/160/base/valid.scm - Validity (@?) predicates.
* srfi/160/base/at-vector2list.scm - Reimplementation of SRFI 4's @vector->list procedures that accept {{start}} and {{end}} optional arguments.
* srfi/160/base/r7rec.scm - Record-type definitions for R7RS or SRFI 9.
* srfi/160/base/r6rec.scm - Record-type definitions for R6RS.
* shared-base-tests.scm - Shared tests (no dependencies).
* chibi-base-tests.scm - Chibi test script wrapper.
* chicken-base-tests.scm - Chicken 5 test script wrapper.
=== The SRFI 160 libraries
The following files are provided:

* srfi/160/at.sld - Skeleton for Chibi libraries. Can be adapted to any R7RS system.
* srfi.160.at.scm - Skeleton for Chicken 5 libraries. Can be adapted to any R5RS system with simple byte vectors.
* srfi/160/at-impl.scm - Skeleton for shared implementation of SRFI 160 procedures.
* shared-tests.scm - Tests of the s16 library only (depends on Chicken or Chibi test library). The assumption is that if s16 works, everything works.
* chibi-tests.scm - Chibi test script wrapper.
* chicken-tests.scm - Chicken 5 test script wrapper.
* gauche-tests.scm - Gauche test script with embedded testing library.
=== Acknowledgements
Thanks to all participants in the SRFI 160 mailing list over the unconscionably long time it took me to get this proposal to finalization. Special thanks to Shiro Kawai
for bringing up many issues and contributing the code that extended many procedures from one {{@vector}} to many.
=== Authors
* John Cowan (based on SRFI 4 by Marc Feeley)
* Shiro Kawai (contributed a major patch).
* Ported to Chicken Scheme 5 by Sergey Goldgaber
=== Copyright
Copyright © John Cowan 2018.

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice (including the next paragraph) shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
=== Version history
* [[https://github.com/diamond-lizard/srfi-160/releases/tag/0.4|0.4]] - Fix for [[https://github.com/diamond-lizard/srfi-160/issues/6|issue 6]]
* [[https://github.com/diamond-lizard/srfi-160/releases/tag/0.3|0.3]] - Fix for [[https://github.com/diamond-lizard/srfi-160/issues/5|issue 5]]
* [[https://github.com/diamond-lizard/srfi-160/releases/tag/0.2|0.2]] - Fix for [[https://github.com/diamond-lizard/srfi-160/issues/1|issue 1]]
* [[https://github.com/diamond-lizard/srfi-160/releases/tag/0.1|0.1]] - Ported to Chicken Scheme 5
