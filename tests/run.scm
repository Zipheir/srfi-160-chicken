(import scheme)
(import (chicken base))
(import (srfi 160 base))
(import test)
(import srfi-128)
(import srfi-133)

(current-test-verbosity #f)

(test-begin "srfi-160")

(test-group "(srfi 160 base)"
;;;; Shared tests
;;; Hvector = homogeneous vector

  ;; Test for sameness

  (define relerr (expt 2 -24))
  (define (inexact-real? x) (and (number? x) (inexact? x) (real? x)))
  (define (inexact-complex? x) (and (number? x) (inexact? x) (not (real? x))))
  (define (realify z) (* (real-part z) (imag-part z)))

  (define (same? result expected)
    (cond
     ((and (inexact-real? result) (inexact-real? expected))
      (let ((abserr (abs (* expected relerr))))
        (<= (- expected abserr) result (+ expected abserr))))
     ((and (inexact-complex? result) (inexact-complex? expected))
      (let ((abserr (abs (* (realify expected) relerr))))
        (<= (- (realify expected) abserr) (realify result) (+ (realify expected) abserr))))
     ((and (number? result) (number? expected))
      (= result expected))
     ((and (pair? result) (pair? expected))
      (list-same? result expected))
     (else
      (equal? result expected))))

  (define (list-same? result expected)
    (cond
     ((and (null? result) (null? expected))
      #t)
     ((and (pair? result) (pair? expected))
      (and (same? (car result) (car expected)) (list-same? (cdr result) (cdr expected))))
     (else
      #f)))

  (define-syntax is-same?
    (syntax-rules ()
      ((is-same? result expected)
       (test-assert (same? result expected)))))

  (define (create label value)
    value)

  (define (test tag make-Hvector Hvector Hvector? Hvector-length
                Hvector-ref Hvector-set! Hvector->list list->Hvector)
    (test-group (string-append (symbol->string tag) "vector")
      (let* ((first 32.0)
             (second 32.0+47.0i)
             (third -47.0i)
             (vec0 (make-Hvector 3))
             (vec1 (make-Hvector 3 second))
             (vec2 (Hvector first second third))
             (vec3 (list->Hvector (list third second first))))
        (is-same? (Hvector? vec0) #t)
        (is-same? (Hvector? vec1) #t)
        (is-same? (Hvector? vec2) #t)
        (is-same? (Hvector? vec3) #t)
        (is-same? (Hvector-length vec0) 3)
        (is-same? (Hvector-length vec1) 3)
        (is-same? (Hvector-length vec2) 3)
        (is-same? (Hvector-length vec3) 3)
        (Hvector-set! vec0 0 second)
        (Hvector-set! vec0 1 third)
        (Hvector-set! vec0 2 first)
        (is-same? (Hvector-ref vec0 0) second)
        (is-same? (Hvector-ref vec0 1) third)
        (is-same? (Hvector-ref vec0 2) first)
        (is-same? (Hvector-ref vec1 0) second)
        (is-same? (Hvector-ref vec1 1) second)
        (is-same? (Hvector-ref vec1 2) second)
        (is-same? (Hvector-ref vec2 0) first)
        (is-same? (Hvector-ref vec2 1) second)
        (is-same? (Hvector-ref vec2 2) third)
        (is-same? (Hvector-ref vec3 0) third)
        (is-same? (Hvector-ref vec3 1) second)
        (is-same? (Hvector-ref vec3 2) first)
        (is-same? (Hvector->list vec0) (list second third first))
        (is-same? (Hvector->list vec1) (list second second second))
        (is-same? (Hvector->list vec2) (list first second third))
        (is-same? (Hvector->list vec3) (list third second first)))))

  (test 'c64 make-c64vector c64vector c64vector? c64vector-length
        c64vector-ref c64vector-set! c64vector->list list->c64vector)

  (test 'c128 make-c128vector c128vector c128vector? c128vector-length
        c128vector-ref c128vector-set! c128vector->list list->c128vector)

  ;; (define-syntax test-assert
  ;;   (syntax-rules ()
  ;;     ((test-assert expr)
  ;;      (begin
  ;;        (display "Try ")
  ;;        (display 'expr)
  ;;        (display " is ")
  ;;        (display (if expr "true OK" "false FAIL"))
  ;;        (newline)))))

  (define-syntax test-not
    (syntax-rules ()
      ((test-not expr)
       (test-assert (not expr))
       ;; (begin
       ;;   (display "Try ")
       ;;   (display 'expr)
       ;;   (display " is ")
       ;;   (display (if expr "true FAIL" "false OK"))
       ;;   (newline))
       )))

  (define-syntax integral-tests
    (syntax-rules ()
      ((integral-tests pred lo hi)
       (begin
         (test-not (pred 1/2))
         (test-not (pred 1.0))
         (test-not (pred 1+2i))
         (test-not (pred 1.0+2.0i))
         (test-assert (pred 0))
         (test-assert (pred hi))
         (test-assert (pred lo))
         (test-not (pred (+ hi 1)))
         (test-not (pred (- lo 1)))))))

  (test-group "@?"
    (integral-tests u8? 0 255)
    (integral-tests s8? -128 127)
    (integral-tests u16? 0 65535)
    (integral-tests s16? -32768 32767)
    (integral-tests u32? 0 4294967295)
    (integral-tests s32? -2147483648 2147483647)
    (integral-tests u64? 0 18446744073709551615)
    (integral-tests s64? -9223372036854775808 9223372036854775807)

    (test-assert (f32? 1.0))
    (test-not (f32? 1))
    (test-not (f32? 1.0+2.0i))

    (test-assert (f64? 1.0))
    (test-not (f64? 1))
    (test-not (f64? 1.0+2.0i))

    (test-assert (c64? 1.0))
    (test-not (c64? 1))
    (test-assert (c64? 1.0+2.0i))

    (test-assert (c128? 1.0))
    (test-not (c128? 1))
    (test-assert (c128? 1.0+2.0i))))
(import (srfi 160 u8))

(test-group "u8vector tests"
  (define (times2 x) (* x 2))
  (define s5 (u8vector 1 2 3 4 5))
  (define s4 (u8vector 1 2 3 4))
  (define s5+ (u8vector 1 2 3 4 6))

  (define (steady i x) (values x x))
  (define (count-up i x) (values x (+ x 1)))
  (define (count-down i x) (values x (- x 1)))
  (define (odd+1 x) (if (odd? x) (+ 1 x) #f))
  (define u8vector< (comparator-ordering-predicate u8vector-comparator))
  (define u8vector-hash (comparator-hash-function u8vector-comparator))

  (define g (make-u8vector-generator s5))
  (define-syntax test-equiv
    (syntax-rules ()
      ((test-equiv expect expr)
       (test expect (map inexact->exact (u8vector->list expr))))
      ((test-equiv name expect expr)
       (test name expect (map inexact->exact (u8vector->list expr))))))

  (test-group "u8vector"
    (test-group "u8vector/constructors"
      (test-equiv "make" '(3 3 3 3 3) (make-u8vector 5 3))
      (test-equiv "u8vector" '(2 1 0 1 2) (u8vector 2 1 0 1 2))
      (test-equiv "unfold up" '(10 11 12 13 14)
                  (u8vector-unfold count-up 5 10))
      (test-equiv "unfold down" '(10 9 8 7 6)
                  (u8vector-unfold count-down 5 10))
      (test-equiv "unfold steady" '(10 10 10 10 10)
                  (u8vector-unfold steady 5 10))
      (test-equiv "unfold-right up" '(14 13 12 11 10)
                  (u8vector-unfold-right count-up 5 10))
      (test-equiv "unfold-right down" '(6 7 8 9 10)
                  (u8vector-unfold-right count-down 5 10))
      (test-equiv "unfold-right steady" '(10 10 10 10 10)
                  (u8vector-unfold-right steady 5 10))
      (test-equiv "copy" '(1 2 3 4 5) (u8vector-copy s5))
      (test-assert "copy2" (not (eqv? s5 (u8vector-copy s5))))
      (test-equiv "copy3" '(2 3) (u8vector-copy s5 1 3))
      (test-equiv "reverse-copy" '(5 4 3 2 1) (u8vector-reverse-copy s5))
      (test-equiv "append" '(1 2 3 4 5 1 2 3 4 5)
                  (u8vector-append s5 s5))
      (test-equiv "concatenate" '(1 2 3 4 5 1 2 3 4 5)
                  (u8vector-concatenate (list s5 s5)))
      (test-equiv "append-subvectors" '(2 3 2 3)
                  (u8vector-append-subvectors s5 1 3 s5 1 3))
      ) ; end u8vector/constructors

    ;; (test-group "u8vector/predicates"
    ;;   (test-assert "u8?" (u8? 5))
    ;;   (test-assert "not u8?" (not (u8? 65536)))
    ;;   (test-assert "u8vector?" (u8vector? s5))
    ;;   (test-assert "not u8vector?" (not (u8vector? #t)))
    ;;   (test-assert "empty" (u8vector-empty? (u8vector)))
    ;;   (test-assert "not empty" (not (u8vector-empty? s5)))
    ;;   (test-assert "=" (u8vector= (u8vector 1 2 3) (u8vector 1 2 3)))
    ;;   (test-assert "= multi" (u8vector= (u8vector 1 2 3)
    ;;                                    (u8vector 1 2 3)
    ;;                                    (u8vector 1 2 3)))
    ;;   (test-assert "not =" (not (u8vector= (u8vector 1 2 3) (u8vector 3 2 1))))
    ;;   (test-assert "not =2" (not (u8vector= (u8vector 1 2 3) (u8vector 1 2))))
    ;;   (test-assert "not = multi" (not (u8vector= (u8vector 1 2 3)
    ;;                                             (u8vector 1 2 3)
    ;;                                             (u8vector 3 2 1))))
    ;;   )
                                        ; end u8vector/predicates

    (test-group "u8vector/selectors"
      (test "ref" 1 (inexact->exact (u8vector-ref (u8vector 1 2 3) 0)))
      (test "length" 3 (u8vector-length (u8vector 1 2 3)))
      ) ; end u8vector/selectors

    (test-group "u8vector/iteration"
      (test-equiv "take" '(1 2) (u8vector-take s5 2))
      (test-equiv "take-right" '(4 5) (u8vector-take-right s5 2))
      (test-equiv "drop" '(3 4 5) (u8vector-drop s5 2))
      (test-equiv "drop-right" '(1 2 3) (u8vector-drop-right s5 2))
      (test "segment" (list (u8vector 1 2 3) (u8vector 4 5))
            (u8vector-segment s5 3))
      (test "fold" -6 (inexact->exact (u8vector-fold - 0 (u8vector 1 2 3))))
      ;; (test "fold" '(((0 1 4) 2 5) 3 6)
      ;;       (u8vector-fold list 0 (u8vector 1 2 3) (u8vector 4 5 6)))
      (test "fold-right" -6 (inexact->exact (u8vector-fold-right - 0 (u8vector 1 2 3))))
      ;; (test "fold-right" '(((0 3 6) 2 5) 1 4)
      ;;       (u8vector-fold-right list 0 (u8vector 1 2 3) (u8vector 4 5 6)))
      (test-equiv "map" '(1 4 9 16 25) (u8vector-map (cut expt <> 2) s5))
      (test-equiv "map" '(0 0 0 0 0) (u8vector-map - s5 s5))
      (let ((v (u8vector 1 2 3 4 5)))
        (u8vector-map! (cut expt <> 2) v)
        (test-equiv "map!" '(1 4 9 16 25) v))
      (let ((v (u8vector 1 2 3 4 5))
            (v2 (u8vector 6 7 8 9 10)))
        (u8vector-map! + v v2)
        (test-equiv "map!" '(7 9 11 13 15) v))
      (let ((list '()))
        (u8vector-for-each
         (lambda (e) (set! list (cons e list)))
         s5)
        ;; stupid hack to shut up test egg about testing the value of a variable
        (test "for-each" '(5 4 3 2 1) (map inexact->exact (cons (car list) (cdr list)))))
      ;; (let ((list '()))
      ;;   (u8vector-for-each
      ;;    (lambda (e1 e2) (set! list (cons (cons e1 e2) list)))
      ;;    s5
      ;;    (u8vector 6 7 8 9 10))
      ;;   ;; stupid hack to shut up test egg about testing the value of a variable
      ;;   (test "for-each" '((5 . 10) (4 . 9) (3 . 8) (2 . 7) (1 . 6))
      ;;         (cons (car list) (cdr list))))
      (test "count" 3 (u8vector-count odd? s5))
      (test "count" 2 (u8vector-count > s5 (u8vector 9 2 1 5 3)))
      (test-equiv "cumulate" '(1 3 6 10 15)
                  (u8vector-cumulate + 0 s5))
      ) ; end u8vector/iteration

    (test-group "u8vector/searching"
      (test-equiv "take-while" '(1) (u8vector-take-while odd? s5))
      (test-equiv "take-while-right" '(5) (u8vector-take-while-right odd? s5))
      (test-equiv "drop-while" '(2 3 4 5) (u8vector-drop-while odd? s5))
      (test-equiv "drop-while-right" '(1 2 3 4) (u8vector-drop-while-right odd? s5))
      ;; (test-equiv "degenerate take-while" '() (u8vector-take-while inexact? s5))
      ;; (test-equiv "degenerate take-while-right" '() (u8vector-take-while-right inexact? s5))
      ;; (test-equiv "degenerate drop-while" '(1 2 3 4 5) (u8vector-drop-while inexact? s5))
      ;; (test-equiv "degenerate drop-while-right" '(1 2 3 4 5) (u8vector-drop-while-right inexact? s5))
      (test "index" 1 (u8vector-index even? s5))
      (test "index" 2 (u8vector-index < s5 (u8vector 0 0 10 10 0)))
      (test "index-right" 3 (u8vector-index-right even? s5))
      (test "index-right" 3 (u8vector-index-right < s5 (u8vector 0 0 10 10 0)))
      (test "skip" 1 (u8vector-skip odd? s5))
      (test "skip" 2 (u8vector-skip > s5 (u8vector 0 0 10 10 0)))
      (test "skip-right" 3 (u8vector-skip-right odd? s5))
      (test "skip-right" 3 (u8vector-skip-right > s5 (u8vector 0 0 10 10 0)))
      (test "any" 4 (inexact->exact (u8vector-any (lambda (x) (and (even? x) (* x 2))) s5)))
      (test-assert "not any" (not (u8vector-any list? s5)))
      (test "any + 1" 2 (inexact->exact (u8vector-any odd+1 s5)))
      (test-assert "every" (u8vector-every number? s5))
      (test-assert "not every" (not (u8vector-every odd? s5)))
      (test-assert "every + 1" (not (u8vector-every odd+1 s5)))
      (test "multi-any" 10 (inexact->exact (u8vector-any (lambda (x y) (and (even? x) (even? y) (+ x y)))
                                                        s5 (u8vector 0 1 2 6 4))))
      (test "multi-any 2" #f (u8vector-any (lambda (x y) (and (even? x) (even? y) (+ x y)))
                                          s5 (u8vector 0 1 2 5 4)))
      (test "multi-every" 10 (inexact->exact (u8vector-every (lambda (x) (and (number? x) (* x 2))) s5)))
      (test "multi-every-2" 10 (inexact->exact (u8vector-every (lambda (x y) (and (number? x) (number? y) (+ x y)))
                                                              s5 s5)))
      (test-assert "multi-not every" (not (u8vector-every < s5 (u8vector 10 10 10 10 0))))
      (test-equiv "partition" '(1 3 5 2 4) (u8vector-partition odd? s5))
      (test-equiv "filter" '(1 3 5) (u8vector-filter odd? s5))
      (test-equiv "remove" '(2 4) (u8vector-remove odd? s5))
      ) ; end u8vector/searching

    (test-group "u8vector/mutators"
      (let ((v (u8vector 1 2 3)))
        ;; (display "set!\n")
        (u8vector-set! v 0 10)
        (test-equiv "set!" '(10 2 3) v))
      (let ((v (u8vector 1 2 3)))
        ;; (display "swap!\n")
        (u8vector-swap! v 0 1)
        (test-equiv "swap!" '(2 1 3) v))
      (let ((v (u8vector 1 2 3)))
        ;; (display "fill!\n")
        (u8vector-fill! v 2)
        (test-equiv "fill!" '(2 2 2) v))
      (let ((v (u8vector 1 2 3)))
        ;; (display "fill2!\n")
        (u8vector-fill! v 10 0 2)
        (test-equiv "fill2!" '(10 10 3) v))
      (let ((v (u8vector 1 2 3)))
        ;; (display "reverse!\n")
        (u8vector-reverse! v)
        (test-equiv "reverse!" '(3 2 1) v))
      (let ((v (u8vector 1 2 3)))
        ;; (display "reverse!\n")
        (u8vector-reverse! v 1 3)
        (test-equiv "reverse2!" '(1 3 2) v))
      (let ((v (u8vector 10 20 30 40 50)))
        ;; (display "copy!\n")
        (u8vector-copy! v 1 s5 2 4)
        (test-equiv "copy!" '(10 3 4 40 50) v))
      (let ((v (u8vector 10 20 30 40 50)))
        ;; (display "reverse-copy!\n")
        (u8vector-reverse-copy! v 1 s5 2 4)
        (test-equiv "reverse-copy!" '(10 4 3 40 50) v))
      (let ((v (u8vector 1 2 3 4 5 6 7 8)))
        ;; (display "unfold!")
        (u8vector-unfold! (lambda (x) (values (* x 2) (* x 2)))
                         v 1 6 1)
        (test-equiv "vector-unfold!" '(1 2 4 8 16 32 7 8) v))
      (let ((v (u8vector 1 2 3 4 5 6 7 8)))
        ;; (display "unfold-right!")
        (u8vector-unfold-right! (lambda (x) (values (* x 2) (* x 2)))
                               v 1 6 1)
        (test-equiv "vector-unfold!" '(1 32 16 8 4 2 7 8) v))
      ) ; end u8vector/mutators

    (test-group "u8vector/conversion"
      (test "u8vector->list 1" '(1 2 3 4 5)
            (map inexact->exact (u8vector->list s5)))
      (test "u8vector->list 2" '(2 3 4 5)
            (map inexact->exact (u8vector->list s5 1)))
      (test "u8vector->list 3" '(2 3 4)
            (map inexact->exact (u8vector->list s5 1 4)))
      (test "u8vector->vector 1" #(1 2 3 4 5)
            (vector-map inexact->exact (u8vector->vector s5)))
      (test "u8vector->vector 2" #(2 3 4 5)
            (vector-map inexact->exact (u8vector->vector s5 1)))
      (test "u8vector->vector 3" #(2 3 4)
            (vector-map inexact->exact (u8vector->vector s5 1 4)))
      (test-equiv "list->u8vector" '(1 2 3 4 5)
                  (list->u8vector '(1 2 3 4 5)))
      (test-equiv "reverse-list->u8vector" '(5 4 3 2 1)
                  (reverse-list->u8vector '(1 2 3 4 5)))
      (test-equiv "vector->u8vector 1" '(1 2 3 4 5)
                  (vector->u8vector #(1 2 3 4 5)))
      (test-equiv "vector->u8vector 2" '(2 3 4 5)
                  (vector->u8vector #(1 2 3 4 5) 1))
      (test-equiv "vector->u8vector 3" '(2 3 4)
                  (vector->u8vector #(1 2 3 4 5) 1 4))
      ) ; end u8vector/conversion

    (test-group "u8vector/misc"
      ;; (let ((port (open-output-string)))
      ;;   (write-u8vector s5 port)
      ;;   (test "write-u8vector" "#u8(1 2 3 4 5)" (get-output-string port))
      ;;   (close-output-port port))

      (test-assert "u8vector< short" (u8vector< s4 s5))
      (test-assert "not u8vector< short" (not (u8vector< s5 s4)))
      (test-assert "u8vector< samelen" (u8vector< s5 s5+))
      (test-assert "not u8vector< samelen" (not (u8vector< s5+ s5+)))
      (test-assert "u8vector=" (u8vector= s5+ s5+))
      (test "u8vector-hash" 15 (u8vector-hash s5))

      (test "u8vector-gen 0" 1 (inexact->exact (g)))
      (test "u8vector-gen 1" 2 (inexact->exact (g)))
      (test "u8vector-gen 2" 3 (inexact->exact (g)))
      (test "u8vector-gen 3" 4 (inexact->exact (g)))
      (test "u8vector-gen 4" 5 (inexact->exact (g)))
      (test-assert (eof-object? (g)))
      ) ; end u8vector/misc

    ) ; end u8vector

  )
(import (srfi 160 s8))

(test-group "s8vector tests"
  (define (times2 x) (* x 2))
  (define s5 (s8vector 1 2 3 4 5))
  (define s4 (s8vector 1 2 3 4))
  (define s5+ (s8vector 1 2 3 4 6))

  (define (steady i x) (values x x))
  (define (count-up i x) (values x (+ x 1)))
  (define (count-down i x) (values x (- x 1)))
  (define (odd+1 x) (if (odd? x) (+ 1 x) #f))
  (define s8vector< (comparator-ordering-predicate s8vector-comparator))
  (define s8vector-hash (comparator-hash-function s8vector-comparator))

  (define g (make-s8vector-generator s5))
  (define-syntax test-equiv
    (syntax-rules ()
      ((test-equiv expect expr)
       (test expect (map inexact->exact (s8vector->list expr))))
      ((test-equiv name expect expr)
       (test name expect (map inexact->exact (s8vector->list expr))))))

  (test-group "s8vector"
    (test-group "s8vector/constructors"
      (test-equiv "make" '(3 3 3 3 3) (make-s8vector 5 3))
      (test-equiv "s8vector" '(2 1 0 1 2) (s8vector 2 1 0 1 2))
      (test-equiv "unfold up" '(10 11 12 13 14)
                  (s8vector-unfold count-up 5 10))
      (test-equiv "unfold down" '(10 9 8 7 6)
                  (s8vector-unfold count-down 5 10))
      (test-equiv "unfold steady" '(10 10 10 10 10)
                  (s8vector-unfold steady 5 10))
      (test-equiv "unfold-right up" '(14 13 12 11 10)
                  (s8vector-unfold-right count-up 5 10))
      (test-equiv "unfold-right down" '(6 7 8 9 10)
                  (s8vector-unfold-right count-down 5 10))
      (test-equiv "unfold-right steady" '(10 10 10 10 10)
                  (s8vector-unfold-right steady 5 10))
      (test-equiv "copy" '(1 2 3 4 5) (s8vector-copy s5))
      (test-assert "copy2" (not (eqv? s5 (s8vector-copy s5))))
      (test-equiv "copy3" '(2 3) (s8vector-copy s5 1 3))
      (test-equiv "reverse-copy" '(5 4 3 2 1) (s8vector-reverse-copy s5))
      (test-equiv "append" '(1 2 3 4 5 1 2 3 4 5)
                  (s8vector-append s5 s5))
      (test-equiv "concatenate" '(1 2 3 4 5 1 2 3 4 5)
                  (s8vector-concatenate (list s5 s5)))
      (test-equiv "append-subvectors" '(2 3 2 3)
                  (s8vector-append-subvectors s5 1 3 s5 1 3))
      ) ; end s8vector/constructors

    ;; (test-group "s8vector/predicates"
    ;;   (test-assert "s8?" (s8? 5))
    ;;   (test-assert "not s8?" (not (s8? 65536)))
    ;;   (test-assert "s8vector?" (s8vector? s5))
    ;;   (test-assert "not s8vector?" (not (s8vector? #t)))
    ;;   (test-assert "empty" (s8vector-empty? (s8vector)))
    ;;   (test-assert "not empty" (not (s8vector-empty? s5)))
    ;;   (test-assert "=" (s8vector= (s8vector 1 2 3) (s8vector 1 2 3)))
    ;;   (test-assert "= multi" (s8vector= (s8vector 1 2 3)
    ;;                                    (s8vector 1 2 3)
    ;;                                    (s8vector 1 2 3)))
    ;;   (test-assert "not =" (not (s8vector= (s8vector 1 2 3) (s8vector 3 2 1))))
    ;;   (test-assert "not =2" (not (s8vector= (s8vector 1 2 3) (s8vector 1 2))))
    ;;   (test-assert "not = multi" (not (s8vector= (s8vector 1 2 3)
    ;;                                             (s8vector 1 2 3)
    ;;                                             (s8vector 3 2 1))))
    ;;   )
                                        ; end s8vector/predicates

    (test-group "s8vector/selectors"
      (test "ref" 1 (inexact->exact (s8vector-ref (s8vector 1 2 3) 0)))
      (test "length" 3 (s8vector-length (s8vector 1 2 3)))
      ) ; end s8vector/selectors

    (test-group "s8vector/iteration"
      (test-equiv "take" '(1 2) (s8vector-take s5 2))
      (test-equiv "take-right" '(4 5) (s8vector-take-right s5 2))
      (test-equiv "drop" '(3 4 5) (s8vector-drop s5 2))
      (test-equiv "drop-right" '(1 2 3) (s8vector-drop-right s5 2))
      (test "segment" (list (s8vector 1 2 3) (s8vector 4 5))
            (s8vector-segment s5 3))
      (test "fold" -6 (inexact->exact (s8vector-fold - 0 (s8vector 1 2 3))))
      ;; (test "fold" '(((0 1 4) 2 5) 3 6)
      ;;       (s8vector-fold list 0 (s8vector 1 2 3) (s8vector 4 5 6)))
      (test "fold-right" -6 (inexact->exact (s8vector-fold-right - 0 (s8vector 1 2 3))))
      ;; (test "fold-right" '(((0 3 6) 2 5) 1 4)
      ;;       (s8vector-fold-right list 0 (s8vector 1 2 3) (s8vector 4 5 6)))
      (test-equiv "map" '(1 4 9 16 25) (s8vector-map (cut expt <> 2) s5))
      (test-equiv "map" '(0 0 0 0 0) (s8vector-map - s5 s5))
      (let ((v (s8vector 1 2 3 4 5)))
        (s8vector-map! (cut expt <> 2) v)
        (test-equiv "map!" '(1 4 9 16 25) v))
      (let ((v (s8vector 1 2 3 4 5))
            (v2 (s8vector 6 7 8 9 10)))
        (s8vector-map! + v v2)
        (test-equiv "map!" '(7 9 11 13 15) v))
      (let ((list '()))
        (s8vector-for-each
         (lambda (e) (set! list (cons e list)))
         s5)
        ;; stupid hack to shut up test egg about testing the value of a variable
        (test "for-each" '(5 4 3 2 1) (map inexact->exact (cons (car list) (cdr list)))))
      ;; (let ((list '()))
      ;;   (s8vector-for-each
      ;;    (lambda (e1 e2) (set! list (cons (cons e1 e2) list)))
      ;;    s5
      ;;    (s8vector 6 7 8 9 10))
      ;;   ;; stupid hack to shut up test egg about testing the value of a variable
      ;;   (test "for-each" '((5 . 10) (4 . 9) (3 . 8) (2 . 7) (1 . 6))
      ;;         (cons (car list) (cdr list))))
      (test "count" 3 (s8vector-count odd? s5))
      (test "count" 2 (s8vector-count > s5 (s8vector 9 2 1 5 3)))
      (test-equiv "cumulate" '(1 3 6 10 15)
                  (s8vector-cumulate + 0 s5))
      ) ; end s8vector/iteration

    (test-group "s8vector/searching"
      (test-equiv "take-while" '(1) (s8vector-take-while odd? s5))
      (test-equiv "take-while-right" '(5) (s8vector-take-while-right odd? s5))
      (test-equiv "drop-while" '(2 3 4 5) (s8vector-drop-while odd? s5))
      (test-equiv "drop-while-right" '(1 2 3 4) (s8vector-drop-while-right odd? s5))
      ;; (test-equiv "degenerate take-while" '() (s8vector-take-while inexact? s5))
      ;; (test-equiv "degenerate take-while-right" '() (s8vector-take-while-right inexact? s5))
      ;; (test-equiv "degenerate drop-while" '(1 2 3 4 5) (s8vector-drop-while inexact? s5))
      ;; (test-equiv "degenerate drop-while-right" '(1 2 3 4 5) (s8vector-drop-while-right inexact? s5))
      (test "index" 1 (s8vector-index even? s5))
      (test "index" 2 (s8vector-index < s5 (s8vector 0 0 10 10 0)))
      (test "index-right" 3 (s8vector-index-right even? s5))
      (test "index-right" 3 (s8vector-index-right < s5 (s8vector 0 0 10 10 0)))
      (test "skip" 1 (s8vector-skip odd? s5))
      (test "skip" 2 (s8vector-skip > s5 (s8vector 0 0 10 10 0)))
      (test "skip-right" 3 (s8vector-skip-right odd? s5))
      (test "skip-right" 3 (s8vector-skip-right > s5 (s8vector 0 0 10 10 0)))
      (test "any" 4 (inexact->exact (s8vector-any (lambda (x) (and (even? x) (* x 2))) s5)))
      (test-assert "not any" (not (s8vector-any list? s5)))
      (test "any + 1" 2 (inexact->exact (s8vector-any odd+1 s5)))
      (test-assert "every" (s8vector-every number? s5))
      (test-assert "not every" (not (s8vector-every odd? s5)))
      (test-assert "every + 1" (not (s8vector-every odd+1 s5)))
      (test "multi-any" 10 (inexact->exact (s8vector-any (lambda (x y) (and (even? x) (even? y) (+ x y)))
                                                        s5 (s8vector 0 1 2 6 4))))
      (test "multi-any 2" #f (s8vector-any (lambda (x y) (and (even? x) (even? y) (+ x y)))
                                          s5 (s8vector 0 1 2 5 4)))
      (test "multi-every" 10 (inexact->exact (s8vector-every (lambda (x) (and (number? x) (* x 2))) s5)))
      (test "multi-every-2" 10 (inexact->exact (s8vector-every (lambda (x y) (and (number? x) (number? y) (+ x y)))
                                                              s5 s5)))
      (test-assert "multi-not every" (not (s8vector-every < s5 (s8vector 10 10 10 10 0))))
      (test-equiv "partition" '(1 3 5 2 4) (s8vector-partition odd? s5))
      (test-equiv "filter" '(1 3 5) (s8vector-filter odd? s5))
      (test-equiv "remove" '(2 4) (s8vector-remove odd? s5))
      ) ; end s8vector/searching

    (test-group "s8vector/mutators"
      (let ((v (s8vector 1 2 3)))
        ;; (display "set!\n")
        (s8vector-set! v 0 10)
        (test-equiv "set!" '(10 2 3) v))
      (let ((v (s8vector 1 2 3)))
        ;; (display "swap!\n")
        (s8vector-swap! v 0 1)
        (test-equiv "swap!" '(2 1 3) v))
      (let ((v (s8vector 1 2 3)))
        ;; (display "fill!\n")
        (s8vector-fill! v 2)
        (test-equiv "fill!" '(2 2 2) v))
      (let ((v (s8vector 1 2 3)))
        ;; (display "fill2!\n")
        (s8vector-fill! v 10 0 2)
        (test-equiv "fill2!" '(10 10 3) v))
      (let ((v (s8vector 1 2 3)))
        ;; (display "reverse!\n")
        (s8vector-reverse! v)
        (test-equiv "reverse!" '(3 2 1) v))
      (let ((v (s8vector 1 2 3)))
        ;; (display "reverse!\n")
        (s8vector-reverse! v 1 3)
        (test-equiv "reverse2!" '(1 3 2) v))
      (let ((v (s8vector 10 20 30 40 50)))
        ;; (display "copy!\n")
        (s8vector-copy! v 1 s5 2 4)
        (test-equiv "copy!" '(10 3 4 40 50) v))
      (let ((v (s8vector 10 20 30 40 50)))
        ;; (display "reverse-copy!\n")
        (s8vector-reverse-copy! v 1 s5 2 4)
        (test-equiv "reverse-copy!" '(10 4 3 40 50) v))
      (let ((v (s8vector 1 2 3 4 5 6 7 8)))
        ;; (display "unfold!")
        (s8vector-unfold! (lambda (x) (values (* x 2) (* x 2)))
                         v 1 6 1)
        (test-equiv "vector-unfold!" '(1 2 4 8 16 32 7 8) v))
      (let ((v (s8vector 1 2 3 4 5 6 7 8)))
        ;; (display "unfold-right!")
        (s8vector-unfold-right! (lambda (x) (values (* x 2) (* x 2)))
                               v 1 6 1)
        (test-equiv "vector-unfold!" '(1 32 16 8 4 2 7 8) v))
      ) ; end s8vector/mutators

    (test-group "s8vector/conversion"
      (test "s8vector->list 1" '(1 2 3 4 5)
            (map inexact->exact (s8vector->list s5)))
      (test "s8vector->list 2" '(2 3 4 5)
            (map inexact->exact (s8vector->list s5 1)))
      (test "s8vector->list 3" '(2 3 4)
            (map inexact->exact (s8vector->list s5 1 4)))
      (test "s8vector->vector 1" #(1 2 3 4 5)
            (vector-map inexact->exact (s8vector->vector s5)))
      (test "s8vector->vector 2" #(2 3 4 5)
            (vector-map inexact->exact (s8vector->vector s5 1)))
      (test "s8vector->vector 3" #(2 3 4)
            (vector-map inexact->exact (s8vector->vector s5 1 4)))
      (test-equiv "list->s8vector" '(1 2 3 4 5)
                  (list->s8vector '(1 2 3 4 5)))
      (test-equiv "reverse-list->s8vector" '(5 4 3 2 1)
                  (reverse-list->s8vector '(1 2 3 4 5)))
      (test-equiv "vector->s8vector 1" '(1 2 3 4 5)
                  (vector->s8vector #(1 2 3 4 5)))
      (test-equiv "vector->s8vector 2" '(2 3 4 5)
                  (vector->s8vector #(1 2 3 4 5) 1))
      (test-equiv "vector->s8vector 3" '(2 3 4)
                  (vector->s8vector #(1 2 3 4 5) 1 4))
      ) ; end s8vector/conversion

    (test-group "s8vector/misc"
      ;; (let ((port (open-output-string)))
      ;;   (write-s8vector s5 port)
      ;;   (test "write-s8vector" "#s8(1 2 3 4 5)" (get-output-string port))
      ;;   (close-output-port port))

      (test-assert "s8vector< short" (s8vector< s4 s5))
      (test-assert "not s8vector< short" (not (s8vector< s5 s4)))
      (test-assert "s8vector< samelen" (s8vector< s5 s5+))
      (test-assert "not s8vector< samelen" (not (s8vector< s5+ s5+)))
      (test-assert "s8vector=" (s8vector= s5+ s5+))
      (test "s8vector-hash" 15 (s8vector-hash s5))

      (test "s8vector-gen 0" 1 (inexact->exact (g)))
      (test "s8vector-gen 1" 2 (inexact->exact (g)))
      (test "s8vector-gen 2" 3 (inexact->exact (g)))
      (test "s8vector-gen 3" 4 (inexact->exact (g)))
      (test "s8vector-gen 4" 5 (inexact->exact (g)))
      (test-assert (eof-object? (g)))
      ) ; end s8vector/misc

    ) ; end s8vector

  )
(import (srfi 160 u16))

(test-group "u16vector tests"
  (define (times2 x) (* x 2))
  (define s5 (u16vector 1 2 3 4 5))
  (define s4 (u16vector 1 2 3 4))
  (define s5+ (u16vector 1 2 3 4 6))

  (define (steady i x) (values x x))
  (define (count-up i x) (values x (+ x 1)))
  (define (count-down i x) (values x (- x 1)))
  (define (odd+1 x) (if (odd? x) (+ 1 x) #f))
  (define u16vector< (comparator-ordering-predicate u16vector-comparator))
  (define u16vector-hash (comparator-hash-function u16vector-comparator))

  (define g (make-u16vector-generator s5))
  (define-syntax test-equiv
    (syntax-rules ()
      ((test-equiv expect expr)
       (test expect (map inexact->exact (u16vector->list expr))))
      ((test-equiv name expect expr)
       (test name expect (map inexact->exact (u16vector->list expr))))))

  (test-group "u16vector"
    (test-group "u16vector/constructors"
      (test-equiv "make" '(3 3 3 3 3) (make-u16vector 5 3))
      (test-equiv "u16vector" '(2 1 0 1 2) (u16vector 2 1 0 1 2))
      (test-equiv "unfold up" '(10 11 12 13 14)
                  (u16vector-unfold count-up 5 10))
      (test-equiv "unfold down" '(10 9 8 7 6)
                  (u16vector-unfold count-down 5 10))
      (test-equiv "unfold steady" '(10 10 10 10 10)
                  (u16vector-unfold steady 5 10))
      (test-equiv "unfold-right up" '(14 13 12 11 10)
                  (u16vector-unfold-right count-up 5 10))
      (test-equiv "unfold-right down" '(6 7 8 9 10)
                  (u16vector-unfold-right count-down 5 10))
      (test-equiv "unfold-right steady" '(10 10 10 10 10)
                  (u16vector-unfold-right steady 5 10))
      (test-equiv "copy" '(1 2 3 4 5) (u16vector-copy s5))
      (test-assert "copy2" (not (eqv? s5 (u16vector-copy s5))))
      (test-equiv "copy3" '(2 3) (u16vector-copy s5 1 3))
      (test-equiv "reverse-copy" '(5 4 3 2 1) (u16vector-reverse-copy s5))
      (test-equiv "append" '(1 2 3 4 5 1 2 3 4 5)
                  (u16vector-append s5 s5))
      (test-equiv "concatenate" '(1 2 3 4 5 1 2 3 4 5)
                  (u16vector-concatenate (list s5 s5)))
      (test-equiv "append-subvectors" '(2 3 2 3)
                  (u16vector-append-subvectors s5 1 3 s5 1 3))
      ) ; end u16vector/constructors

    ;; (test-group "u16vector/predicates"
    ;;   (test-assert "u16?" (u16? 5))
    ;;   (test-assert "not u16?" (not (u16? 65536)))
    ;;   (test-assert "u16vector?" (u16vector? s5))
    ;;   (test-assert "not u16vector?" (not (u16vector? #t)))
    ;;   (test-assert "empty" (u16vector-empty? (u16vector)))
    ;;   (test-assert "not empty" (not (u16vector-empty? s5)))
    ;;   (test-assert "=" (u16vector= (u16vector 1 2 3) (u16vector 1 2 3)))
    ;;   (test-assert "= multi" (u16vector= (u16vector 1 2 3)
    ;;                                    (u16vector 1 2 3)
    ;;                                    (u16vector 1 2 3)))
    ;;   (test-assert "not =" (not (u16vector= (u16vector 1 2 3) (u16vector 3 2 1))))
    ;;   (test-assert "not =2" (not (u16vector= (u16vector 1 2 3) (u16vector 1 2))))
    ;;   (test-assert "not = multi" (not (u16vector= (u16vector 1 2 3)
    ;;                                             (u16vector 1 2 3)
    ;;                                             (u16vector 3 2 1))))
    ;;   )
                                        ; end u16vector/predicates

    (test-group "u16vector/selectors"
      (test "ref" 1 (inexact->exact (u16vector-ref (u16vector 1 2 3) 0)))
      (test "length" 3 (u16vector-length (u16vector 1 2 3)))
      ) ; end u16vector/selectors

    (test-group "u16vector/iteration"
      (test-equiv "take" '(1 2) (u16vector-take s5 2))
      (test-equiv "take-right" '(4 5) (u16vector-take-right s5 2))
      (test-equiv "drop" '(3 4 5) (u16vector-drop s5 2))
      (test-equiv "drop-right" '(1 2 3) (u16vector-drop-right s5 2))
      (test "segment" (list (u16vector 1 2 3) (u16vector 4 5))
            (u16vector-segment s5 3))
      (test "fold" -6 (inexact->exact (u16vector-fold - 0 (u16vector 1 2 3))))
      ;; (test "fold" '(((0 1 4) 2 5) 3 6)
      ;;       (u16vector-fold list 0 (u16vector 1 2 3) (u16vector 4 5 6)))
      (test "fold-right" -6 (inexact->exact (u16vector-fold-right - 0 (u16vector 1 2 3))))
      ;; (test "fold-right" '(((0 3 6) 2 5) 1 4)
      ;;       (u16vector-fold-right list 0 (u16vector 1 2 3) (u16vector 4 5 6)))
      (test-equiv "map" '(1 4 9 16 25) (u16vector-map (cut expt <> 2) s5))
      (test-equiv "map" '(0 0 0 0 0) (u16vector-map - s5 s5))
      (let ((v (u16vector 1 2 3 4 5)))
        (u16vector-map! (cut expt <> 2) v)
        (test-equiv "map!" '(1 4 9 16 25) v))
      (let ((v (u16vector 1 2 3 4 5))
            (v2 (u16vector 6 7 8 9 10)))
        (u16vector-map! + v v2)
        (test-equiv "map!" '(7 9 11 13 15) v))
      (let ((list '()))
        (u16vector-for-each
         (lambda (e) (set! list (cons e list)))
         s5)
        ;; stupid hack to shut up test egg about testing the value of a variable
        (test "for-each" '(5 4 3 2 1) (map inexact->exact (cons (car list) (cdr list)))))
      ;; (let ((list '()))
      ;;   (u16vector-for-each
      ;;    (lambda (e1 e2) (set! list (cons (cons e1 e2) list)))
      ;;    s5
      ;;    (u16vector 6 7 8 9 10))
      ;;   ;; stupid hack to shut up test egg about testing the value of a variable
      ;;   (test "for-each" '((5 . 10) (4 . 9) (3 . 8) (2 . 7) (1 . 6))
      ;;         (cons (car list) (cdr list))))
      (test "count" 3 (u16vector-count odd? s5))
      (test "count" 2 (u16vector-count > s5 (u16vector 9 2 1 5 3)))
      (test-equiv "cumulate" '(1 3 6 10 15)
                  (u16vector-cumulate + 0 s5))
      ) ; end u16vector/iteration

    (test-group "u16vector/searching"
      (test-equiv "take-while" '(1) (u16vector-take-while odd? s5))
      (test-equiv "take-while-right" '(5) (u16vector-take-while-right odd? s5))
      (test-equiv "drop-while" '(2 3 4 5) (u16vector-drop-while odd? s5))
      (test-equiv "drop-while-right" '(1 2 3 4) (u16vector-drop-while-right odd? s5))
      ;; (test-equiv "degenerate take-while" '() (u16vector-take-while inexact? s5))
      ;; (test-equiv "degenerate take-while-right" '() (u16vector-take-while-right inexact? s5))
      ;; (test-equiv "degenerate drop-while" '(1 2 3 4 5) (u16vector-drop-while inexact? s5))
      ;; (test-equiv "degenerate drop-while-right" '(1 2 3 4 5) (u16vector-drop-while-right inexact? s5))
      (test "index" 1 (u16vector-index even? s5))
      (test "index" 2 (u16vector-index < s5 (u16vector 0 0 10 10 0)))
      (test "index-right" 3 (u16vector-index-right even? s5))
      (test "index-right" 3 (u16vector-index-right < s5 (u16vector 0 0 10 10 0)))
      (test "skip" 1 (u16vector-skip odd? s5))
      (test "skip" 2 (u16vector-skip > s5 (u16vector 0 0 10 10 0)))
      (test "skip-right" 3 (u16vector-skip-right odd? s5))
      (test "skip-right" 3 (u16vector-skip-right > s5 (u16vector 0 0 10 10 0)))
      (test "any" 4 (inexact->exact (u16vector-any (lambda (x) (and (even? x) (* x 2))) s5)))
      (test-assert "not any" (not (u16vector-any list? s5)))
      (test "any + 1" 2 (inexact->exact (u16vector-any odd+1 s5)))
      (test-assert "every" (u16vector-every number? s5))
      (test-assert "not every" (not (u16vector-every odd? s5)))
      (test-assert "every + 1" (not (u16vector-every odd+1 s5)))
      (test "multi-any" 10 (inexact->exact (u16vector-any (lambda (x y) (and (even? x) (even? y) (+ x y)))
                                                        s5 (u16vector 0 1 2 6 4))))
      (test "multi-any 2" #f (u16vector-any (lambda (x y) (and (even? x) (even? y) (+ x y)))
                                          s5 (u16vector 0 1 2 5 4)))
      (test "multi-every" 10 (inexact->exact (u16vector-every (lambda (x) (and (number? x) (* x 2))) s5)))
      (test "multi-every-2" 10 (inexact->exact (u16vector-every (lambda (x y) (and (number? x) (number? y) (+ x y)))
                                                              s5 s5)))
      (test-assert "multi-not every" (not (u16vector-every < s5 (u16vector 10 10 10 10 0))))
      (test-equiv "partition" '(1 3 5 2 4) (u16vector-partition odd? s5))
      (test-equiv "filter" '(1 3 5) (u16vector-filter odd? s5))
      (test-equiv "remove" '(2 4) (u16vector-remove odd? s5))
      ) ; end u16vector/searching

    (test-group "u16vector/mutators"
      (let ((v (u16vector 1 2 3)))
        ;; (display "set!\n")
        (u16vector-set! v 0 10)
        (test-equiv "set!" '(10 2 3) v))
      (let ((v (u16vector 1 2 3)))
        ;; (display "swap!\n")
        (u16vector-swap! v 0 1)
        (test-equiv "swap!" '(2 1 3) v))
      (let ((v (u16vector 1 2 3)))
        ;; (display "fill!\n")
        (u16vector-fill! v 2)
        (test-equiv "fill!" '(2 2 2) v))
      (let ((v (u16vector 1 2 3)))
        ;; (display "fill2!\n")
        (u16vector-fill! v 10 0 2)
        (test-equiv "fill2!" '(10 10 3) v))
      (let ((v (u16vector 1 2 3)))
        ;; (display "reverse!\n")
        (u16vector-reverse! v)
        (test-equiv "reverse!" '(3 2 1) v))
      (let ((v (u16vector 1 2 3)))
        ;; (display "reverse!\n")
        (u16vector-reverse! v 1 3)
        (test-equiv "reverse2!" '(1 3 2) v))
      (let ((v (u16vector 10 20 30 40 50)))
        ;; (display "copy!\n")
        (u16vector-copy! v 1 s5 2 4)
        (test-equiv "copy!" '(10 3 4 40 50) v))
      (let ((v (u16vector 10 20 30 40 50)))
        ;; (display "reverse-copy!\n")
        (u16vector-reverse-copy! v 1 s5 2 4)
        (test-equiv "reverse-copy!" '(10 4 3 40 50) v))
      (let ((v (u16vector 1 2 3 4 5 6 7 8)))
        ;; (display "unfold!")
        (u16vector-unfold! (lambda (x) (values (* x 2) (* x 2)))
                         v 1 6 1)
        (test-equiv "vector-unfold!" '(1 2 4 8 16 32 7 8) v))
      (let ((v (u16vector 1 2 3 4 5 6 7 8)))
        ;; (display "unfold-right!")
        (u16vector-unfold-right! (lambda (x) (values (* x 2) (* x 2)))
                               v 1 6 1)
        (test-equiv "vector-unfold!" '(1 32 16 8 4 2 7 8) v))
      ) ; end u16vector/mutators

    (test-group "u16vector/conversion"
      (test "u16vector->list 1" '(1 2 3 4 5)
            (map inexact->exact (u16vector->list s5)))
      (test "u16vector->list 2" '(2 3 4 5)
            (map inexact->exact (u16vector->list s5 1)))
      (test "u16vector->list 3" '(2 3 4)
            (map inexact->exact (u16vector->list s5 1 4)))
      (test "u16vector->vector 1" #(1 2 3 4 5)
            (vector-map inexact->exact (u16vector->vector s5)))
      (test "u16vector->vector 2" #(2 3 4 5)
            (vector-map inexact->exact (u16vector->vector s5 1)))
      (test "u16vector->vector 3" #(2 3 4)
            (vector-map inexact->exact (u16vector->vector s5 1 4)))
      (test-equiv "list->u16vector" '(1 2 3 4 5)
                  (list->u16vector '(1 2 3 4 5)))
      (test-equiv "reverse-list->u16vector" '(5 4 3 2 1)
                  (reverse-list->u16vector '(1 2 3 4 5)))
      (test-equiv "vector->u16vector 1" '(1 2 3 4 5)
                  (vector->u16vector #(1 2 3 4 5)))
      (test-equiv "vector->u16vector 2" '(2 3 4 5)
                  (vector->u16vector #(1 2 3 4 5) 1))
      (test-equiv "vector->u16vector 3" '(2 3 4)
                  (vector->u16vector #(1 2 3 4 5) 1 4))
      ) ; end u16vector/conversion

    (test-group "u16vector/misc"
      ;; (let ((port (open-output-string)))
      ;;   (write-u16vector s5 port)
      ;;   (test "write-u16vector" "#u16(1 2 3 4 5)" (get-output-string port))
      ;;   (close-output-port port))

      (test-assert "u16vector< short" (u16vector< s4 s5))
      (test-assert "not u16vector< short" (not (u16vector< s5 s4)))
      (test-assert "u16vector< samelen" (u16vector< s5 s5+))
      (test-assert "not u16vector< samelen" (not (u16vector< s5+ s5+)))
      (test-assert "u16vector=" (u16vector= s5+ s5+))
      (test "u16vector-hash" 15 (u16vector-hash s5))

      (test "u16vector-gen 0" 1 (inexact->exact (g)))
      (test "u16vector-gen 1" 2 (inexact->exact (g)))
      (test "u16vector-gen 2" 3 (inexact->exact (g)))
      (test "u16vector-gen 3" 4 (inexact->exact (g)))
      (test "u16vector-gen 4" 5 (inexact->exact (g)))
      (test-assert (eof-object? (g)))
      ) ; end u16vector/misc

    ) ; end u16vector

  )
(import (srfi 160 s16))

(test-group "s16vector tests"
  (define (times2 x) (* x 2))
  (define s5 (s16vector 1 2 3 4 5))
  (define s4 (s16vector 1 2 3 4))
  (define s5+ (s16vector 1 2 3 4 6))

  (define (steady i x) (values x x))
  (define (count-up i x) (values x (+ x 1)))
  (define (count-down i x) (values x (- x 1)))
  (define (odd+1 x) (if (odd? x) (+ 1 x) #f))
  (define s16vector< (comparator-ordering-predicate s16vector-comparator))
  (define s16vector-hash (comparator-hash-function s16vector-comparator))

  (define g (make-s16vector-generator s5))
  (define-syntax test-equiv
    (syntax-rules ()
      ((test-equiv expect expr)
       (test expect (map inexact->exact (s16vector->list expr))))
      ((test-equiv name expect expr)
       (test name expect (map inexact->exact (s16vector->list expr))))))

  (test-group "s16vector"
    (test-group "s16vector/constructors"
      (test-equiv "make" '(3 3 3 3 3) (make-s16vector 5 3))
      (test-equiv "s16vector" '(2 1 0 1 2) (s16vector 2 1 0 1 2))
      (test-equiv "unfold up" '(10 11 12 13 14)
                  (s16vector-unfold count-up 5 10))
      (test-equiv "unfold down" '(10 9 8 7 6)
                  (s16vector-unfold count-down 5 10))
      (test-equiv "unfold steady" '(10 10 10 10 10)
                  (s16vector-unfold steady 5 10))
      (test-equiv "unfold-right up" '(14 13 12 11 10)
                  (s16vector-unfold-right count-up 5 10))
      (test-equiv "unfold-right down" '(6 7 8 9 10)
                  (s16vector-unfold-right count-down 5 10))
      (test-equiv "unfold-right steady" '(10 10 10 10 10)
                  (s16vector-unfold-right steady 5 10))
      (test-equiv "copy" '(1 2 3 4 5) (s16vector-copy s5))
      (test-assert "copy2" (not (eqv? s5 (s16vector-copy s5))))
      (test-equiv "copy3" '(2 3) (s16vector-copy s5 1 3))
      (test-equiv "reverse-copy" '(5 4 3 2 1) (s16vector-reverse-copy s5))
      (test-equiv "append" '(1 2 3 4 5 1 2 3 4 5)
                  (s16vector-append s5 s5))
      (test-equiv "concatenate" '(1 2 3 4 5 1 2 3 4 5)
                  (s16vector-concatenate (list s5 s5)))
      (test-equiv "append-subvectors" '(2 3 2 3)
                  (s16vector-append-subvectors s5 1 3 s5 1 3))
      ) ; end s16vector/constructors

    ;; (test-group "s16vector/predicates"
    ;;   (test-assert "s16?" (s16? 5))
    ;;   (test-assert "not s16?" (not (s16? 65536)))
    ;;   (test-assert "s16vector?" (s16vector? s5))
    ;;   (test-assert "not s16vector?" (not (s16vector? #t)))
    ;;   (test-assert "empty" (s16vector-empty? (s16vector)))
    ;;   (test-assert "not empty" (not (s16vector-empty? s5)))
    ;;   (test-assert "=" (s16vector= (s16vector 1 2 3) (s16vector 1 2 3)))
    ;;   (test-assert "= multi" (s16vector= (s16vector 1 2 3)
    ;;                                    (s16vector 1 2 3)
    ;;                                    (s16vector 1 2 3)))
    ;;   (test-assert "not =" (not (s16vector= (s16vector 1 2 3) (s16vector 3 2 1))))
    ;;   (test-assert "not =2" (not (s16vector= (s16vector 1 2 3) (s16vector 1 2))))
    ;;   (test-assert "not = multi" (not (s16vector= (s16vector 1 2 3)
    ;;                                             (s16vector 1 2 3)
    ;;                                             (s16vector 3 2 1))))
    ;;   )
                                        ; end s16vector/predicates

    (test-group "s16vector/selectors"
      (test "ref" 1 (inexact->exact (s16vector-ref (s16vector 1 2 3) 0)))
      (test "length" 3 (s16vector-length (s16vector 1 2 3)))
      ) ; end s16vector/selectors

    (test-group "s16vector/iteration"
      (test-equiv "take" '(1 2) (s16vector-take s5 2))
      (test-equiv "take-right" '(4 5) (s16vector-take-right s5 2))
      (test-equiv "drop" '(3 4 5) (s16vector-drop s5 2))
      (test-equiv "drop-right" '(1 2 3) (s16vector-drop-right s5 2))
      (test "segment" (list (s16vector 1 2 3) (s16vector 4 5))
            (s16vector-segment s5 3))
      (test "fold" -6 (inexact->exact (s16vector-fold - 0 (s16vector 1 2 3))))
      ;; (test "fold" '(((0 1 4) 2 5) 3 6)
      ;;       (s16vector-fold list 0 (s16vector 1 2 3) (s16vector 4 5 6)))
      (test "fold-right" -6 (inexact->exact (s16vector-fold-right - 0 (s16vector 1 2 3))))
      ;; (test "fold-right" '(((0 3 6) 2 5) 1 4)
      ;;       (s16vector-fold-right list 0 (s16vector 1 2 3) (s16vector 4 5 6)))
      (test-equiv "map" '(1 4 9 16 25) (s16vector-map (cut expt <> 2) s5))
      (test-equiv "map" '(0 0 0 0 0) (s16vector-map - s5 s5))
      (let ((v (s16vector 1 2 3 4 5)))
        (s16vector-map! (cut expt <> 2) v)
        (test-equiv "map!" '(1 4 9 16 25) v))
      (let ((v (s16vector 1 2 3 4 5))
            (v2 (s16vector 6 7 8 9 10)))
        (s16vector-map! + v v2)
        (test-equiv "map!" '(7 9 11 13 15) v))
      (let ((list '()))
        (s16vector-for-each
         (lambda (e) (set! list (cons e list)))
         s5)
        ;; stupid hack to shut up test egg about testing the value of a variable
        (test "for-each" '(5 4 3 2 1) (map inexact->exact (cons (car list) (cdr list)))))
      ;; (let ((list '()))
      ;;   (s16vector-for-each
      ;;    (lambda (e1 e2) (set! list (cons (cons e1 e2) list)))
      ;;    s5
      ;;    (s16vector 6 7 8 9 10))
      ;;   ;; stupid hack to shut up test egg about testing the value of a variable
      ;;   (test "for-each" '((5 . 10) (4 . 9) (3 . 8) (2 . 7) (1 . 6))
      ;;         (cons (car list) (cdr list))))
      (test "count" 3 (s16vector-count odd? s5))
      (test "count" 2 (s16vector-count > s5 (s16vector 9 2 1 5 3)))
      (test-equiv "cumulate" '(1 3 6 10 15)
                  (s16vector-cumulate + 0 s5))
      ) ; end s16vector/iteration

    (test-group "s16vector/searching"
      (test-equiv "take-while" '(1) (s16vector-take-while odd? s5))
      (test-equiv "take-while-right" '(5) (s16vector-take-while-right odd? s5))
      (test-equiv "drop-while" '(2 3 4 5) (s16vector-drop-while odd? s5))
      (test-equiv "drop-while-right" '(1 2 3 4) (s16vector-drop-while-right odd? s5))
      ;; (test-equiv "degenerate take-while" '() (s16vector-take-while inexact? s5))
      ;; (test-equiv "degenerate take-while-right" '() (s16vector-take-while-right inexact? s5))
      ;; (test-equiv "degenerate drop-while" '(1 2 3 4 5) (s16vector-drop-while inexact? s5))
      ;; (test-equiv "degenerate drop-while-right" '(1 2 3 4 5) (s16vector-drop-while-right inexact? s5))
      (test "index" 1 (s16vector-index even? s5))
      (test "index" 2 (s16vector-index < s5 (s16vector 0 0 10 10 0)))
      (test "index-right" 3 (s16vector-index-right even? s5))
      (test "index-right" 3 (s16vector-index-right < s5 (s16vector 0 0 10 10 0)))
      (test "skip" 1 (s16vector-skip odd? s5))
      (test "skip" 2 (s16vector-skip > s5 (s16vector 0 0 10 10 0)))
      (test "skip-right" 3 (s16vector-skip-right odd? s5))
      (test "skip-right" 3 (s16vector-skip-right > s5 (s16vector 0 0 10 10 0)))
      (test "any" 4 (inexact->exact (s16vector-any (lambda (x) (and (even? x) (* x 2))) s5)))
      (test-assert "not any" (not (s16vector-any list? s5)))
      (test "any + 1" 2 (inexact->exact (s16vector-any odd+1 s5)))
      (test-assert "every" (s16vector-every number? s5))
      (test-assert "not every" (not (s16vector-every odd? s5)))
      (test-assert "every + 1" (not (s16vector-every odd+1 s5)))
      (test "multi-any" 10 (inexact->exact (s16vector-any (lambda (x y) (and (even? x) (even? y) (+ x y)))
                                                        s5 (s16vector 0 1 2 6 4))))
      (test "multi-any 2" #f (s16vector-any (lambda (x y) (and (even? x) (even? y) (+ x y)))
                                          s5 (s16vector 0 1 2 5 4)))
      (test "multi-every" 10 (inexact->exact (s16vector-every (lambda (x) (and (number? x) (* x 2))) s5)))
      (test "multi-every-2" 10 (inexact->exact (s16vector-every (lambda (x y) (and (number? x) (number? y) (+ x y)))
                                                              s5 s5)))
      (test-assert "multi-not every" (not (s16vector-every < s5 (s16vector 10 10 10 10 0))))
      (test-equiv "partition" '(1 3 5 2 4) (s16vector-partition odd? s5))
      (test-equiv "filter" '(1 3 5) (s16vector-filter odd? s5))
      (test-equiv "remove" '(2 4) (s16vector-remove odd? s5))
      ) ; end s16vector/searching

    (test-group "s16vector/mutators"
      (let ((v (s16vector 1 2 3)))
        ;; (display "set!\n")
        (s16vector-set! v 0 10)
        (test-equiv "set!" '(10 2 3) v))
      (let ((v (s16vector 1 2 3)))
        ;; (display "swap!\n")
        (s16vector-swap! v 0 1)
        (test-equiv "swap!" '(2 1 3) v))
      (let ((v (s16vector 1 2 3)))
        ;; (display "fill!\n")
        (s16vector-fill! v 2)
        (test-equiv "fill!" '(2 2 2) v))
      (let ((v (s16vector 1 2 3)))
        ;; (display "fill2!\n")
        (s16vector-fill! v 10 0 2)
        (test-equiv "fill2!" '(10 10 3) v))
      (let ((v (s16vector 1 2 3)))
        ;; (display "reverse!\n")
        (s16vector-reverse! v)
        (test-equiv "reverse!" '(3 2 1) v))
      (let ((v (s16vector 1 2 3)))
        ;; (display "reverse!\n")
        (s16vector-reverse! v 1 3)
        (test-equiv "reverse2!" '(1 3 2) v))
      (let ((v (s16vector 10 20 30 40 50)))
        ;; (display "copy!\n")
        (s16vector-copy! v 1 s5 2 4)
        (test-equiv "copy!" '(10 3 4 40 50) v))
      (let ((v (s16vector 10 20 30 40 50)))
        ;; (display "reverse-copy!\n")
        (s16vector-reverse-copy! v 1 s5 2 4)
        (test-equiv "reverse-copy!" '(10 4 3 40 50) v))
      (let ((v (s16vector 1 2 3 4 5 6 7 8)))
        ;; (display "unfold!")
        (s16vector-unfold! (lambda (x) (values (* x 2) (* x 2)))
                         v 1 6 1)
        (test-equiv "vector-unfold!" '(1 2 4 8 16 32 7 8) v))
      (let ((v (s16vector 1 2 3 4 5 6 7 8)))
        ;; (display "unfold-right!")
        (s16vector-unfold-right! (lambda (x) (values (* x 2) (* x 2)))
                               v 1 6 1)
        (test-equiv "vector-unfold!" '(1 32 16 8 4 2 7 8) v))
      ) ; end s16vector/mutators

    (test-group "s16vector/conversion"
      (test "s16vector->list 1" '(1 2 3 4 5)
            (map inexact->exact (s16vector->list s5)))
      (test "s16vector->list 2" '(2 3 4 5)
            (map inexact->exact (s16vector->list s5 1)))
      (test "s16vector->list 3" '(2 3 4)
            (map inexact->exact (s16vector->list s5 1 4)))
      (test "s16vector->vector 1" #(1 2 3 4 5)
            (vector-map inexact->exact (s16vector->vector s5)))
      (test "s16vector->vector 2" #(2 3 4 5)
            (vector-map inexact->exact (s16vector->vector s5 1)))
      (test "s16vector->vector 3" #(2 3 4)
            (vector-map inexact->exact (s16vector->vector s5 1 4)))
      (test-equiv "list->s16vector" '(1 2 3 4 5)
                  (list->s16vector '(1 2 3 4 5)))
      (test-equiv "reverse-list->s16vector" '(5 4 3 2 1)
                  (reverse-list->s16vector '(1 2 3 4 5)))
      (test-equiv "vector->s16vector 1" '(1 2 3 4 5)
                  (vector->s16vector #(1 2 3 4 5)))
      (test-equiv "vector->s16vector 2" '(2 3 4 5)
                  (vector->s16vector #(1 2 3 4 5) 1))
      (test-equiv "vector->s16vector 3" '(2 3 4)
                  (vector->s16vector #(1 2 3 4 5) 1 4))
      ) ; end s16vector/conversion

    (test-group "s16vector/misc"
      ;; (let ((port (open-output-string)))
      ;;   (write-s16vector s5 port)
      ;;   (test "write-s16vector" "#s16(1 2 3 4 5)" (get-output-string port))
      ;;   (close-output-port port))

      (test-assert "s16vector< short" (s16vector< s4 s5))
      (test-assert "not s16vector< short" (not (s16vector< s5 s4)))
      (test-assert "s16vector< samelen" (s16vector< s5 s5+))
      (test-assert "not s16vector< samelen" (not (s16vector< s5+ s5+)))
      (test-assert "s16vector=" (s16vector= s5+ s5+))
      (test "s16vector-hash" 15 (s16vector-hash s5))

      (test "s16vector-gen 0" 1 (inexact->exact (g)))
      (test "s16vector-gen 1" 2 (inexact->exact (g)))
      (test "s16vector-gen 2" 3 (inexact->exact (g)))
      (test "s16vector-gen 3" 4 (inexact->exact (g)))
      (test "s16vector-gen 4" 5 (inexact->exact (g)))
      (test-assert (eof-object? (g)))
      ) ; end s16vector/misc

    ) ; end s16vector

  )
(import (srfi 160 u32))

(test-group "u32vector tests"
  (define (times2 x) (* x 2))
  (define s5 (u32vector 1 2 3 4 5))
  (define s4 (u32vector 1 2 3 4))
  (define s5+ (u32vector 1 2 3 4 6))

  (define (steady i x) (values x x))
  (define (count-up i x) (values x (+ x 1)))
  (define (count-down i x) (values x (- x 1)))
  (define (odd+1 x) (if (odd? x) (+ 1 x) #f))
  (define u32vector< (comparator-ordering-predicate u32vector-comparator))
  (define u32vector-hash (comparator-hash-function u32vector-comparator))

  (define g (make-u32vector-generator s5))
  (define-syntax test-equiv
    (syntax-rules ()
      ((test-equiv expect expr)
       (test expect (map inexact->exact (u32vector->list expr))))
      ((test-equiv name expect expr)
       (test name expect (map inexact->exact (u32vector->list expr))))))

  (test-group "u32vector"
    (test-group "u32vector/constructors"
      (test-equiv "make" '(3 3 3 3 3) (make-u32vector 5 3))
      (test-equiv "u32vector" '(2 1 0 1 2) (u32vector 2 1 0 1 2))
      (test-equiv "unfold up" '(10 11 12 13 14)
                  (u32vector-unfold count-up 5 10))
      (test-equiv "unfold down" '(10 9 8 7 6)
                  (u32vector-unfold count-down 5 10))
      (test-equiv "unfold steady" '(10 10 10 10 10)
                  (u32vector-unfold steady 5 10))
      (test-equiv "unfold-right up" '(14 13 12 11 10)
                  (u32vector-unfold-right count-up 5 10))
      (test-equiv "unfold-right down" '(6 7 8 9 10)
                  (u32vector-unfold-right count-down 5 10))
      (test-equiv "unfold-right steady" '(10 10 10 10 10)
                  (u32vector-unfold-right steady 5 10))
      (test-equiv "copy" '(1 2 3 4 5) (u32vector-copy s5))
      (test-assert "copy2" (not (eqv? s5 (u32vector-copy s5))))
      (test-equiv "copy3" '(2 3) (u32vector-copy s5 1 3))
      (test-equiv "reverse-copy" '(5 4 3 2 1) (u32vector-reverse-copy s5))
      (test-equiv "append" '(1 2 3 4 5 1 2 3 4 5)
                  (u32vector-append s5 s5))
      (test-equiv "concatenate" '(1 2 3 4 5 1 2 3 4 5)
                  (u32vector-concatenate (list s5 s5)))
      (test-equiv "append-subvectors" '(2 3 2 3)
                  (u32vector-append-subvectors s5 1 3 s5 1 3))
      ) ; end u32vector/constructors

    ;; (test-group "u32vector/predicates"
    ;;   (test-assert "u32?" (u32? 5))
    ;;   (test-assert "not u32?" (not (u32? 65536)))
    ;;   (test-assert "u32vector?" (u32vector? s5))
    ;;   (test-assert "not u32vector?" (not (u32vector? #t)))
    ;;   (test-assert "empty" (u32vector-empty? (u32vector)))
    ;;   (test-assert "not empty" (not (u32vector-empty? s5)))
    ;;   (test-assert "=" (u32vector= (u32vector 1 2 3) (u32vector 1 2 3)))
    ;;   (test-assert "= multi" (u32vector= (u32vector 1 2 3)
    ;;                                    (u32vector 1 2 3)
    ;;                                    (u32vector 1 2 3)))
    ;;   (test-assert "not =" (not (u32vector= (u32vector 1 2 3) (u32vector 3 2 1))))
    ;;   (test-assert "not =2" (not (u32vector= (u32vector 1 2 3) (u32vector 1 2))))
    ;;   (test-assert "not = multi" (not (u32vector= (u32vector 1 2 3)
    ;;                                             (u32vector 1 2 3)
    ;;                                             (u32vector 3 2 1))))
    ;;   )
                                        ; end u32vector/predicates

    (test-group "u32vector/selectors"
      (test "ref" 1 (inexact->exact (u32vector-ref (u32vector 1 2 3) 0)))
      (test "length" 3 (u32vector-length (u32vector 1 2 3)))
      ) ; end u32vector/selectors

    (test-group "u32vector/iteration"
      (test-equiv "take" '(1 2) (u32vector-take s5 2))
      (test-equiv "take-right" '(4 5) (u32vector-take-right s5 2))
      (test-equiv "drop" '(3 4 5) (u32vector-drop s5 2))
      (test-equiv "drop-right" '(1 2 3) (u32vector-drop-right s5 2))
      (test "segment" (list (u32vector 1 2 3) (u32vector 4 5))
            (u32vector-segment s5 3))
      (test "fold" -6 (inexact->exact (u32vector-fold - 0 (u32vector 1 2 3))))
      ;; (test "fold" '(((0 1 4) 2 5) 3 6)
      ;;       (u32vector-fold list 0 (u32vector 1 2 3) (u32vector 4 5 6)))
      (test "fold-right" -6 (inexact->exact (u32vector-fold-right - 0 (u32vector 1 2 3))))
      ;; (test "fold-right" '(((0 3 6) 2 5) 1 4)
      ;;       (u32vector-fold-right list 0 (u32vector 1 2 3) (u32vector 4 5 6)))
      (test-equiv "map" '(1 4 9 16 25) (u32vector-map (cut expt <> 2) s5))
      (test-equiv "map" '(0 0 0 0 0) (u32vector-map - s5 s5))
      (let ((v (u32vector 1 2 3 4 5)))
        (u32vector-map! (cut expt <> 2) v)
        (test-equiv "map!" '(1 4 9 16 25) v))
      (let ((v (u32vector 1 2 3 4 5))
            (v2 (u32vector 6 7 8 9 10)))
        (u32vector-map! + v v2)
        (test-equiv "map!" '(7 9 11 13 15) v))
      (let ((list '()))
        (u32vector-for-each
         (lambda (e) (set! list (cons e list)))
         s5)
        ;; stupid hack to shut up test egg about testing the value of a variable
        (test "for-each" '(5 4 3 2 1) (map inexact->exact (cons (car list) (cdr list)))))
      ;; (let ((list '()))
      ;;   (u32vector-for-each
      ;;    (lambda (e1 e2) (set! list (cons (cons e1 e2) list)))
      ;;    s5
      ;;    (u32vector 6 7 8 9 10))
      ;;   ;; stupid hack to shut up test egg about testing the value of a variable
      ;;   (test "for-each" '((5 . 10) (4 . 9) (3 . 8) (2 . 7) (1 . 6))
      ;;         (cons (car list) (cdr list))))
      (test "count" 3 (u32vector-count odd? s5))
      (test "count" 2 (u32vector-count > s5 (u32vector 9 2 1 5 3)))
      (test-equiv "cumulate" '(1 3 6 10 15)
                  (u32vector-cumulate + 0 s5))
      ) ; end u32vector/iteration

    (test-group "u32vector/searching"
      (test-equiv "take-while" '(1) (u32vector-take-while odd? s5))
      (test-equiv "take-while-right" '(5) (u32vector-take-while-right odd? s5))
      (test-equiv "drop-while" '(2 3 4 5) (u32vector-drop-while odd? s5))
      (test-equiv "drop-while-right" '(1 2 3 4) (u32vector-drop-while-right odd? s5))
      ;; (test-equiv "degenerate take-while" '() (u32vector-take-while inexact? s5))
      ;; (test-equiv "degenerate take-while-right" '() (u32vector-take-while-right inexact? s5))
      ;; (test-equiv "degenerate drop-while" '(1 2 3 4 5) (u32vector-drop-while inexact? s5))
      ;; (test-equiv "degenerate drop-while-right" '(1 2 3 4 5) (u32vector-drop-while-right inexact? s5))
      (test "index" 1 (u32vector-index even? s5))
      (test "index" 2 (u32vector-index < s5 (u32vector 0 0 10 10 0)))
      (test "index-right" 3 (u32vector-index-right even? s5))
      (test "index-right" 3 (u32vector-index-right < s5 (u32vector 0 0 10 10 0)))
      (test "skip" 1 (u32vector-skip odd? s5))
      (test "skip" 2 (u32vector-skip > s5 (u32vector 0 0 10 10 0)))
      (test "skip-right" 3 (u32vector-skip-right odd? s5))
      (test "skip-right" 3 (u32vector-skip-right > s5 (u32vector 0 0 10 10 0)))
      (test "any" 4 (inexact->exact (u32vector-any (lambda (x) (and (even? x) (* x 2))) s5)))
      (test-assert "not any" (not (u32vector-any list? s5)))
      (test "any + 1" 2 (inexact->exact (u32vector-any odd+1 s5)))
      (test-assert "every" (u32vector-every number? s5))
      (test-assert "not every" (not (u32vector-every odd? s5)))
      (test-assert "every + 1" (not (u32vector-every odd+1 s5)))
      (test "multi-any" 10 (inexact->exact (u32vector-any (lambda (x y) (and (even? x) (even? y) (+ x y)))
                                                        s5 (u32vector 0 1 2 6 4))))
      (test "multi-any 2" #f (u32vector-any (lambda (x y) (and (even? x) (even? y) (+ x y)))
                                          s5 (u32vector 0 1 2 5 4)))
      (test "multi-every" 10 (inexact->exact (u32vector-every (lambda (x) (and (number? x) (* x 2))) s5)))
      (test "multi-every-2" 10 (inexact->exact (u32vector-every (lambda (x y) (and (number? x) (number? y) (+ x y)))
                                                              s5 s5)))
      (test-assert "multi-not every" (not (u32vector-every < s5 (u32vector 10 10 10 10 0))))
      (test-equiv "partition" '(1 3 5 2 4) (u32vector-partition odd? s5))
      (test-equiv "filter" '(1 3 5) (u32vector-filter odd? s5))
      (test-equiv "remove" '(2 4) (u32vector-remove odd? s5))
      ) ; end u32vector/searching

    (test-group "u32vector/mutators"
      (let ((v (u32vector 1 2 3)))
        ;; (display "set!\n")
        (u32vector-set! v 0 10)
        (test-equiv "set!" '(10 2 3) v))
      (let ((v (u32vector 1 2 3)))
        ;; (display "swap!\n")
        (u32vector-swap! v 0 1)
        (test-equiv "swap!" '(2 1 3) v))
      (let ((v (u32vector 1 2 3)))
        ;; (display "fill!\n")
        (u32vector-fill! v 2)
        (test-equiv "fill!" '(2 2 2) v))
      (let ((v (u32vector 1 2 3)))
        ;; (display "fill2!\n")
        (u32vector-fill! v 10 0 2)
        (test-equiv "fill2!" '(10 10 3) v))
      (let ((v (u32vector 1 2 3)))
        ;; (display "reverse!\n")
        (u32vector-reverse! v)
        (test-equiv "reverse!" '(3 2 1) v))
      (let ((v (u32vector 1 2 3)))
        ;; (display "reverse!\n")
        (u32vector-reverse! v 1 3)
        (test-equiv "reverse2!" '(1 3 2) v))
      (let ((v (u32vector 10 20 30 40 50)))
        ;; (display "copy!\n")
        (u32vector-copy! v 1 s5 2 4)
        (test-equiv "copy!" '(10 3 4 40 50) v))
      (let ((v (u32vector 10 20 30 40 50)))
        ;; (display "reverse-copy!\n")
        (u32vector-reverse-copy! v 1 s5 2 4)
        (test-equiv "reverse-copy!" '(10 4 3 40 50) v))
      (let ((v (u32vector 1 2 3 4 5 6 7 8)))
        ;; (display "unfold!")
        (u32vector-unfold! (lambda (x) (values (* x 2) (* x 2)))
                         v 1 6 1)
        (test-equiv "vector-unfold!" '(1 2 4 8 16 32 7 8) v))
      (let ((v (u32vector 1 2 3 4 5 6 7 8)))
        ;; (display "unfold-right!")
        (u32vector-unfold-right! (lambda (x) (values (* x 2) (* x 2)))
                               v 1 6 1)
        (test-equiv "vector-unfold!" '(1 32 16 8 4 2 7 8) v))
      ) ; end u32vector/mutators

    (test-group "u32vector/conversion"
      (test "u32vector->list 1" '(1 2 3 4 5)
            (map inexact->exact (u32vector->list s5)))
      (test "u32vector->list 2" '(2 3 4 5)
            (map inexact->exact (u32vector->list s5 1)))
      (test "u32vector->list 3" '(2 3 4)
            (map inexact->exact (u32vector->list s5 1 4)))
      (test "u32vector->vector 1" #(1 2 3 4 5)
            (vector-map inexact->exact (u32vector->vector s5)))
      (test "u32vector->vector 2" #(2 3 4 5)
            (vector-map inexact->exact (u32vector->vector s5 1)))
      (test "u32vector->vector 3" #(2 3 4)
            (vector-map inexact->exact (u32vector->vector s5 1 4)))
      (test-equiv "list->u32vector" '(1 2 3 4 5)
                  (list->u32vector '(1 2 3 4 5)))
      (test-equiv "reverse-list->u32vector" '(5 4 3 2 1)
                  (reverse-list->u32vector '(1 2 3 4 5)))
      (test-equiv "vector->u32vector 1" '(1 2 3 4 5)
                  (vector->u32vector #(1 2 3 4 5)))
      (test-equiv "vector->u32vector 2" '(2 3 4 5)
                  (vector->u32vector #(1 2 3 4 5) 1))
      (test-equiv "vector->u32vector 3" '(2 3 4)
                  (vector->u32vector #(1 2 3 4 5) 1 4))
      ) ; end u32vector/conversion

    (test-group "u32vector/misc"
      ;; (let ((port (open-output-string)))
      ;;   (write-u32vector s5 port)
      ;;   (test "write-u32vector" "#u32(1 2 3 4 5)" (get-output-string port))
      ;;   (close-output-port port))

      (test-assert "u32vector< short" (u32vector< s4 s5))
      (test-assert "not u32vector< short" (not (u32vector< s5 s4)))
      (test-assert "u32vector< samelen" (u32vector< s5 s5+))
      (test-assert "not u32vector< samelen" (not (u32vector< s5+ s5+)))
      (test-assert "u32vector=" (u32vector= s5+ s5+))
      (test "u32vector-hash" 15 (u32vector-hash s5))

      (test "u32vector-gen 0" 1 (inexact->exact (g)))
      (test "u32vector-gen 1" 2 (inexact->exact (g)))
      (test "u32vector-gen 2" 3 (inexact->exact (g)))
      (test "u32vector-gen 3" 4 (inexact->exact (g)))
      (test "u32vector-gen 4" 5 (inexact->exact (g)))
      (test-assert (eof-object? (g)))
      ) ; end u32vector/misc

    ) ; end u32vector

  )
(import (srfi 160 s32))

(test-group "s32vector tests"
  (define (times2 x) (* x 2))
  (define s5 (s32vector 1 2 3 4 5))
  (define s4 (s32vector 1 2 3 4))
  (define s5+ (s32vector 1 2 3 4 6))

  (define (steady i x) (values x x))
  (define (count-up i x) (values x (+ x 1)))
  (define (count-down i x) (values x (- x 1)))
  (define (odd+1 x) (if (odd? x) (+ 1 x) #f))
  (define s32vector< (comparator-ordering-predicate s32vector-comparator))
  (define s32vector-hash (comparator-hash-function s32vector-comparator))

  (define g (make-s32vector-generator s5))
  (define-syntax test-equiv
    (syntax-rules ()
      ((test-equiv expect expr)
       (test expect (map inexact->exact (s32vector->list expr))))
      ((test-equiv name expect expr)
       (test name expect (map inexact->exact (s32vector->list expr))))))

  (test-group "s32vector"
    (test-group "s32vector/constructors"
      (test-equiv "make" '(3 3 3 3 3) (make-s32vector 5 3))
      (test-equiv "s32vector" '(2 1 0 1 2) (s32vector 2 1 0 1 2))
      (test-equiv "unfold up" '(10 11 12 13 14)
                  (s32vector-unfold count-up 5 10))
      (test-equiv "unfold down" '(10 9 8 7 6)
                  (s32vector-unfold count-down 5 10))
      (test-equiv "unfold steady" '(10 10 10 10 10)
                  (s32vector-unfold steady 5 10))
      (test-equiv "unfold-right up" '(14 13 12 11 10)
                  (s32vector-unfold-right count-up 5 10))
      (test-equiv "unfold-right down" '(6 7 8 9 10)
                  (s32vector-unfold-right count-down 5 10))
      (test-equiv "unfold-right steady" '(10 10 10 10 10)
                  (s32vector-unfold-right steady 5 10))
      (test-equiv "copy" '(1 2 3 4 5) (s32vector-copy s5))
      (test-assert "copy2" (not (eqv? s5 (s32vector-copy s5))))
      (test-equiv "copy3" '(2 3) (s32vector-copy s5 1 3))
      (test-equiv "reverse-copy" '(5 4 3 2 1) (s32vector-reverse-copy s5))
      (test-equiv "append" '(1 2 3 4 5 1 2 3 4 5)
                  (s32vector-append s5 s5))
      (test-equiv "concatenate" '(1 2 3 4 5 1 2 3 4 5)
                  (s32vector-concatenate (list s5 s5)))
      (test-equiv "append-subvectors" '(2 3 2 3)
                  (s32vector-append-subvectors s5 1 3 s5 1 3))
      ) ; end s32vector/constructors

    ;; (test-group "s32vector/predicates"
    ;;   (test-assert "s32?" (s32? 5))
    ;;   (test-assert "not s32?" (not (s32? 65536)))
    ;;   (test-assert "s32vector?" (s32vector? s5))
    ;;   (test-assert "not s32vector?" (not (s32vector? #t)))
    ;;   (test-assert "empty" (s32vector-empty? (s32vector)))
    ;;   (test-assert "not empty" (not (s32vector-empty? s5)))
    ;;   (test-assert "=" (s32vector= (s32vector 1 2 3) (s32vector 1 2 3)))
    ;;   (test-assert "= multi" (s32vector= (s32vector 1 2 3)
    ;;                                    (s32vector 1 2 3)
    ;;                                    (s32vector 1 2 3)))
    ;;   (test-assert "not =" (not (s32vector= (s32vector 1 2 3) (s32vector 3 2 1))))
    ;;   (test-assert "not =2" (not (s32vector= (s32vector 1 2 3) (s32vector 1 2))))
    ;;   (test-assert "not = multi" (not (s32vector= (s32vector 1 2 3)
    ;;                                             (s32vector 1 2 3)
    ;;                                             (s32vector 3 2 1))))
    ;;   )
                                        ; end s32vector/predicates

    (test-group "s32vector/selectors"
      (test "ref" 1 (inexact->exact (s32vector-ref (s32vector 1 2 3) 0)))
      (test "length" 3 (s32vector-length (s32vector 1 2 3)))
      ) ; end s32vector/selectors

    (test-group "s32vector/iteration"
      (test-equiv "take" '(1 2) (s32vector-take s5 2))
      (test-equiv "take-right" '(4 5) (s32vector-take-right s5 2))
      (test-equiv "drop" '(3 4 5) (s32vector-drop s5 2))
      (test-equiv "drop-right" '(1 2 3) (s32vector-drop-right s5 2))
      (test "segment" (list (s32vector 1 2 3) (s32vector 4 5))
            (s32vector-segment s5 3))
      (test "fold" -6 (inexact->exact (s32vector-fold - 0 (s32vector 1 2 3))))
      ;; (test "fold" '(((0 1 4) 2 5) 3 6)
      ;;       (s32vector-fold list 0 (s32vector 1 2 3) (s32vector 4 5 6)))
      (test "fold-right" -6 (inexact->exact (s32vector-fold-right - 0 (s32vector 1 2 3))))
      ;; (test "fold-right" '(((0 3 6) 2 5) 1 4)
      ;;       (s32vector-fold-right list 0 (s32vector 1 2 3) (s32vector 4 5 6)))
      (test-equiv "map" '(1 4 9 16 25) (s32vector-map (cut expt <> 2) s5))
      (test-equiv "map" '(0 0 0 0 0) (s32vector-map - s5 s5))
      (let ((v (s32vector 1 2 3 4 5)))
        (s32vector-map! (cut expt <> 2) v)
        (test-equiv "map!" '(1 4 9 16 25) v))
      (let ((v (s32vector 1 2 3 4 5))
            (v2 (s32vector 6 7 8 9 10)))
        (s32vector-map! + v v2)
        (test-equiv "map!" '(7 9 11 13 15) v))
      (let ((list '()))
        (s32vector-for-each
         (lambda (e) (set! list (cons e list)))
         s5)
        ;; stupid hack to shut up test egg about testing the value of a variable
        (test "for-each" '(5 4 3 2 1) (map inexact->exact (cons (car list) (cdr list)))))
      ;; (let ((list '()))
      ;;   (s32vector-for-each
      ;;    (lambda (e1 e2) (set! list (cons (cons e1 e2) list)))
      ;;    s5
      ;;    (s32vector 6 7 8 9 10))
      ;;   ;; stupid hack to shut up test egg about testing the value of a variable
      ;;   (test "for-each" '((5 . 10) (4 . 9) (3 . 8) (2 . 7) (1 . 6))
      ;;         (cons (car list) (cdr list))))
      (test "count" 3 (s32vector-count odd? s5))
      (test "count" 2 (s32vector-count > s5 (s32vector 9 2 1 5 3)))
      (test-equiv "cumulate" '(1 3 6 10 15)
                  (s32vector-cumulate + 0 s5))
      ) ; end s32vector/iteration

    (test-group "s32vector/searching"
      (test-equiv "take-while" '(1) (s32vector-take-while odd? s5))
      (test-equiv "take-while-right" '(5) (s32vector-take-while-right odd? s5))
      (test-equiv "drop-while" '(2 3 4 5) (s32vector-drop-while odd? s5))
      (test-equiv "drop-while-right" '(1 2 3 4) (s32vector-drop-while-right odd? s5))
      ;; (test-equiv "degenerate take-while" '() (s32vector-take-while inexact? s5))
      ;; (test-equiv "degenerate take-while-right" '() (s32vector-take-while-right inexact? s5))
      ;; (test-equiv "degenerate drop-while" '(1 2 3 4 5) (s32vector-drop-while inexact? s5))
      ;; (test-equiv "degenerate drop-while-right" '(1 2 3 4 5) (s32vector-drop-while-right inexact? s5))
      (test "index" 1 (s32vector-index even? s5))
      (test "index" 2 (s32vector-index < s5 (s32vector 0 0 10 10 0)))
      (test "index-right" 3 (s32vector-index-right even? s5))
      (test "index-right" 3 (s32vector-index-right < s5 (s32vector 0 0 10 10 0)))
      (test "skip" 1 (s32vector-skip odd? s5))
      (test "skip" 2 (s32vector-skip > s5 (s32vector 0 0 10 10 0)))
      (test "skip-right" 3 (s32vector-skip-right odd? s5))
      (test "skip-right" 3 (s32vector-skip-right > s5 (s32vector 0 0 10 10 0)))
      (test "any" 4 (inexact->exact (s32vector-any (lambda (x) (and (even? x) (* x 2))) s5)))
      (test-assert "not any" (not (s32vector-any list? s5)))
      (test "any + 1" 2 (inexact->exact (s32vector-any odd+1 s5)))
      (test-assert "every" (s32vector-every number? s5))
      (test-assert "not every" (not (s32vector-every odd? s5)))
      (test-assert "every + 1" (not (s32vector-every odd+1 s5)))
      (test "multi-any" 10 (inexact->exact (s32vector-any (lambda (x y) (and (even? x) (even? y) (+ x y)))
                                                        s5 (s32vector 0 1 2 6 4))))
      (test "multi-any 2" #f (s32vector-any (lambda (x y) (and (even? x) (even? y) (+ x y)))
                                          s5 (s32vector 0 1 2 5 4)))
      (test "multi-every" 10 (inexact->exact (s32vector-every (lambda (x) (and (number? x) (* x 2))) s5)))
      (test "multi-every-2" 10 (inexact->exact (s32vector-every (lambda (x y) (and (number? x) (number? y) (+ x y)))
                                                              s5 s5)))
      (test-assert "multi-not every" (not (s32vector-every < s5 (s32vector 10 10 10 10 0))))
      (test-equiv "partition" '(1 3 5 2 4) (s32vector-partition odd? s5))
      (test-equiv "filter" '(1 3 5) (s32vector-filter odd? s5))
      (test-equiv "remove" '(2 4) (s32vector-remove odd? s5))
      ) ; end s32vector/searching

    (test-group "s32vector/mutators"
      (let ((v (s32vector 1 2 3)))
        ;; (display "set!\n")
        (s32vector-set! v 0 10)
        (test-equiv "set!" '(10 2 3) v))
      (let ((v (s32vector 1 2 3)))
        ;; (display "swap!\n")
        (s32vector-swap! v 0 1)
        (test-equiv "swap!" '(2 1 3) v))
      (let ((v (s32vector 1 2 3)))
        ;; (display "fill!\n")
        (s32vector-fill! v 2)
        (test-equiv "fill!" '(2 2 2) v))
      (let ((v (s32vector 1 2 3)))
        ;; (display "fill2!\n")
        (s32vector-fill! v 10 0 2)
        (test-equiv "fill2!" '(10 10 3) v))
      (let ((v (s32vector 1 2 3)))
        ;; (display "reverse!\n")
        (s32vector-reverse! v)
        (test-equiv "reverse!" '(3 2 1) v))
      (let ((v (s32vector 1 2 3)))
        ;; (display "reverse!\n")
        (s32vector-reverse! v 1 3)
        (test-equiv "reverse2!" '(1 3 2) v))
      (let ((v (s32vector 10 20 30 40 50)))
        ;; (display "copy!\n")
        (s32vector-copy! v 1 s5 2 4)
        (test-equiv "copy!" '(10 3 4 40 50) v))
      (let ((v (s32vector 10 20 30 40 50)))
        ;; (display "reverse-copy!\n")
        (s32vector-reverse-copy! v 1 s5 2 4)
        (test-equiv "reverse-copy!" '(10 4 3 40 50) v))
      (let ((v (s32vector 1 2 3 4 5 6 7 8)))
        ;; (display "unfold!")
        (s32vector-unfold! (lambda (x) (values (* x 2) (* x 2)))
                         v 1 6 1)
        (test-equiv "vector-unfold!" '(1 2 4 8 16 32 7 8) v))
      (let ((v (s32vector 1 2 3 4 5 6 7 8)))
        ;; (display "unfold-right!")
        (s32vector-unfold-right! (lambda (x) (values (* x 2) (* x 2)))
                               v 1 6 1)
        (test-equiv "vector-unfold!" '(1 32 16 8 4 2 7 8) v))
      ) ; end s32vector/mutators

    (test-group "s32vector/conversion"
      (test "s32vector->list 1" '(1 2 3 4 5)
            (map inexact->exact (s32vector->list s5)))
      (test "s32vector->list 2" '(2 3 4 5)
            (map inexact->exact (s32vector->list s5 1)))
      (test "s32vector->list 3" '(2 3 4)
            (map inexact->exact (s32vector->list s5 1 4)))
      (test "s32vector->vector 1" #(1 2 3 4 5)
            (vector-map inexact->exact (s32vector->vector s5)))
      (test "s32vector->vector 2" #(2 3 4 5)
            (vector-map inexact->exact (s32vector->vector s5 1)))
      (test "s32vector->vector 3" #(2 3 4)
            (vector-map inexact->exact (s32vector->vector s5 1 4)))
      (test-equiv "list->s32vector" '(1 2 3 4 5)
                  (list->s32vector '(1 2 3 4 5)))
      (test-equiv "reverse-list->s32vector" '(5 4 3 2 1)
                  (reverse-list->s32vector '(1 2 3 4 5)))
      (test-equiv "vector->s32vector 1" '(1 2 3 4 5)
                  (vector->s32vector #(1 2 3 4 5)))
      (test-equiv "vector->s32vector 2" '(2 3 4 5)
                  (vector->s32vector #(1 2 3 4 5) 1))
      (test-equiv "vector->s32vector 3" '(2 3 4)
                  (vector->s32vector #(1 2 3 4 5) 1 4))
      ) ; end s32vector/conversion

    (test-group "s32vector/misc"
      ;; (let ((port (open-output-string)))
      ;;   (write-s32vector s5 port)
      ;;   (test "write-s32vector" "#s32(1 2 3 4 5)" (get-output-string port))
      ;;   (close-output-port port))

      (test-assert "s32vector< short" (s32vector< s4 s5))
      (test-assert "not s32vector< short" (not (s32vector< s5 s4)))
      (test-assert "s32vector< samelen" (s32vector< s5 s5+))
      (test-assert "not s32vector< samelen" (not (s32vector< s5+ s5+)))
      (test-assert "s32vector=" (s32vector= s5+ s5+))
      (test "s32vector-hash" 15 (s32vector-hash s5))

      (test "s32vector-gen 0" 1 (inexact->exact (g)))
      (test "s32vector-gen 1" 2 (inexact->exact (g)))
      (test "s32vector-gen 2" 3 (inexact->exact (g)))
      (test "s32vector-gen 3" 4 (inexact->exact (g)))
      (test "s32vector-gen 4" 5 (inexact->exact (g)))
      (test-assert (eof-object? (g)))
      ) ; end s32vector/misc

    ) ; end s32vector

  )
(import (srfi 160 u64))

(test-group "u64vector tests"
  (define (times2 x) (* x 2))
  (define s5 (u64vector 1 2 3 4 5))
  (define s4 (u64vector 1 2 3 4))
  (define s5+ (u64vector 1 2 3 4 6))

  (define (steady i x) (values x x))
  (define (count-up i x) (values x (+ x 1)))
  (define (count-down i x) (values x (- x 1)))
  (define (odd+1 x) (if (odd? x) (+ 1 x) #f))
  (define u64vector< (comparator-ordering-predicate u64vector-comparator))
  (define u64vector-hash (comparator-hash-function u64vector-comparator))

  (define g (make-u64vector-generator s5))
  (define-syntax test-equiv
    (syntax-rules ()
      ((test-equiv expect expr)
       (test expect (map inexact->exact (u64vector->list expr))))
      ((test-equiv name expect expr)
       (test name expect (map inexact->exact (u64vector->list expr))))))

  (test-group "u64vector"
    (test-group "u64vector/constructors"
      (test-equiv "make" '(3 3 3 3 3) (make-u64vector 5 3))
      (test-equiv "u64vector" '(2 1 0 1 2) (u64vector 2 1 0 1 2))
      (test-equiv "unfold up" '(10 11 12 13 14)
                  (u64vector-unfold count-up 5 10))
      (test-equiv "unfold down" '(10 9 8 7 6)
                  (u64vector-unfold count-down 5 10))
      (test-equiv "unfold steady" '(10 10 10 10 10)
                  (u64vector-unfold steady 5 10))
      (test-equiv "unfold-right up" '(14 13 12 11 10)
                  (u64vector-unfold-right count-up 5 10))
      (test-equiv "unfold-right down" '(6 7 8 9 10)
                  (u64vector-unfold-right count-down 5 10))
      (test-equiv "unfold-right steady" '(10 10 10 10 10)
                  (u64vector-unfold-right steady 5 10))
      (test-equiv "copy" '(1 2 3 4 5) (u64vector-copy s5))
      (test-assert "copy2" (not (eqv? s5 (u64vector-copy s5))))
      (test-equiv "copy3" '(2 3) (u64vector-copy s5 1 3))
      (test-equiv "reverse-copy" '(5 4 3 2 1) (u64vector-reverse-copy s5))
      (test-equiv "append" '(1 2 3 4 5 1 2 3 4 5)
                  (u64vector-append s5 s5))
      (test-equiv "concatenate" '(1 2 3 4 5 1 2 3 4 5)
                  (u64vector-concatenate (list s5 s5)))
      (test-equiv "append-subvectors" '(2 3 2 3)
                  (u64vector-append-subvectors s5 1 3 s5 1 3))
      ) ; end u64vector/constructors

    ;; (test-group "u64vector/predicates"
    ;;   (test-assert "u64?" (u64? 5))
    ;;   (test-assert "not u64?" (not (u64? 65536)))
    ;;   (test-assert "u64vector?" (u64vector? s5))
    ;;   (test-assert "not u64vector?" (not (u64vector? #t)))
    ;;   (test-assert "empty" (u64vector-empty? (u64vector)))
    ;;   (test-assert "not empty" (not (u64vector-empty? s5)))
    ;;   (test-assert "=" (u64vector= (u64vector 1 2 3) (u64vector 1 2 3)))
    ;;   (test-assert "= multi" (u64vector= (u64vector 1 2 3)
    ;;                                    (u64vector 1 2 3)
    ;;                                    (u64vector 1 2 3)))
    ;;   (test-assert "not =" (not (u64vector= (u64vector 1 2 3) (u64vector 3 2 1))))
    ;;   (test-assert "not =2" (not (u64vector= (u64vector 1 2 3) (u64vector 1 2))))
    ;;   (test-assert "not = multi" (not (u64vector= (u64vector 1 2 3)
    ;;                                             (u64vector 1 2 3)
    ;;                                             (u64vector 3 2 1))))
    ;;   )
                                        ; end u64vector/predicates

    (test-group "u64vector/selectors"
      (test "ref" 1 (inexact->exact (u64vector-ref (u64vector 1 2 3) 0)))
      (test "length" 3 (u64vector-length (u64vector 1 2 3)))
      ) ; end u64vector/selectors

    (test-group "u64vector/iteration"
      (test-equiv "take" '(1 2) (u64vector-take s5 2))
      (test-equiv "take-right" '(4 5) (u64vector-take-right s5 2))
      (test-equiv "drop" '(3 4 5) (u64vector-drop s5 2))
      (test-equiv "drop-right" '(1 2 3) (u64vector-drop-right s5 2))
      (test "segment" (list (u64vector 1 2 3) (u64vector 4 5))
            (u64vector-segment s5 3))
      (test "fold" -6 (inexact->exact (u64vector-fold - 0 (u64vector 1 2 3))))
      ;; (test "fold" '(((0 1 4) 2 5) 3 6)
      ;;       (u64vector-fold list 0 (u64vector 1 2 3) (u64vector 4 5 6)))
      (test "fold-right" -6 (inexact->exact (u64vector-fold-right - 0 (u64vector 1 2 3))))
      ;; (test "fold-right" '(((0 3 6) 2 5) 1 4)
      ;;       (u64vector-fold-right list 0 (u64vector 1 2 3) (u64vector 4 5 6)))
      (test-equiv "map" '(1 4 9 16 25) (u64vector-map (cut expt <> 2) s5))
      (test-equiv "map" '(0 0 0 0 0) (u64vector-map - s5 s5))
      (let ((v (u64vector 1 2 3 4 5)))
        (u64vector-map! (cut expt <> 2) v)
        (test-equiv "map!" '(1 4 9 16 25) v))
      (let ((v (u64vector 1 2 3 4 5))
            (v2 (u64vector 6 7 8 9 10)))
        (u64vector-map! + v v2)
        (test-equiv "map!" '(7 9 11 13 15) v))
      (let ((list '()))
        (u64vector-for-each
         (lambda (e) (set! list (cons e list)))
         s5)
        ;; stupid hack to shut up test egg about testing the value of a variable
        (test "for-each" '(5 4 3 2 1) (map inexact->exact (cons (car list) (cdr list)))))
      ;; (let ((list '()))
      ;;   (u64vector-for-each
      ;;    (lambda (e1 e2) (set! list (cons (cons e1 e2) list)))
      ;;    s5
      ;;    (u64vector 6 7 8 9 10))
      ;;   ;; stupid hack to shut up test egg about testing the value of a variable
      ;;   (test "for-each" '((5 . 10) (4 . 9) (3 . 8) (2 . 7) (1 . 6))
      ;;         (cons (car list) (cdr list))))
      (test "count" 3 (u64vector-count odd? s5))
      (test "count" 2 (u64vector-count > s5 (u64vector 9 2 1 5 3)))
      (test-equiv "cumulate" '(1 3 6 10 15)
                  (u64vector-cumulate + 0 s5))
      ) ; end u64vector/iteration

    (test-group "u64vector/searching"
      (test-equiv "take-while" '(1) (u64vector-take-while odd? s5))
      (test-equiv "take-while-right" '(5) (u64vector-take-while-right odd? s5))
      (test-equiv "drop-while" '(2 3 4 5) (u64vector-drop-while odd? s5))
      (test-equiv "drop-while-right" '(1 2 3 4) (u64vector-drop-while-right odd? s5))
      ;; (test-equiv "degenerate take-while" '() (u64vector-take-while inexact? s5))
      ;; (test-equiv "degenerate take-while-right" '() (u64vector-take-while-right inexact? s5))
      ;; (test-equiv "degenerate drop-while" '(1 2 3 4 5) (u64vector-drop-while inexact? s5))
      ;; (test-equiv "degenerate drop-while-right" '(1 2 3 4 5) (u64vector-drop-while-right inexact? s5))
      (test "index" 1 (u64vector-index even? s5))
      (test "index" 2 (u64vector-index < s5 (u64vector 0 0 10 10 0)))
      (test "index-right" 3 (u64vector-index-right even? s5))
      (test "index-right" 3 (u64vector-index-right < s5 (u64vector 0 0 10 10 0)))
      (test "skip" 1 (u64vector-skip odd? s5))
      (test "skip" 2 (u64vector-skip > s5 (u64vector 0 0 10 10 0)))
      (test "skip-right" 3 (u64vector-skip-right odd? s5))
      (test "skip-right" 3 (u64vector-skip-right > s5 (u64vector 0 0 10 10 0)))
      (test "any" 4 (inexact->exact (u64vector-any (lambda (x) (and (even? x) (* x 2))) s5)))
      (test-assert "not any" (not (u64vector-any list? s5)))
      (test "any + 1" 2 (inexact->exact (u64vector-any odd+1 s5)))
      (test-assert "every" (u64vector-every number? s5))
      (test-assert "not every" (not (u64vector-every odd? s5)))
      (test-assert "every + 1" (not (u64vector-every odd+1 s5)))
      (test "multi-any" 10 (inexact->exact (u64vector-any (lambda (x y) (and (even? x) (even? y) (+ x y)))
                                                        s5 (u64vector 0 1 2 6 4))))
      (test "multi-any 2" #f (u64vector-any (lambda (x y) (and (even? x) (even? y) (+ x y)))
                                          s5 (u64vector 0 1 2 5 4)))
      (test "multi-every" 10 (inexact->exact (u64vector-every (lambda (x) (and (number? x) (* x 2))) s5)))
      (test "multi-every-2" 10 (inexact->exact (u64vector-every (lambda (x y) (and (number? x) (number? y) (+ x y)))
                                                              s5 s5)))
      (test-assert "multi-not every" (not (u64vector-every < s5 (u64vector 10 10 10 10 0))))
      (test-equiv "partition" '(1 3 5 2 4) (u64vector-partition odd? s5))
      (test-equiv "filter" '(1 3 5) (u64vector-filter odd? s5))
      (test-equiv "remove" '(2 4) (u64vector-remove odd? s5))
      ) ; end u64vector/searching

    (test-group "u64vector/mutators"
      (let ((v (u64vector 1 2 3)))
        ;; (display "set!\n")
        (u64vector-set! v 0 10)
        (test-equiv "set!" '(10 2 3) v))
      (let ((v (u64vector 1 2 3)))
        ;; (display "swap!\n")
        (u64vector-swap! v 0 1)
        (test-equiv "swap!" '(2 1 3) v))
      (let ((v (u64vector 1 2 3)))
        ;; (display "fill!\n")
        (u64vector-fill! v 2)
        (test-equiv "fill!" '(2 2 2) v))
      (let ((v (u64vector 1 2 3)))
        ;; (display "fill2!\n")
        (u64vector-fill! v 10 0 2)
        (test-equiv "fill2!" '(10 10 3) v))
      (let ((v (u64vector 1 2 3)))
        ;; (display "reverse!\n")
        (u64vector-reverse! v)
        (test-equiv "reverse!" '(3 2 1) v))
      (let ((v (u64vector 1 2 3)))
        ;; (display "reverse!\n")
        (u64vector-reverse! v 1 3)
        (test-equiv "reverse2!" '(1 3 2) v))
      (let ((v (u64vector 10 20 30 40 50)))
        ;; (display "copy!\n")
        (u64vector-copy! v 1 s5 2 4)
        (test-equiv "copy!" '(10 3 4 40 50) v))
      (let ((v (u64vector 10 20 30 40 50)))
        ;; (display "reverse-copy!\n")
        (u64vector-reverse-copy! v 1 s5 2 4)
        (test-equiv "reverse-copy!" '(10 4 3 40 50) v))
      (let ((v (u64vector 1 2 3 4 5 6 7 8)))
        ;; (display "unfold!")
        (u64vector-unfold! (lambda (x) (values (* x 2) (* x 2)))
                         v 1 6 1)
        (test-equiv "vector-unfold!" '(1 2 4 8 16 32 7 8) v))
      (let ((v (u64vector 1 2 3 4 5 6 7 8)))
        ;; (display "unfold-right!")
        (u64vector-unfold-right! (lambda (x) (values (* x 2) (* x 2)))
                               v 1 6 1)
        (test-equiv "vector-unfold!" '(1 32 16 8 4 2 7 8) v))
      ) ; end u64vector/mutators

    (test-group "u64vector/conversion"
      (test "u64vector->list 1" '(1 2 3 4 5)
            (map inexact->exact (u64vector->list s5)))
      (test "u64vector->list 2" '(2 3 4 5)
            (map inexact->exact (u64vector->list s5 1)))
      (test "u64vector->list 3" '(2 3 4)
            (map inexact->exact (u64vector->list s5 1 4)))
      (test "u64vector->vector 1" #(1 2 3 4 5)
            (vector-map inexact->exact (u64vector->vector s5)))
      (test "u64vector->vector 2" #(2 3 4 5)
            (vector-map inexact->exact (u64vector->vector s5 1)))
      (test "u64vector->vector 3" #(2 3 4)
            (vector-map inexact->exact (u64vector->vector s5 1 4)))
      (test-equiv "list->u64vector" '(1 2 3 4 5)
                  (list->u64vector '(1 2 3 4 5)))
      (test-equiv "reverse-list->u64vector" '(5 4 3 2 1)
                  (reverse-list->u64vector '(1 2 3 4 5)))
      (test-equiv "vector->u64vector 1" '(1 2 3 4 5)
                  (vector->u64vector #(1 2 3 4 5)))
      (test-equiv "vector->u64vector 2" '(2 3 4 5)
                  (vector->u64vector #(1 2 3 4 5) 1))
      (test-equiv "vector->u64vector 3" '(2 3 4)
                  (vector->u64vector #(1 2 3 4 5) 1 4))
      ) ; end u64vector/conversion

    (test-group "u64vector/misc"
      ;; (let ((port (open-output-string)))
      ;;   (write-u64vector s5 port)
      ;;   (test "write-u64vector" "#u64(1 2 3 4 5)" (get-output-string port))
      ;;   (close-output-port port))

      (test-assert "u64vector< short" (u64vector< s4 s5))
      (test-assert "not u64vector< short" (not (u64vector< s5 s4)))
      (test-assert "u64vector< samelen" (u64vector< s5 s5+))
      (test-assert "not u64vector< samelen" (not (u64vector< s5+ s5+)))
      (test-assert "u64vector=" (u64vector= s5+ s5+))
      (test "u64vector-hash" 15 (u64vector-hash s5))

      (test "u64vector-gen 0" 1 (inexact->exact (g)))
      (test "u64vector-gen 1" 2 (inexact->exact (g)))
      (test "u64vector-gen 2" 3 (inexact->exact (g)))
      (test "u64vector-gen 3" 4 (inexact->exact (g)))
      (test "u64vector-gen 4" 5 (inexact->exact (g)))
      (test-assert (eof-object? (g)))
      ) ; end u64vector/misc

    ) ; end u64vector

  )
(import (srfi 160 s64))

(test-group "s64vector tests"
  (define (times2 x) (* x 2))
  (define s5 (s64vector 1 2 3 4 5))
  (define s4 (s64vector 1 2 3 4))
  (define s5+ (s64vector 1 2 3 4 6))

  (define (steady i x) (values x x))
  (define (count-up i x) (values x (+ x 1)))
  (define (count-down i x) (values x (- x 1)))
  (define (odd+1 x) (if (odd? x) (+ 1 x) #f))
  (define s64vector< (comparator-ordering-predicate s64vector-comparator))
  (define s64vector-hash (comparator-hash-function s64vector-comparator))

  (define g (make-s64vector-generator s5))
  (define-syntax test-equiv
    (syntax-rules ()
      ((test-equiv expect expr)
       (test expect (map inexact->exact (s64vector->list expr))))
      ((test-equiv name expect expr)
       (test name expect (map inexact->exact (s64vector->list expr))))))

  (test-group "s64vector"
    (test-group "s64vector/constructors"
      (test-equiv "make" '(3 3 3 3 3) (make-s64vector 5 3))
      (test-equiv "s64vector" '(2 1 0 1 2) (s64vector 2 1 0 1 2))
      (test-equiv "unfold up" '(10 11 12 13 14)
                  (s64vector-unfold count-up 5 10))
      (test-equiv "unfold down" '(10 9 8 7 6)
                  (s64vector-unfold count-down 5 10))
      (test-equiv "unfold steady" '(10 10 10 10 10)
                  (s64vector-unfold steady 5 10))
      (test-equiv "unfold-right up" '(14 13 12 11 10)
                  (s64vector-unfold-right count-up 5 10))
      (test-equiv "unfold-right down" '(6 7 8 9 10)
                  (s64vector-unfold-right count-down 5 10))
      (test-equiv "unfold-right steady" '(10 10 10 10 10)
                  (s64vector-unfold-right steady 5 10))
      (test-equiv "copy" '(1 2 3 4 5) (s64vector-copy s5))
      (test-assert "copy2" (not (eqv? s5 (s64vector-copy s5))))
      (test-equiv "copy3" '(2 3) (s64vector-copy s5 1 3))
      (test-equiv "reverse-copy" '(5 4 3 2 1) (s64vector-reverse-copy s5))
      (test-equiv "append" '(1 2 3 4 5 1 2 3 4 5)
                  (s64vector-append s5 s5))
      (test-equiv "concatenate" '(1 2 3 4 5 1 2 3 4 5)
                  (s64vector-concatenate (list s5 s5)))
      (test-equiv "append-subvectors" '(2 3 2 3)
                  (s64vector-append-subvectors s5 1 3 s5 1 3))
      ) ; end s64vector/constructors

    ;; (test-group "s64vector/predicates"
    ;;   (test-assert "s64?" (s64? 5))
    ;;   (test-assert "not s64?" (not (s64? 65536)))
    ;;   (test-assert "s64vector?" (s64vector? s5))
    ;;   (test-assert "not s64vector?" (not (s64vector? #t)))
    ;;   (test-assert "empty" (s64vector-empty? (s64vector)))
    ;;   (test-assert "not empty" (not (s64vector-empty? s5)))
    ;;   (test-assert "=" (s64vector= (s64vector 1 2 3) (s64vector 1 2 3)))
    ;;   (test-assert "= multi" (s64vector= (s64vector 1 2 3)
    ;;                                    (s64vector 1 2 3)
    ;;                                    (s64vector 1 2 3)))
    ;;   (test-assert "not =" (not (s64vector= (s64vector 1 2 3) (s64vector 3 2 1))))
    ;;   (test-assert "not =2" (not (s64vector= (s64vector 1 2 3) (s64vector 1 2))))
    ;;   (test-assert "not = multi" (not (s64vector= (s64vector 1 2 3)
    ;;                                             (s64vector 1 2 3)
    ;;                                             (s64vector 3 2 1))))
    ;;   )
                                        ; end s64vector/predicates

    (test-group "s64vector/selectors"
      (test "ref" 1 (inexact->exact (s64vector-ref (s64vector 1 2 3) 0)))
      (test "length" 3 (s64vector-length (s64vector 1 2 3)))
      ) ; end s64vector/selectors

    (test-group "s64vector/iteration"
      (test-equiv "take" '(1 2) (s64vector-take s5 2))
      (test-equiv "take-right" '(4 5) (s64vector-take-right s5 2))
      (test-equiv "drop" '(3 4 5) (s64vector-drop s5 2))
      (test-equiv "drop-right" '(1 2 3) (s64vector-drop-right s5 2))
      (test "segment" (list (s64vector 1 2 3) (s64vector 4 5))
            (s64vector-segment s5 3))
      (test "fold" -6 (inexact->exact (s64vector-fold - 0 (s64vector 1 2 3))))
      ;; (test "fold" '(((0 1 4) 2 5) 3 6)
      ;;       (s64vector-fold list 0 (s64vector 1 2 3) (s64vector 4 5 6)))
      (test "fold-right" -6 (inexact->exact (s64vector-fold-right - 0 (s64vector 1 2 3))))
      ;; (test "fold-right" '(((0 3 6) 2 5) 1 4)
      ;;       (s64vector-fold-right list 0 (s64vector 1 2 3) (s64vector 4 5 6)))
      (test-equiv "map" '(1 4 9 16 25) (s64vector-map (cut expt <> 2) s5))
      (test-equiv "map" '(0 0 0 0 0) (s64vector-map - s5 s5))
      (let ((v (s64vector 1 2 3 4 5)))
        (s64vector-map! (cut expt <> 2) v)
        (test-equiv "map!" '(1 4 9 16 25) v))
      (let ((v (s64vector 1 2 3 4 5))
            (v2 (s64vector 6 7 8 9 10)))
        (s64vector-map! + v v2)
        (test-equiv "map!" '(7 9 11 13 15) v))
      (let ((list '()))
        (s64vector-for-each
         (lambda (e) (set! list (cons e list)))
         s5)
        ;; stupid hack to shut up test egg about testing the value of a variable
        (test "for-each" '(5 4 3 2 1) (map inexact->exact (cons (car list) (cdr list)))))
      ;; (let ((list '()))
      ;;   (s64vector-for-each
      ;;    (lambda (e1 e2) (set! list (cons (cons e1 e2) list)))
      ;;    s5
      ;;    (s64vector 6 7 8 9 10))
      ;;   ;; stupid hack to shut up test egg about testing the value of a variable
      ;;   (test "for-each" '((5 . 10) (4 . 9) (3 . 8) (2 . 7) (1 . 6))
      ;;         (cons (car list) (cdr list))))
      (test "count" 3 (s64vector-count odd? s5))
      (test "count" 2 (s64vector-count > s5 (s64vector 9 2 1 5 3)))
      (test-equiv "cumulate" '(1 3 6 10 15)
                  (s64vector-cumulate + 0 s5))
      ) ; end s64vector/iteration

    (test-group "s64vector/searching"
      (test-equiv "take-while" '(1) (s64vector-take-while odd? s5))
      (test-equiv "take-while-right" '(5) (s64vector-take-while-right odd? s5))
      (test-equiv "drop-while" '(2 3 4 5) (s64vector-drop-while odd? s5))
      (test-equiv "drop-while-right" '(1 2 3 4) (s64vector-drop-while-right odd? s5))
      ;; (test-equiv "degenerate take-while" '() (s64vector-take-while inexact? s5))
      ;; (test-equiv "degenerate take-while-right" '() (s64vector-take-while-right inexact? s5))
      ;; (test-equiv "degenerate drop-while" '(1 2 3 4 5) (s64vector-drop-while inexact? s5))
      ;; (test-equiv "degenerate drop-while-right" '(1 2 3 4 5) (s64vector-drop-while-right inexact? s5))
      (test "index" 1 (s64vector-index even? s5))
      (test "index" 2 (s64vector-index < s5 (s64vector 0 0 10 10 0)))
      (test "index-right" 3 (s64vector-index-right even? s5))
      (test "index-right" 3 (s64vector-index-right < s5 (s64vector 0 0 10 10 0)))
      (test "skip" 1 (s64vector-skip odd? s5))
      (test "skip" 2 (s64vector-skip > s5 (s64vector 0 0 10 10 0)))
      (test "skip-right" 3 (s64vector-skip-right odd? s5))
      (test "skip-right" 3 (s64vector-skip-right > s5 (s64vector 0 0 10 10 0)))
      (test "any" 4 (inexact->exact (s64vector-any (lambda (x) (and (even? x) (* x 2))) s5)))
      (test-assert "not any" (not (s64vector-any list? s5)))
      (test "any + 1" 2 (inexact->exact (s64vector-any odd+1 s5)))
      (test-assert "every" (s64vector-every number? s5))
      (test-assert "not every" (not (s64vector-every odd? s5)))
      (test-assert "every + 1" (not (s64vector-every odd+1 s5)))
      (test "multi-any" 10 (inexact->exact (s64vector-any (lambda (x y) (and (even? x) (even? y) (+ x y)))
                                                        s5 (s64vector 0 1 2 6 4))))
      (test "multi-any 2" #f (s64vector-any (lambda (x y) (and (even? x) (even? y) (+ x y)))
                                          s5 (s64vector 0 1 2 5 4)))
      (test "multi-every" 10 (inexact->exact (s64vector-every (lambda (x) (and (number? x) (* x 2))) s5)))
      (test "multi-every-2" 10 (inexact->exact (s64vector-every (lambda (x y) (and (number? x) (number? y) (+ x y)))
                                                              s5 s5)))
      (test-assert "multi-not every" (not (s64vector-every < s5 (s64vector 10 10 10 10 0))))
      (test-equiv "partition" '(1 3 5 2 4) (s64vector-partition odd? s5))
      (test-equiv "filter" '(1 3 5) (s64vector-filter odd? s5))
      (test-equiv "remove" '(2 4) (s64vector-remove odd? s5))
      ) ; end s64vector/searching

    (test-group "s64vector/mutators"
      (let ((v (s64vector 1 2 3)))
        ;; (display "set!\n")
        (s64vector-set! v 0 10)
        (test-equiv "set!" '(10 2 3) v))
      (let ((v (s64vector 1 2 3)))
        ;; (display "swap!\n")
        (s64vector-swap! v 0 1)
        (test-equiv "swap!" '(2 1 3) v))
      (let ((v (s64vector 1 2 3)))
        ;; (display "fill!\n")
        (s64vector-fill! v 2)
        (test-equiv "fill!" '(2 2 2) v))
      (let ((v (s64vector 1 2 3)))
        ;; (display "fill2!\n")
        (s64vector-fill! v 10 0 2)
        (test-equiv "fill2!" '(10 10 3) v))
      (let ((v (s64vector 1 2 3)))
        ;; (display "reverse!\n")
        (s64vector-reverse! v)
        (test-equiv "reverse!" '(3 2 1) v))
      (let ((v (s64vector 1 2 3)))
        ;; (display "reverse!\n")
        (s64vector-reverse! v 1 3)
        (test-equiv "reverse2!" '(1 3 2) v))
      (let ((v (s64vector 10 20 30 40 50)))
        ;; (display "copy!\n")
        (s64vector-copy! v 1 s5 2 4)
        (test-equiv "copy!" '(10 3 4 40 50) v))
      (let ((v (s64vector 10 20 30 40 50)))
        ;; (display "reverse-copy!\n")
        (s64vector-reverse-copy! v 1 s5 2 4)
        (test-equiv "reverse-copy!" '(10 4 3 40 50) v))
      (let ((v (s64vector 1 2 3 4 5 6 7 8)))
        ;; (display "unfold!")
        (s64vector-unfold! (lambda (x) (values (* x 2) (* x 2)))
                         v 1 6 1)
        (test-equiv "vector-unfold!" '(1 2 4 8 16 32 7 8) v))
      (let ((v (s64vector 1 2 3 4 5 6 7 8)))
        ;; (display "unfold-right!")
        (s64vector-unfold-right! (lambda (x) (values (* x 2) (* x 2)))
                               v 1 6 1)
        (test-equiv "vector-unfold!" '(1 32 16 8 4 2 7 8) v))
      ) ; end s64vector/mutators

    (test-group "s64vector/conversion"
      (test "s64vector->list 1" '(1 2 3 4 5)
            (map inexact->exact (s64vector->list s5)))
      (test "s64vector->list 2" '(2 3 4 5)
            (map inexact->exact (s64vector->list s5 1)))
      (test "s64vector->list 3" '(2 3 4)
            (map inexact->exact (s64vector->list s5 1 4)))
      (test "s64vector->vector 1" #(1 2 3 4 5)
            (vector-map inexact->exact (s64vector->vector s5)))
      (test "s64vector->vector 2" #(2 3 4 5)
            (vector-map inexact->exact (s64vector->vector s5 1)))
      (test "s64vector->vector 3" #(2 3 4)
            (vector-map inexact->exact (s64vector->vector s5 1 4)))
      (test-equiv "list->s64vector" '(1 2 3 4 5)
                  (list->s64vector '(1 2 3 4 5)))
      (test-equiv "reverse-list->s64vector" '(5 4 3 2 1)
                  (reverse-list->s64vector '(1 2 3 4 5)))
      (test-equiv "vector->s64vector 1" '(1 2 3 4 5)
                  (vector->s64vector #(1 2 3 4 5)))
      (test-equiv "vector->s64vector 2" '(2 3 4 5)
                  (vector->s64vector #(1 2 3 4 5) 1))
      (test-equiv "vector->s64vector 3" '(2 3 4)
                  (vector->s64vector #(1 2 3 4 5) 1 4))
      ) ; end s64vector/conversion

    (test-group "s64vector/misc"
      ;; (let ((port (open-output-string)))
      ;;   (write-s64vector s5 port)
      ;;   (test "write-s64vector" "#s64(1 2 3 4 5)" (get-output-string port))
      ;;   (close-output-port port))

      (test-assert "s64vector< short" (s64vector< s4 s5))
      (test-assert "not s64vector< short" (not (s64vector< s5 s4)))
      (test-assert "s64vector< samelen" (s64vector< s5 s5+))
      (test-assert "not s64vector< samelen" (not (s64vector< s5+ s5+)))
      (test-assert "s64vector=" (s64vector= s5+ s5+))
      (test "s64vector-hash" 15 (s64vector-hash s5))

      (test "s64vector-gen 0" 1 (inexact->exact (g)))
      (test "s64vector-gen 1" 2 (inexact->exact (g)))
      (test "s64vector-gen 2" 3 (inexact->exact (g)))
      (test "s64vector-gen 3" 4 (inexact->exact (g)))
      (test "s64vector-gen 4" 5 (inexact->exact (g)))
      (test-assert (eof-object? (g)))
      ) ; end s64vector/misc

    ) ; end s64vector

  )
(import (srfi 160 f32))

(test-group "f32vector tests"
  (define (times2 x) (* x 2))
  (define s5 (f32vector 1 2 3 4 5))
  (define s4 (f32vector 1 2 3 4))
  (define s5+ (f32vector 1 2 3 4 6))

  (define (steady i x) (values x x))
  (define (count-up i x) (values x (+ x 1)))
  (define (count-down i x) (values x (- x 1)))
  (define (odd+1 x) (if (odd? x) (+ 1 x) #f))
  (define f32vector< (comparator-ordering-predicate f32vector-comparator))
  (define f32vector-hash (comparator-hash-function f32vector-comparator))

  (define g (make-f32vector-generator s5))
  (define-syntax test-equiv
    (syntax-rules ()
      ((test-equiv expect expr)
       (test expect (map inexact->exact (f32vector->list expr))))
      ((test-equiv name expect expr)
       (test name expect (map inexact->exact (f32vector->list expr))))))

  (test-group "f32vector"
    (test-group "f32vector/constructors"
      (test-equiv "make" '(3 3 3 3 3) (make-f32vector 5 3))
      (test-equiv "f32vector" '(2 1 0 1 2) (f32vector 2 1 0 1 2))
      (test-equiv "unfold up" '(10 11 12 13 14)
                  (f32vector-unfold count-up 5 10))
      (test-equiv "unfold down" '(10 9 8 7 6)
                  (f32vector-unfold count-down 5 10))
      (test-equiv "unfold steady" '(10 10 10 10 10)
                  (f32vector-unfold steady 5 10))
      (test-equiv "unfold-right up" '(14 13 12 11 10)
                  (f32vector-unfold-right count-up 5 10))
      (test-equiv "unfold-right down" '(6 7 8 9 10)
                  (f32vector-unfold-right count-down 5 10))
      (test-equiv "unfold-right steady" '(10 10 10 10 10)
                  (f32vector-unfold-right steady 5 10))
      (test-equiv "copy" '(1 2 3 4 5) (f32vector-copy s5))
      (test-assert "copy2" (not (eqv? s5 (f32vector-copy s5))))
      (test-equiv "copy3" '(2 3) (f32vector-copy s5 1 3))
      (test-equiv "reverse-copy" '(5 4 3 2 1) (f32vector-reverse-copy s5))
      (test-equiv "append" '(1 2 3 4 5 1 2 3 4 5)
                  (f32vector-append s5 s5))
      (test-equiv "concatenate" '(1 2 3 4 5 1 2 3 4 5)
                  (f32vector-concatenate (list s5 s5)))
      (test-equiv "append-subvectors" '(2 3 2 3)
                  (f32vector-append-subvectors s5 1 3 s5 1 3))
      ) ; end f32vector/constructors

    ;; (test-group "f32vector/predicates"
    ;;   (test-assert "f32?" (f32? 5))
    ;;   (test-assert "not f32?" (not (f32? 65536)))
    ;;   (test-assert "f32vector?" (f32vector? s5))
    ;;   (test-assert "not f32vector?" (not (f32vector? #t)))
    ;;   (test-assert "empty" (f32vector-empty? (f32vector)))
    ;;   (test-assert "not empty" (not (f32vector-empty? s5)))
    ;;   (test-assert "=" (f32vector= (f32vector 1 2 3) (f32vector 1 2 3)))
    ;;   (test-assert "= multi" (f32vector= (f32vector 1 2 3)
    ;;                                    (f32vector 1 2 3)
    ;;                                    (f32vector 1 2 3)))
    ;;   (test-assert "not =" (not (f32vector= (f32vector 1 2 3) (f32vector 3 2 1))))
    ;;   (test-assert "not =2" (not (f32vector= (f32vector 1 2 3) (f32vector 1 2))))
    ;;   (test-assert "not = multi" (not (f32vector= (f32vector 1 2 3)
    ;;                                             (f32vector 1 2 3)
    ;;                                             (f32vector 3 2 1))))
    ;;   )
                                        ; end f32vector/predicates

    (test-group "f32vector/selectors"
      (test "ref" 1 (inexact->exact (f32vector-ref (f32vector 1 2 3) 0)))
      (test "length" 3 (f32vector-length (f32vector 1 2 3)))
      ) ; end f32vector/selectors

    (test-group "f32vector/iteration"
      (test-equiv "take" '(1 2) (f32vector-take s5 2))
      (test-equiv "take-right" '(4 5) (f32vector-take-right s5 2))
      (test-equiv "drop" '(3 4 5) (f32vector-drop s5 2))
      (test-equiv "drop-right" '(1 2 3) (f32vector-drop-right s5 2))
      (test "segment" (list (f32vector 1 2 3) (f32vector 4 5))
            (f32vector-segment s5 3))
      (test "fold" -6 (inexact->exact (f32vector-fold - 0 (f32vector 1 2 3))))
      ;; (test "fold" '(((0 1 4) 2 5) 3 6)
      ;;       (f32vector-fold list 0 (f32vector 1 2 3) (f32vector 4 5 6)))
      (test "fold-right" -6 (inexact->exact (f32vector-fold-right - 0 (f32vector 1 2 3))))
      ;; (test "fold-right" '(((0 3 6) 2 5) 1 4)
      ;;       (f32vector-fold-right list 0 (f32vector 1 2 3) (f32vector 4 5 6)))
      (test-equiv "map" '(1 4 9 16 25) (f32vector-map (cut expt <> 2) s5))
      (test-equiv "map" '(0 0 0 0 0) (f32vector-map - s5 s5))
      (let ((v (f32vector 1 2 3 4 5)))
        (f32vector-map! (cut expt <> 2) v)
        (test-equiv "map!" '(1 4 9 16 25) v))
      (let ((v (f32vector 1 2 3 4 5))
            (v2 (f32vector 6 7 8 9 10)))
        (f32vector-map! + v v2)
        (test-equiv "map!" '(7 9 11 13 15) v))
      (let ((list '()))
        (f32vector-for-each
         (lambda (e) (set! list (cons e list)))
         s5)
        ;; stupid hack to shut up test egg about testing the value of a variable
        (test "for-each" '(5 4 3 2 1) (map inexact->exact (cons (car list) (cdr list)))))
      ;; (let ((list '()))
      ;;   (f32vector-for-each
      ;;    (lambda (e1 e2) (set! list (cons (cons e1 e2) list)))
      ;;    s5
      ;;    (f32vector 6 7 8 9 10))
      ;;   ;; stupid hack to shut up test egg about testing the value of a variable
      ;;   (test "for-each" '((5 . 10) (4 . 9) (3 . 8) (2 . 7) (1 . 6))
      ;;         (cons (car list) (cdr list))))
      (test "count" 3 (f32vector-count odd? s5))
      (test "count" 2 (f32vector-count > s5 (f32vector 9 2 1 5 3)))
      (test-equiv "cumulate" '(1 3 6 10 15)
                  (f32vector-cumulate + 0 s5))
      ) ; end f32vector/iteration

    (test-group "f32vector/searching"
      (test-equiv "take-while" '(1) (f32vector-take-while odd? s5))
      (test-equiv "take-while-right" '(5) (f32vector-take-while-right odd? s5))
      (test-equiv "drop-while" '(2 3 4 5) (f32vector-drop-while odd? s5))
      (test-equiv "drop-while-right" '(1 2 3 4) (f32vector-drop-while-right odd? s5))
      ;; (test-equiv "degenerate take-while" '() (f32vector-take-while inexact? s5))
      ;; (test-equiv "degenerate take-while-right" '() (f32vector-take-while-right inexact? s5))
      ;; (test-equiv "degenerate drop-while" '(1 2 3 4 5) (f32vector-drop-while inexact? s5))
      ;; (test-equiv "degenerate drop-while-right" '(1 2 3 4 5) (f32vector-drop-while-right inexact? s5))
      (test "index" 1 (f32vector-index even? s5))
      (test "index" 2 (f32vector-index < s5 (f32vector 0 0 10 10 0)))
      (test "index-right" 3 (f32vector-index-right even? s5))
      (test "index-right" 3 (f32vector-index-right < s5 (f32vector 0 0 10 10 0)))
      (test "skip" 1 (f32vector-skip odd? s5))
      (test "skip" 2 (f32vector-skip > s5 (f32vector 0 0 10 10 0)))
      (test "skip-right" 3 (f32vector-skip-right odd? s5))
      (test "skip-right" 3 (f32vector-skip-right > s5 (f32vector 0 0 10 10 0)))
      (test "any" 4 (inexact->exact (f32vector-any (lambda (x) (and (even? x) (* x 2))) s5)))
      (test-assert "not any" (not (f32vector-any list? s5)))
      (test "any + 1" 2 (inexact->exact (f32vector-any odd+1 s5)))
      (test-assert "every" (f32vector-every number? s5))
      (test-assert "not every" (not (f32vector-every odd? s5)))
      (test-assert "every + 1" (not (f32vector-every odd+1 s5)))
      (test "multi-any" 10 (inexact->exact (f32vector-any (lambda (x y) (and (even? x) (even? y) (+ x y)))
                                                        s5 (f32vector 0 1 2 6 4))))
      (test "multi-any 2" #f (f32vector-any (lambda (x y) (and (even? x) (even? y) (+ x y)))
                                          s5 (f32vector 0 1 2 5 4)))
      (test "multi-every" 10 (inexact->exact (f32vector-every (lambda (x) (and (number? x) (* x 2))) s5)))
      (test "multi-every-2" 10 (inexact->exact (f32vector-every (lambda (x y) (and (number? x) (number? y) (+ x y)))
                                                              s5 s5)))
      (test-assert "multi-not every" (not (f32vector-every < s5 (f32vector 10 10 10 10 0))))
      (test-equiv "partition" '(1 3 5 2 4) (f32vector-partition odd? s5))
      (test-equiv "filter" '(1 3 5) (f32vector-filter odd? s5))
      (test-equiv "remove" '(2 4) (f32vector-remove odd? s5))
      ) ; end f32vector/searching

    (test-group "f32vector/mutators"
      (let ((v (f32vector 1 2 3)))
        ;; (display "set!\n")
        (f32vector-set! v 0 10)
        (test-equiv "set!" '(10 2 3) v))
      (let ((v (f32vector 1 2 3)))
        ;; (display "swap!\n")
        (f32vector-swap! v 0 1)
        (test-equiv "swap!" '(2 1 3) v))
      (let ((v (f32vector 1 2 3)))
        ;; (display "fill!\n")
        (f32vector-fill! v 2)
        (test-equiv "fill!" '(2 2 2) v))
      (let ((v (f32vector 1 2 3)))
        ;; (display "fill2!\n")
        (f32vector-fill! v 10 0 2)
        (test-equiv "fill2!" '(10 10 3) v))
      (let ((v (f32vector 1 2 3)))
        ;; (display "reverse!\n")
        (f32vector-reverse! v)
        (test-equiv "reverse!" '(3 2 1) v))
      (let ((v (f32vector 1 2 3)))
        ;; (display "reverse!\n")
        (f32vector-reverse! v 1 3)
        (test-equiv "reverse2!" '(1 3 2) v))
      (let ((v (f32vector 10 20 30 40 50)))
        ;; (display "copy!\n")
        (f32vector-copy! v 1 s5 2 4)
        (test-equiv "copy!" '(10 3 4 40 50) v))
      (let ((v (f32vector 10 20 30 40 50)))
        ;; (display "reverse-copy!\n")
        (f32vector-reverse-copy! v 1 s5 2 4)
        (test-equiv "reverse-copy!" '(10 4 3 40 50) v))
      (let ((v (f32vector 1 2 3 4 5 6 7 8)))
        ;; (display "unfold!")
        (f32vector-unfold! (lambda (x) (values (* x 2) (* x 2)))
                         v 1 6 1)
        (test-equiv "vector-unfold!" '(1 2 4 8 16 32 7 8) v))
      (let ((v (f32vector 1 2 3 4 5 6 7 8)))
        ;; (display "unfold-right!")
        (f32vector-unfold-right! (lambda (x) (values (* x 2) (* x 2)))
                               v 1 6 1)
        (test-equiv "vector-unfold!" '(1 32 16 8 4 2 7 8) v))
      ) ; end f32vector/mutators

    (test-group "f32vector/conversion"
      (test "f32vector->list 1" '(1 2 3 4 5)
            (map inexact->exact (f32vector->list s5)))
      (test "f32vector->list 2" '(2 3 4 5)
            (map inexact->exact (f32vector->list s5 1)))
      (test "f32vector->list 3" '(2 3 4)
            (map inexact->exact (f32vector->list s5 1 4)))
      (test "f32vector->vector 1" #(1 2 3 4 5)
            (vector-map inexact->exact (f32vector->vector s5)))
      (test "f32vector->vector 2" #(2 3 4 5)
            (vector-map inexact->exact (f32vector->vector s5 1)))
      (test "f32vector->vector 3" #(2 3 4)
            (vector-map inexact->exact (f32vector->vector s5 1 4)))
      (test-equiv "list->f32vector" '(1 2 3 4 5)
                  (list->f32vector '(1 2 3 4 5)))
      (test-equiv "reverse-list->f32vector" '(5 4 3 2 1)
                  (reverse-list->f32vector '(1 2 3 4 5)))
      (test-equiv "vector->f32vector 1" '(1 2 3 4 5)
                  (vector->f32vector #(1 2 3 4 5)))
      (test-equiv "vector->f32vector 2" '(2 3 4 5)
                  (vector->f32vector #(1 2 3 4 5) 1))
      (test-equiv "vector->f32vector 3" '(2 3 4)
                  (vector->f32vector #(1 2 3 4 5) 1 4))
      ) ; end f32vector/conversion

    (test-group "f32vector/misc"
      ;; (let ((port (open-output-string)))
      ;;   (write-f32vector s5 port)
      ;;   (test "write-f32vector" "#f32(1 2 3 4 5)" (get-output-string port))
      ;;   (close-output-port port))

      (test-assert "f32vector< short" (f32vector< s4 s5))
      (test-assert "not f32vector< short" (not (f32vector< s5 s4)))
      (test-assert "f32vector< samelen" (f32vector< s5 s5+))
      (test-assert "not f32vector< samelen" (not (f32vector< s5+ s5+)))
      (test-assert "f32vector=" (f32vector= s5+ s5+))
      (test "f32vector-hash" 15 (f32vector-hash s5))

      (test "f32vector-gen 0" 1 (inexact->exact (g)))
      (test "f32vector-gen 1" 2 (inexact->exact (g)))
      (test "f32vector-gen 2" 3 (inexact->exact (g)))
      (test "f32vector-gen 3" 4 (inexact->exact (g)))
      (test "f32vector-gen 4" 5 (inexact->exact (g)))
      (test-assert (eof-object? (g)))
      ) ; end f32vector/misc

    ) ; end f32vector

  )
(import (srfi 160 f64))

(test-group "f64vector tests"
  (define (times2 x) (* x 2))
  (define s5 (f64vector 1 2 3 4 5))
  (define s4 (f64vector 1 2 3 4))
  (define s5+ (f64vector 1 2 3 4 6))

  (define (steady i x) (values x x))
  (define (count-up i x) (values x (+ x 1)))
  (define (count-down i x) (values x (- x 1)))
  (define (odd+1 x) (if (odd? x) (+ 1 x) #f))
  (define f64vector< (comparator-ordering-predicate f64vector-comparator))
  (define f64vector-hash (comparator-hash-function f64vector-comparator))

  (define g (make-f64vector-generator s5))
  (define-syntax test-equiv
    (syntax-rules ()
      ((test-equiv expect expr)
       (test expect (map inexact->exact (f64vector->list expr))))
      ((test-equiv name expect expr)
       (test name expect (map inexact->exact (f64vector->list expr))))))

  (test-group "f64vector"
    (test-group "f64vector/constructors"
      (test-equiv "make" '(3 3 3 3 3) (make-f64vector 5 3))
      (test-equiv "f64vector" '(2 1 0 1 2) (f64vector 2 1 0 1 2))
      (test-equiv "unfold up" '(10 11 12 13 14)
                  (f64vector-unfold count-up 5 10))
      (test-equiv "unfold down" '(10 9 8 7 6)
                  (f64vector-unfold count-down 5 10))
      (test-equiv "unfold steady" '(10 10 10 10 10)
                  (f64vector-unfold steady 5 10))
      (test-equiv "unfold-right up" '(14 13 12 11 10)
                  (f64vector-unfold-right count-up 5 10))
      (test-equiv "unfold-right down" '(6 7 8 9 10)
                  (f64vector-unfold-right count-down 5 10))
      (test-equiv "unfold-right steady" '(10 10 10 10 10)
                  (f64vector-unfold-right steady 5 10))
      (test-equiv "copy" '(1 2 3 4 5) (f64vector-copy s5))
      (test-assert "copy2" (not (eqv? s5 (f64vector-copy s5))))
      (test-equiv "copy3" '(2 3) (f64vector-copy s5 1 3))
      (test-equiv "reverse-copy" '(5 4 3 2 1) (f64vector-reverse-copy s5))
      (test-equiv "append" '(1 2 3 4 5 1 2 3 4 5)
                  (f64vector-append s5 s5))
      (test-equiv "concatenate" '(1 2 3 4 5 1 2 3 4 5)
                  (f64vector-concatenate (list s5 s5)))
      (test-equiv "append-subvectors" '(2 3 2 3)
                  (f64vector-append-subvectors s5 1 3 s5 1 3))
      ) ; end f64vector/constructors

    ;; (test-group "f64vector/predicates"
    ;;   (test-assert "f64?" (f64? 5))
    ;;   (test-assert "not f64?" (not (f64? 65536)))
    ;;   (test-assert "f64vector?" (f64vector? s5))
    ;;   (test-assert "not f64vector?" (not (f64vector? #t)))
    ;;   (test-assert "empty" (f64vector-empty? (f64vector)))
    ;;   (test-assert "not empty" (not (f64vector-empty? s5)))
    ;;   (test-assert "=" (f64vector= (f64vector 1 2 3) (f64vector 1 2 3)))
    ;;   (test-assert "= multi" (f64vector= (f64vector 1 2 3)
    ;;                                    (f64vector 1 2 3)
    ;;                                    (f64vector 1 2 3)))
    ;;   (test-assert "not =" (not (f64vector= (f64vector 1 2 3) (f64vector 3 2 1))))
    ;;   (test-assert "not =2" (not (f64vector= (f64vector 1 2 3) (f64vector 1 2))))
    ;;   (test-assert "not = multi" (not (f64vector= (f64vector 1 2 3)
    ;;                                             (f64vector 1 2 3)
    ;;                                             (f64vector 3 2 1))))
    ;;   )
                                        ; end f64vector/predicates

    (test-group "f64vector/selectors"
      (test "ref" 1 (inexact->exact (f64vector-ref (f64vector 1 2 3) 0)))
      (test "length" 3 (f64vector-length (f64vector 1 2 3)))
      ) ; end f64vector/selectors

    (test-group "f64vector/iteration"
      (test-equiv "take" '(1 2) (f64vector-take s5 2))
      (test-equiv "take-right" '(4 5) (f64vector-take-right s5 2))
      (test-equiv "drop" '(3 4 5) (f64vector-drop s5 2))
      (test-equiv "drop-right" '(1 2 3) (f64vector-drop-right s5 2))
      (test "segment" (list (f64vector 1 2 3) (f64vector 4 5))
            (f64vector-segment s5 3))
      (test "fold" -6 (inexact->exact (f64vector-fold - 0 (f64vector 1 2 3))))
      ;; (test "fold" '(((0 1 4) 2 5) 3 6)
      ;;       (f64vector-fold list 0 (f64vector 1 2 3) (f64vector 4 5 6)))
      (test "fold-right" -6 (inexact->exact (f64vector-fold-right - 0 (f64vector 1 2 3))))
      ;; (test "fold-right" '(((0 3 6) 2 5) 1 4)
      ;;       (f64vector-fold-right list 0 (f64vector 1 2 3) (f64vector 4 5 6)))
      (test-equiv "map" '(1 4 9 16 25) (f64vector-map (cut expt <> 2) s5))
      (test-equiv "map" '(0 0 0 0 0) (f64vector-map - s5 s5))
      (let ((v (f64vector 1 2 3 4 5)))
        (f64vector-map! (cut expt <> 2) v)
        (test-equiv "map!" '(1 4 9 16 25) v))
      (let ((v (f64vector 1 2 3 4 5))
            (v2 (f64vector 6 7 8 9 10)))
        (f64vector-map! + v v2)
        (test-equiv "map!" '(7 9 11 13 15) v))
      (let ((list '()))
        (f64vector-for-each
         (lambda (e) (set! list (cons e list)))
         s5)
        ;; stupid hack to shut up test egg about testing the value of a variable
        (test "for-each" '(5 4 3 2 1) (map inexact->exact (cons (car list) (cdr list)))))
      ;; (let ((list '()))
      ;;   (f64vector-for-each
      ;;    (lambda (e1 e2) (set! list (cons (cons e1 e2) list)))
      ;;    s5
      ;;    (f64vector 6 7 8 9 10))
      ;;   ;; stupid hack to shut up test egg about testing the value of a variable
      ;;   (test "for-each" '((5 . 10) (4 . 9) (3 . 8) (2 . 7) (1 . 6))
      ;;         (cons (car list) (cdr list))))
      (test "count" 3 (f64vector-count odd? s5))
      (test "count" 2 (f64vector-count > s5 (f64vector 9 2 1 5 3)))
      (test-equiv "cumulate" '(1 3 6 10 15)
                  (f64vector-cumulate + 0 s5))
      ) ; end f64vector/iteration

    (test-group "f64vector/searching"
      (test-equiv "take-while" '(1) (f64vector-take-while odd? s5))
      (test-equiv "take-while-right" '(5) (f64vector-take-while-right odd? s5))
      (test-equiv "drop-while" '(2 3 4 5) (f64vector-drop-while odd? s5))
      (test-equiv "drop-while-right" '(1 2 3 4) (f64vector-drop-while-right odd? s5))
      ;; (test-equiv "degenerate take-while" '() (f64vector-take-while inexact? s5))
      ;; (test-equiv "degenerate take-while-right" '() (f64vector-take-while-right inexact? s5))
      ;; (test-equiv "degenerate drop-while" '(1 2 3 4 5) (f64vector-drop-while inexact? s5))
      ;; (test-equiv "degenerate drop-while-right" '(1 2 3 4 5) (f64vector-drop-while-right inexact? s5))
      (test "index" 1 (f64vector-index even? s5))
      (test "index" 2 (f64vector-index < s5 (f64vector 0 0 10 10 0)))
      (test "index-right" 3 (f64vector-index-right even? s5))
      (test "index-right" 3 (f64vector-index-right < s5 (f64vector 0 0 10 10 0)))
      (test "skip" 1 (f64vector-skip odd? s5))
      (test "skip" 2 (f64vector-skip > s5 (f64vector 0 0 10 10 0)))
      (test "skip-right" 3 (f64vector-skip-right odd? s5))
      (test "skip-right" 3 (f64vector-skip-right > s5 (f64vector 0 0 10 10 0)))
      (test "any" 4 (inexact->exact (f64vector-any (lambda (x) (and (even? x) (* x 2))) s5)))
      (test-assert "not any" (not (f64vector-any list? s5)))
      (test "any + 1" 2 (inexact->exact (f64vector-any odd+1 s5)))
      (test-assert "every" (f64vector-every number? s5))
      (test-assert "not every" (not (f64vector-every odd? s5)))
      (test-assert "every + 1" (not (f64vector-every odd+1 s5)))
      (test "multi-any" 10 (inexact->exact (f64vector-any (lambda (x y) (and (even? x) (even? y) (+ x y)))
                                                        s5 (f64vector 0 1 2 6 4))))
      (test "multi-any 2" #f (f64vector-any (lambda (x y) (and (even? x) (even? y) (+ x y)))
                                          s5 (f64vector 0 1 2 5 4)))
      (test "multi-every" 10 (inexact->exact (f64vector-every (lambda (x) (and (number? x) (* x 2))) s5)))
      (test "multi-every-2" 10 (inexact->exact (f64vector-every (lambda (x y) (and (number? x) (number? y) (+ x y)))
                                                              s5 s5)))
      (test-assert "multi-not every" (not (f64vector-every < s5 (f64vector 10 10 10 10 0))))
      (test-equiv "partition" '(1 3 5 2 4) (f64vector-partition odd? s5))
      (test-equiv "filter" '(1 3 5) (f64vector-filter odd? s5))
      (test-equiv "remove" '(2 4) (f64vector-remove odd? s5))
      ) ; end f64vector/searching

    (test-group "f64vector/mutators"
      (let ((v (f64vector 1 2 3)))
        ;; (display "set!\n")
        (f64vector-set! v 0 10)
        (test-equiv "set!" '(10 2 3) v))
      (let ((v (f64vector 1 2 3)))
        ;; (display "swap!\n")
        (f64vector-swap! v 0 1)
        (test-equiv "swap!" '(2 1 3) v))
      (let ((v (f64vector 1 2 3)))
        ;; (display "fill!\n")
        (f64vector-fill! v 2)
        (test-equiv "fill!" '(2 2 2) v))
      (let ((v (f64vector 1 2 3)))
        ;; (display "fill2!\n")
        (f64vector-fill! v 10 0 2)
        (test-equiv "fill2!" '(10 10 3) v))
      (let ((v (f64vector 1 2 3)))
        ;; (display "reverse!\n")
        (f64vector-reverse! v)
        (test-equiv "reverse!" '(3 2 1) v))
      (let ((v (f64vector 1 2 3)))
        ;; (display "reverse!\n")
        (f64vector-reverse! v 1 3)
        (test-equiv "reverse2!" '(1 3 2) v))
      (let ((v (f64vector 10 20 30 40 50)))
        ;; (display "copy!\n")
        (f64vector-copy! v 1 s5 2 4)
        (test-equiv "copy!" '(10 3 4 40 50) v))
      (let ((v (f64vector 10 20 30 40 50)))
        ;; (display "reverse-copy!\n")
        (f64vector-reverse-copy! v 1 s5 2 4)
        (test-equiv "reverse-copy!" '(10 4 3 40 50) v))
      (let ((v (f64vector 1 2 3 4 5 6 7 8)))
        ;; (display "unfold!")
        (f64vector-unfold! (lambda (x) (values (* x 2) (* x 2)))
                         v 1 6 1)
        (test-equiv "vector-unfold!" '(1 2 4 8 16 32 7 8) v))
      (let ((v (f64vector 1 2 3 4 5 6 7 8)))
        ;; (display "unfold-right!")
        (f64vector-unfold-right! (lambda (x) (values (* x 2) (* x 2)))
                               v 1 6 1)
        (test-equiv "vector-unfold!" '(1 32 16 8 4 2 7 8) v))
      ) ; end f64vector/mutators

    (test-group "f64vector/conversion"
      (test "f64vector->list 1" '(1 2 3 4 5)
            (map inexact->exact (f64vector->list s5)))
      (test "f64vector->list 2" '(2 3 4 5)
            (map inexact->exact (f64vector->list s5 1)))
      (test "f64vector->list 3" '(2 3 4)
            (map inexact->exact (f64vector->list s5 1 4)))
      (test "f64vector->vector 1" #(1 2 3 4 5)
            (vector-map inexact->exact (f64vector->vector s5)))
      (test "f64vector->vector 2" #(2 3 4 5)
            (vector-map inexact->exact (f64vector->vector s5 1)))
      (test "f64vector->vector 3" #(2 3 4)
            (vector-map inexact->exact (f64vector->vector s5 1 4)))
      (test-equiv "list->f64vector" '(1 2 3 4 5)
                  (list->f64vector '(1 2 3 4 5)))
      (test-equiv "reverse-list->f64vector" '(5 4 3 2 1)
                  (reverse-list->f64vector '(1 2 3 4 5)))
      (test-equiv "vector->f64vector 1" '(1 2 3 4 5)
                  (vector->f64vector #(1 2 3 4 5)))
      (test-equiv "vector->f64vector 2" '(2 3 4 5)
                  (vector->f64vector #(1 2 3 4 5) 1))
      (test-equiv "vector->f64vector 3" '(2 3 4)
                  (vector->f64vector #(1 2 3 4 5) 1 4))
      ) ; end f64vector/conversion

    (test-group "f64vector/misc"
      ;; (let ((port (open-output-string)))
      ;;   (write-f64vector s5 port)
      ;;   (test "write-f64vector" "#f64(1 2 3 4 5)" (get-output-string port))
      ;;   (close-output-port port))

      (test-assert "f64vector< short" (f64vector< s4 s5))
      (test-assert "not f64vector< short" (not (f64vector< s5 s4)))
      (test-assert "f64vector< samelen" (f64vector< s5 s5+))
      (test-assert "not f64vector< samelen" (not (f64vector< s5+ s5+)))
      (test-assert "f64vector=" (f64vector= s5+ s5+))
      (test "f64vector-hash" 15 (f64vector-hash s5))

      (test "f64vector-gen 0" 1 (inexact->exact (g)))
      (test "f64vector-gen 1" 2 (inexact->exact (g)))
      (test "f64vector-gen 2" 3 (inexact->exact (g)))
      (test "f64vector-gen 3" 4 (inexact->exact (g)))
      (test "f64vector-gen 4" 5 (inexact->exact (g)))
      (test-assert (eof-object? (g)))
      ) ; end f64vector/misc

    ) ; end f64vector

  )
(import (srfi 160 c64))

(test-group "c64vector tests"
  (define (times2 x) (* x 2))
  (define s5 (c64vector 1 2 3 4 5))
  (define s4 (c64vector 1 2 3 4))
  (define s5+ (c64vector 1 2 3 4 6))

  (define (steady i x) (values x x))
  (define (count-up i x) (values x (+ x 1)))
  (define (count-down i x) (values x (- x 1)))
  (define (odd+1 x) (if (odd? x) (+ 1 x) #f))
  (define c64vector< (comparator-ordering-predicate c64vector-comparator))
  (define c64vector-hash (comparator-hash-function c64vector-comparator))

  (define g (make-c64vector-generator s5))
  (define-syntax test-equiv
    (syntax-rules ()
      ((test-equiv expect expr)
       (test expect (map inexact->exact (c64vector->list expr))))
      ((test-equiv name expect expr)
       (test name expect (map inexact->exact (c64vector->list expr))))))

  (test-group "c64vector"
    (test-group "c64vector/constructors"
      (test-equiv "make" '(3 3 3 3 3) (make-c64vector 5 3))
      (test-equiv "c64vector" '(2 1 0 1 2) (c64vector 2 1 0 1 2))
      (test-equiv "unfold up" '(10 11 12 13 14)
                  (c64vector-unfold count-up 5 10))
      (test-equiv "unfold down" '(10 9 8 7 6)
                  (c64vector-unfold count-down 5 10))
      (test-equiv "unfold steady" '(10 10 10 10 10)
                  (c64vector-unfold steady 5 10))
      (test-equiv "unfold-right up" '(14 13 12 11 10)
                  (c64vector-unfold-right count-up 5 10))
      (test-equiv "unfold-right down" '(6 7 8 9 10)
                  (c64vector-unfold-right count-down 5 10))
      (test-equiv "unfold-right steady" '(10 10 10 10 10)
                  (c64vector-unfold-right steady 5 10))
      (test-equiv "copy" '(1 2 3 4 5) (c64vector-copy s5))
      (test-assert "copy2" (not (eqv? s5 (c64vector-copy s5))))
      (test-equiv "copy3" '(2 3) (c64vector-copy s5 1 3))
      (test-equiv "reverse-copy" '(5 4 3 2 1) (c64vector-reverse-copy s5))
      (test-equiv "append" '(1 2 3 4 5 1 2 3 4 5)
                  (c64vector-append s5 s5))
      (test-equiv "concatenate" '(1 2 3 4 5 1 2 3 4 5)
                  (c64vector-concatenate (list s5 s5)))
      (test-equiv "append-subvectors" '(2 3 2 3)
                  (c64vector-append-subvectors s5 1 3 s5 1 3))
      ) ; end c64vector/constructors

    ;; (test-group "c64vector/predicates"
    ;;   (test-assert "c64?" (c64? 5))
    ;;   (test-assert "not c64?" (not (c64? 65536)))
    ;;   (test-assert "c64vector?" (c64vector? s5))
    ;;   (test-assert "not c64vector?" (not (c64vector? #t)))
    ;;   (test-assert "empty" (c64vector-empty? (c64vector)))
    ;;   (test-assert "not empty" (not (c64vector-empty? s5)))
    ;;   (test-assert "=" (c64vector= (c64vector 1 2 3) (c64vector 1 2 3)))
    ;;   (test-assert "= multi" (c64vector= (c64vector 1 2 3)
    ;;                                    (c64vector 1 2 3)
    ;;                                    (c64vector 1 2 3)))
    ;;   (test-assert "not =" (not (c64vector= (c64vector 1 2 3) (c64vector 3 2 1))))
    ;;   (test-assert "not =2" (not (c64vector= (c64vector 1 2 3) (c64vector 1 2))))
    ;;   (test-assert "not = multi" (not (c64vector= (c64vector 1 2 3)
    ;;                                             (c64vector 1 2 3)
    ;;                                             (c64vector 3 2 1))))
    ;;   )
                                        ; end c64vector/predicates

    (test-group "c64vector/selectors"
      (test "ref" 1 (inexact->exact (c64vector-ref (c64vector 1 2 3) 0)))
      (test "length" 3 (c64vector-length (c64vector 1 2 3)))
      ) ; end c64vector/selectors

    (test-group "c64vector/iteration"
      (test-equiv "take" '(1 2) (c64vector-take s5 2))
      (test-equiv "take-right" '(4 5) (c64vector-take-right s5 2))
      (test-equiv "drop" '(3 4 5) (c64vector-drop s5 2))
      (test-equiv "drop-right" '(1 2 3) (c64vector-drop-right s5 2))
      (test "segment" (list (c64vector 1 2 3) (c64vector 4 5))
            (c64vector-segment s5 3))
      (test "fold" -6 (inexact->exact (c64vector-fold - 0 (c64vector 1 2 3))))
      ;; (test "fold" '(((0 1 4) 2 5) 3 6)
      ;;       (c64vector-fold list 0 (c64vector 1 2 3) (c64vector 4 5 6)))
      (test "fold-right" -6 (inexact->exact (c64vector-fold-right - 0 (c64vector 1 2 3))))
      ;; (test "fold-right" '(((0 3 6) 2 5) 1 4)
      ;;       (c64vector-fold-right list 0 (c64vector 1 2 3) (c64vector 4 5 6)))
      (test-equiv "map" '(1 4 9 16 25) (c64vector-map (cut expt <> 2) s5))
      (test-equiv "map" '(0 0 0 0 0) (c64vector-map - s5 s5))
      (let ((v (c64vector 1 2 3 4 5)))
        (c64vector-map! (cut expt <> 2) v)
        (test-equiv "map!" '(1 4 9 16 25) v))
      (let ((v (c64vector 1 2 3 4 5))
            (v2 (c64vector 6 7 8 9 10)))
        (c64vector-map! + v v2)
        (test-equiv "map!" '(7 9 11 13 15) v))
      (let ((list '()))
        (c64vector-for-each
         (lambda (e) (set! list (cons e list)))
         s5)
        ;; stupid hack to shut up test egg about testing the value of a variable
        (test "for-each" '(5 4 3 2 1) (map inexact->exact (cons (car list) (cdr list)))))
      ;; (let ((list '()))
      ;;   (c64vector-for-each
      ;;    (lambda (e1 e2) (set! list (cons (cons e1 e2) list)))
      ;;    s5
      ;;    (c64vector 6 7 8 9 10))
      ;;   ;; stupid hack to shut up test egg about testing the value of a variable
      ;;   (test "for-each" '((5 . 10) (4 . 9) (3 . 8) (2 . 7) (1 . 6))
      ;;         (cons (car list) (cdr list))))
      (test "count" 3 (c64vector-count odd? s5))
      (test "count" 2 (c64vector-count > s5 (c64vector 9 2 1 5 3)))
      (test-equiv "cumulate" '(1 3 6 10 15)
                  (c64vector-cumulate + 0 s5))
      ) ; end c64vector/iteration

    (test-group "c64vector/searching"
      (test-equiv "take-while" '(1) (c64vector-take-while odd? s5))
      (test-equiv "take-while-right" '(5) (c64vector-take-while-right odd? s5))
      (test-equiv "drop-while" '(2 3 4 5) (c64vector-drop-while odd? s5))
      (test-equiv "drop-while-right" '(1 2 3 4) (c64vector-drop-while-right odd? s5))
      ;; (test-equiv "degenerate take-while" '() (c64vector-take-while inexact? s5))
      ;; (test-equiv "degenerate take-while-right" '() (c64vector-take-while-right inexact? s5))
      ;; (test-equiv "degenerate drop-while" '(1 2 3 4 5) (c64vector-drop-while inexact? s5))
      ;; (test-equiv "degenerate drop-while-right" '(1 2 3 4 5) (c64vector-drop-while-right inexact? s5))
      (test "index" 1 (c64vector-index even? s5))
      (test "index" 2 (c64vector-index < s5 (c64vector 0 0 10 10 0)))
      (test "index-right" 3 (c64vector-index-right even? s5))
      (test "index-right" 3 (c64vector-index-right < s5 (c64vector 0 0 10 10 0)))
      (test "skip" 1 (c64vector-skip odd? s5))
      (test "skip" 2 (c64vector-skip > s5 (c64vector 0 0 10 10 0)))
      (test "skip-right" 3 (c64vector-skip-right odd? s5))
      (test "skip-right" 3 (c64vector-skip-right > s5 (c64vector 0 0 10 10 0)))
      (test "any" 4 (inexact->exact (c64vector-any (lambda (x) (and (even? x) (* x 2))) s5)))
      (test-assert "not any" (not (c64vector-any list? s5)))
      (test "any + 1" 2 (inexact->exact (c64vector-any odd+1 s5)))
      (test-assert "every" (c64vector-every number? s5))
      (test-assert "not every" (not (c64vector-every odd? s5)))
      (test-assert "every + 1" (not (c64vector-every odd+1 s5)))
      (test "multi-any" 10 (inexact->exact (c64vector-any (lambda (x y) (and (even? x) (even? y) (+ x y)))
                                                        s5 (c64vector 0 1 2 6 4))))
      (test "multi-any 2" #f (c64vector-any (lambda (x y) (and (even? x) (even? y) (+ x y)))
                                          s5 (c64vector 0 1 2 5 4)))
      (test "multi-every" 10 (inexact->exact (c64vector-every (lambda (x) (and (number? x) (* x 2))) s5)))
      (test "multi-every-2" 10 (inexact->exact (c64vector-every (lambda (x y) (and (number? x) (number? y) (+ x y)))
                                                              s5 s5)))
      (test-assert "multi-not every" (not (c64vector-every < s5 (c64vector 10 10 10 10 0))))
      (test-equiv "partition" '(1 3 5 2 4) (c64vector-partition odd? s5))
      (test-equiv "filter" '(1 3 5) (c64vector-filter odd? s5))
      (test-equiv "remove" '(2 4) (c64vector-remove odd? s5))
      ) ; end c64vector/searching

    (test-group "c64vector/mutators"
      (let ((v (c64vector 1 2 3)))
        ;; (display "set!\n")
        (c64vector-set! v 0 10)
        (test-equiv "set!" '(10 2 3) v))
      (let ((v (c64vector 1 2 3)))
        ;; (display "swap!\n")
        (c64vector-swap! v 0 1)
        (test-equiv "swap!" '(2 1 3) v))
      (let ((v (c64vector 1 2 3)))
        ;; (display "fill!\n")
        (c64vector-fill! v 2)
        (test-equiv "fill!" '(2 2 2) v))
      (let ((v (c64vector 1 2 3)))
        ;; (display "fill2!\n")
        (c64vector-fill! v 10 0 2)
        (test-equiv "fill2!" '(10 10 3) v))
      (let ((v (c64vector 1 2 3)))
        ;; (display "reverse!\n")
        (c64vector-reverse! v)
        (test-equiv "reverse!" '(3 2 1) v))
      (let ((v (c64vector 1 2 3)))
        ;; (display "reverse!\n")
        (c64vector-reverse! v 1 3)
        (test-equiv "reverse2!" '(1 3 2) v))
      (let ((v (c64vector 10 20 30 40 50)))
        ;; (display "copy!\n")
        (c64vector-copy! v 1 s5 2 4)
        (test-equiv "copy!" '(10 3 4 40 50) v))
      (let ((v (c64vector 10 20 30 40 50)))
        ;; (display "reverse-copy!\n")
        (c64vector-reverse-copy! v 1 s5 2 4)
        (test-equiv "reverse-copy!" '(10 4 3 40 50) v))
      (let ((v (c64vector 1 2 3 4 5 6 7 8)))
        ;; (display "unfold!")
        (c64vector-unfold! (lambda (x) (values (* x 2) (* x 2)))
                         v 1 6 1)
        (test-equiv "vector-unfold!" '(1 2 4 8 16 32 7 8) v))
      (let ((v (c64vector 1 2 3 4 5 6 7 8)))
        ;; (display "unfold-right!")
        (c64vector-unfold-right! (lambda (x) (values (* x 2) (* x 2)))
                               v 1 6 1)
        (test-equiv "vector-unfold!" '(1 32 16 8 4 2 7 8) v))
      ) ; end c64vector/mutators

    (test-group "c64vector/conversion"
      (test "c64vector->list 1" '(1 2 3 4 5)
            (map inexact->exact (c64vector->list s5)))
      (test "c64vector->list 2" '(2 3 4 5)
            (map inexact->exact (c64vector->list s5 1)))
      (test "c64vector->list 3" '(2 3 4)
            (map inexact->exact (c64vector->list s5 1 4)))
      (test "c64vector->vector 1" #(1 2 3 4 5)
            (vector-map inexact->exact (c64vector->vector s5)))
      (test "c64vector->vector 2" #(2 3 4 5)
            (vector-map inexact->exact (c64vector->vector s5 1)))
      (test "c64vector->vector 3" #(2 3 4)
            (vector-map inexact->exact (c64vector->vector s5 1 4)))
      (test-equiv "list->c64vector" '(1 2 3 4 5)
                  (list->c64vector '(1 2 3 4 5)))
      (test-equiv "reverse-list->c64vector" '(5 4 3 2 1)
                  (reverse-list->c64vector '(1 2 3 4 5)))
      (test-equiv "vector->c64vector 1" '(1 2 3 4 5)
                  (vector->c64vector #(1 2 3 4 5)))
      (test-equiv "vector->c64vector 2" '(2 3 4 5)
                  (vector->c64vector #(1 2 3 4 5) 1))
      (test-equiv "vector->c64vector 3" '(2 3 4)
                  (vector->c64vector #(1 2 3 4 5) 1 4))
      ) ; end c64vector/conversion

    (test-group "c64vector/misc"
      ;; (let ((port (open-output-string)))
      ;;   (write-c64vector s5 port)
      ;;   (test "write-c64vector" "#c64(1 2 3 4 5)" (get-output-string port))
      ;;   (close-output-port port))

      (test-assert "c64vector< short" (c64vector< s4 s5))
      (test-assert "not c64vector< short" (not (c64vector< s5 s4)))
      (test-assert "c64vector< samelen" (c64vector< s5 s5+))
      (test-assert "not c64vector< samelen" (not (c64vector< s5+ s5+)))
      (test-assert "c64vector=" (c64vector= s5+ s5+))
      (test "c64vector-hash" 15 (c64vector-hash s5))

      (test "c64vector-gen 0" 1 (inexact->exact (g)))
      (test "c64vector-gen 1" 2 (inexact->exact (g)))
      (test "c64vector-gen 2" 3 (inexact->exact (g)))
      (test "c64vector-gen 3" 4 (inexact->exact (g)))
      (test "c64vector-gen 4" 5 (inexact->exact (g)))
      (test-assert (eof-object? (g)))
      ) ; end c64vector/misc

    ) ; end c64vector

  )
(import (srfi 160 c128))

(test-group "c128vector tests"
  (define (times2 x) (* x 2))
  (define s5 (c128vector 1 2 3 4 5))
  (define s4 (c128vector 1 2 3 4))
  (define s5+ (c128vector 1 2 3 4 6))

  (define (steady i x) (values x x))
  (define (count-up i x) (values x (+ x 1)))
  (define (count-down i x) (values x (- x 1)))
  (define (odd+1 x) (if (odd? x) (+ 1 x) #f))
  (define c128vector< (comparator-ordering-predicate c128vector-comparator))
  (define c128vector-hash (comparator-hash-function c128vector-comparator))

  (define g (make-c128vector-generator s5))
  (define-syntax test-equiv
    (syntax-rules ()
      ((test-equiv expect expr)
       (test expect (map inexact->exact (c128vector->list expr))))
      ((test-equiv name expect expr)
       (test name expect (map inexact->exact (c128vector->list expr))))))

  (test-group "c128vector"
    (test-group "c128vector/constructors"
      (test-equiv "make" '(3 3 3 3 3) (make-c128vector 5 3))
      (test-equiv "c128vector" '(2 1 0 1 2) (c128vector 2 1 0 1 2))
      (test-equiv "unfold up" '(10 11 12 13 14)
                  (c128vector-unfold count-up 5 10))
      (test-equiv "unfold down" '(10 9 8 7 6)
                  (c128vector-unfold count-down 5 10))
      (test-equiv "unfold steady" '(10 10 10 10 10)
                  (c128vector-unfold steady 5 10))
      (test-equiv "unfold-right up" '(14 13 12 11 10)
                  (c128vector-unfold-right count-up 5 10))
      (test-equiv "unfold-right down" '(6 7 8 9 10)
                  (c128vector-unfold-right count-down 5 10))
      (test-equiv "unfold-right steady" '(10 10 10 10 10)
                  (c128vector-unfold-right steady 5 10))
      (test-equiv "copy" '(1 2 3 4 5) (c128vector-copy s5))
      (test-assert "copy2" (not (eqv? s5 (c128vector-copy s5))))
      (test-equiv "copy3" '(2 3) (c128vector-copy s5 1 3))
      (test-equiv "reverse-copy" '(5 4 3 2 1) (c128vector-reverse-copy s5))
      (test-equiv "append" '(1 2 3 4 5 1 2 3 4 5)
                  (c128vector-append s5 s5))
      (test-equiv "concatenate" '(1 2 3 4 5 1 2 3 4 5)
                  (c128vector-concatenate (list s5 s5)))
      (test-equiv "append-subvectors" '(2 3 2 3)
                  (c128vector-append-subvectors s5 1 3 s5 1 3))
      ) ; end c128vector/constructors

    ;; (test-group "c128vector/predicates"
    ;;   (test-assert "c128?" (c128? 5))
    ;;   (test-assert "not c128?" (not (c128? 65536)))
    ;;   (test-assert "c128vector?" (c128vector? s5))
    ;;   (test-assert "not c128vector?" (not (c128vector? #t)))
    ;;   (test-assert "empty" (c128vector-empty? (c128vector)))
    ;;   (test-assert "not empty" (not (c128vector-empty? s5)))
    ;;   (test-assert "=" (c128vector= (c128vector 1 2 3) (c128vector 1 2 3)))
    ;;   (test-assert "= multi" (c128vector= (c128vector 1 2 3)
    ;;                                    (c128vector 1 2 3)
    ;;                                    (c128vector 1 2 3)))
    ;;   (test-assert "not =" (not (c128vector= (c128vector 1 2 3) (c128vector 3 2 1))))
    ;;   (test-assert "not =2" (not (c128vector= (c128vector 1 2 3) (c128vector 1 2))))
    ;;   (test-assert "not = multi" (not (c128vector= (c128vector 1 2 3)
    ;;                                             (c128vector 1 2 3)
    ;;                                             (c128vector 3 2 1))))
    ;;   )
                                        ; end c128vector/predicates

    (test-group "c128vector/selectors"
      (test "ref" 1 (inexact->exact (c128vector-ref (c128vector 1 2 3) 0)))
      (test "length" 3 (c128vector-length (c128vector 1 2 3)))
      ) ; end c128vector/selectors

    (test-group "c128vector/iteration"
      (test-equiv "take" '(1 2) (c128vector-take s5 2))
      (test-equiv "take-right" '(4 5) (c128vector-take-right s5 2))
      (test-equiv "drop" '(3 4 5) (c128vector-drop s5 2))
      (test-equiv "drop-right" '(1 2 3) (c128vector-drop-right s5 2))
      (test "segment" (list (c128vector 1 2 3) (c128vector 4 5))
            (c128vector-segment s5 3))
      (test "fold" -6 (inexact->exact (c128vector-fold - 0 (c128vector 1 2 3))))
      ;; (test "fold" '(((0 1 4) 2 5) 3 6)
      ;;       (c128vector-fold list 0 (c128vector 1 2 3) (c128vector 4 5 6)))
      (test "fold-right" -6 (inexact->exact (c128vector-fold-right - 0 (c128vector 1 2 3))))
      ;; (test "fold-right" '(((0 3 6) 2 5) 1 4)
      ;;       (c128vector-fold-right list 0 (c128vector 1 2 3) (c128vector 4 5 6)))
      (test-equiv "map" '(1 4 9 16 25) (c128vector-map (cut expt <> 2) s5))
      (test-equiv "map" '(0 0 0 0 0) (c128vector-map - s5 s5))
      (let ((v (c128vector 1 2 3 4 5)))
        (c128vector-map! (cut expt <> 2) v)
        (test-equiv "map!" '(1 4 9 16 25) v))
      (let ((v (c128vector 1 2 3 4 5))
            (v2 (c128vector 6 7 8 9 10)))
        (c128vector-map! + v v2)
        (test-equiv "map!" '(7 9 11 13 15) v))
      (let ((list '()))
        (c128vector-for-each
         (lambda (e) (set! list (cons e list)))
         s5)
        ;; stupid hack to shut up test egg about testing the value of a variable
        (test "for-each" '(5 4 3 2 1) (map inexact->exact (cons (car list) (cdr list)))))
      ;; (let ((list '()))
      ;;   (c128vector-for-each
      ;;    (lambda (e1 e2) (set! list (cons (cons e1 e2) list)))
      ;;    s5
      ;;    (c128vector 6 7 8 9 10))
      ;;   ;; stupid hack to shut up test egg about testing the value of a variable
      ;;   (test "for-each" '((5 . 10) (4 . 9) (3 . 8) (2 . 7) (1 . 6))
      ;;         (cons (car list) (cdr list))))
      (test "count" 3 (c128vector-count odd? s5))
      (test "count" 2 (c128vector-count > s5 (c128vector 9 2 1 5 3)))
      (test-equiv "cumulate" '(1 3 6 10 15)
                  (c128vector-cumulate + 0 s5))
      ) ; end c128vector/iteration

    (test-group "c128vector/searching"
      (test-equiv "take-while" '(1) (c128vector-take-while odd? s5))
      (test-equiv "take-while-right" '(5) (c128vector-take-while-right odd? s5))
      (test-equiv "drop-while" '(2 3 4 5) (c128vector-drop-while odd? s5))
      (test-equiv "drop-while-right" '(1 2 3 4) (c128vector-drop-while-right odd? s5))
      ;; (test-equiv "degenerate take-while" '() (c128vector-take-while inexact? s5))
      ;; (test-equiv "degenerate take-while-right" '() (c128vector-take-while-right inexact? s5))
      ;; (test-equiv "degenerate drop-while" '(1 2 3 4 5) (c128vector-drop-while inexact? s5))
      ;; (test-equiv "degenerate drop-while-right" '(1 2 3 4 5) (c128vector-drop-while-right inexact? s5))
      (test "index" 1 (c128vector-index even? s5))
      (test "index" 2 (c128vector-index < s5 (c128vector 0 0 10 10 0)))
      (test "index-right" 3 (c128vector-index-right even? s5))
      (test "index-right" 3 (c128vector-index-right < s5 (c128vector 0 0 10 10 0)))
      (test "skip" 1 (c128vector-skip odd? s5))
      (test "skip" 2 (c128vector-skip > s5 (c128vector 0 0 10 10 0)))
      (test "skip-right" 3 (c128vector-skip-right odd? s5))
      (test "skip-right" 3 (c128vector-skip-right > s5 (c128vector 0 0 10 10 0)))
      (test "any" 4 (inexact->exact (c128vector-any (lambda (x) (and (even? x) (* x 2))) s5)))
      (test-assert "not any" (not (c128vector-any list? s5)))
      (test "any + 1" 2 (inexact->exact (c128vector-any odd+1 s5)))
      (test-assert "every" (c128vector-every number? s5))
      (test-assert "not every" (not (c128vector-every odd? s5)))
      (test-assert "every + 1" (not (c128vector-every odd+1 s5)))
      (test "multi-any" 10 (inexact->exact (c128vector-any (lambda (x y) (and (even? x) (even? y) (+ x y)))
                                                        s5 (c128vector 0 1 2 6 4))))
      (test "multi-any 2" #f (c128vector-any (lambda (x y) (and (even? x) (even? y) (+ x y)))
                                          s5 (c128vector 0 1 2 5 4)))
      (test "multi-every" 10 (inexact->exact (c128vector-every (lambda (x) (and (number? x) (* x 2))) s5)))
      (test "multi-every-2" 10 (inexact->exact (c128vector-every (lambda (x y) (and (number? x) (number? y) (+ x y)))
                                                              s5 s5)))
      (test-assert "multi-not every" (not (c128vector-every < s5 (c128vector 10 10 10 10 0))))
      (test-equiv "partition" '(1 3 5 2 4) (c128vector-partition odd? s5))
      (test-equiv "filter" '(1 3 5) (c128vector-filter odd? s5))
      (test-equiv "remove" '(2 4) (c128vector-remove odd? s5))
      ) ; end c128vector/searching

    (test-group "c128vector/mutators"
      (let ((v (c128vector 1 2 3)))
        ;; (display "set!\n")
        (c128vector-set! v 0 10)
        (test-equiv "set!" '(10 2 3) v))
      (let ((v (c128vector 1 2 3)))
        ;; (display "swap!\n")
        (c128vector-swap! v 0 1)
        (test-equiv "swap!" '(2 1 3) v))
      (let ((v (c128vector 1 2 3)))
        ;; (display "fill!\n")
        (c128vector-fill! v 2)
        (test-equiv "fill!" '(2 2 2) v))
      (let ((v (c128vector 1 2 3)))
        ;; (display "fill2!\n")
        (c128vector-fill! v 10 0 2)
        (test-equiv "fill2!" '(10 10 3) v))
      (let ((v (c128vector 1 2 3)))
        ;; (display "reverse!\n")
        (c128vector-reverse! v)
        (test-equiv "reverse!" '(3 2 1) v))
      (let ((v (c128vector 1 2 3)))
        ;; (display "reverse!\n")
        (c128vector-reverse! v 1 3)
        (test-equiv "reverse2!" '(1 3 2) v))
      (let ((v (c128vector 10 20 30 40 50)))
        ;; (display "copy!\n")
        (c128vector-copy! v 1 s5 2 4)
        (test-equiv "copy!" '(10 3 4 40 50) v))
      (let ((v (c128vector 10 20 30 40 50)))
        ;; (display "reverse-copy!\n")
        (c128vector-reverse-copy! v 1 s5 2 4)
        (test-equiv "reverse-copy!" '(10 4 3 40 50) v))
      (let ((v (c128vector 1 2 3 4 5 6 7 8)))
        ;; (display "unfold!")
        (c128vector-unfold! (lambda (x) (values (* x 2) (* x 2)))
                         v 1 6 1)
        (test-equiv "vector-unfold!" '(1 2 4 8 16 32 7 8) v))
      (let ((v (c128vector 1 2 3 4 5 6 7 8)))
        ;; (display "unfold-right!")
        (c128vector-unfold-right! (lambda (x) (values (* x 2) (* x 2)))
                               v 1 6 1)
        (test-equiv "vector-unfold!" '(1 32 16 8 4 2 7 8) v))
      ) ; end c128vector/mutators

    (test-group "c128vector/conversion"
      (test "c128vector->list 1" '(1 2 3 4 5)
            (map inexact->exact (c128vector->list s5)))
      (test "c128vector->list 2" '(2 3 4 5)
            (map inexact->exact (c128vector->list s5 1)))
      (test "c128vector->list 3" '(2 3 4)
            (map inexact->exact (c128vector->list s5 1 4)))
      (test "c128vector->vector 1" #(1 2 3 4 5)
            (vector-map inexact->exact (c128vector->vector s5)))
      (test "c128vector->vector 2" #(2 3 4 5)
            (vector-map inexact->exact (c128vector->vector s5 1)))
      (test "c128vector->vector 3" #(2 3 4)
            (vector-map inexact->exact (c128vector->vector s5 1 4)))
      (test-equiv "list->c128vector" '(1 2 3 4 5)
                  (list->c128vector '(1 2 3 4 5)))
      (test-equiv "reverse-list->c128vector" '(5 4 3 2 1)
                  (reverse-list->c128vector '(1 2 3 4 5)))
      (test-equiv "vector->c128vector 1" '(1 2 3 4 5)
                  (vector->c128vector #(1 2 3 4 5)))
      (test-equiv "vector->c128vector 2" '(2 3 4 5)
                  (vector->c128vector #(1 2 3 4 5) 1))
      (test-equiv "vector->c128vector 3" '(2 3 4)
                  (vector->c128vector #(1 2 3 4 5) 1 4))
      ) ; end c128vector/conversion

    (test-group "c128vector/misc"
      ;; (let ((port (open-output-string)))
      ;;   (write-c128vector s5 port)
      ;;   (test "write-c128vector" "#c128(1 2 3 4 5)" (get-output-string port))
      ;;   (close-output-port port))

      (test-assert "c128vector< short" (c128vector< s4 s5))
      (test-assert "not c128vector< short" (not (c128vector< s5 s4)))
      (test-assert "c128vector< samelen" (c128vector< s5 s5+))
      (test-assert "not c128vector< samelen" (not (c128vector< s5+ s5+)))
      (test-assert "c128vector=" (c128vector= s5+ s5+))
      (test "c128vector-hash" 15 (c128vector-hash s5))

      (test "c128vector-gen 0" 1 (inexact->exact (g)))
      (test "c128vector-gen 1" 2 (inexact->exact (g)))
      (test "c128vector-gen 2" 3 (inexact->exact (g)))
      (test "c128vector-gen 3" 4 (inexact->exact (g)))
      (test "c128vector-gen 4" 5 (inexact->exact (g)))
      (test-assert (eof-object? (g)))
      ) ; end c128vector/misc

    ) ; end c128vector

  )
(test-end)
(test-exit)
