=== Module (srfi 160 @)
==== Constructors
<procedure>(make-@vector size [fill]) -> @vector</procedure>

Returns a {{@vector}} whose length is size. If fill is provided, all the elements of the {{@vector}} are initialized to it.

<procedure>(@vector value ...) -> @vector</procedure>

Returns a {{@vector}} initialized with values.

<procedure>(@vector-unfold f length seed) -> @vector</procedure>

Creates a vector whose length is length and iterates across each index {{k}} between 0 and {{length - 1}}, applying {{f}} at each iteration to the current index and current state, in that order, to receive two values: the element to put in the kth slot of the new vector and a new state for the next iteration. On the first call to {{f}}, the state's value is seed.

<procedure>(@vector-unfold-right f length seed) -> @vector</procedure>

The same as @vector-unfold, but initializes the {{@vector}} from right to left.

<procedure>(@vector-copy @vec [start [end]]) -> @vector</procedure>

Makes a copy of the portion of {{@vec}} from {{start}} to {{end}} and returns it.

<procedure>(@vector-reverse-copy @vec [start [end]]) -> @vector</procedure>

The same as {{@vector-copy}}, but in reverse order.

<procedure>(@vector-append @vec ...) -> @vector</procedure>

Returns a {{@vector}} containing all the elements of the {{@vecs}} in order.

<procedure>(@vector-concatenate list-of-@vectors) -> @vector</procedure>

The same as {{@vector-append}}, but takes a list of {{@vectors}} rather than multiple arguments.

<procedure>(@vector-append-subvectors [@vec start end] ...) -> @vector</procedure>

Concatenates the result of applying {{@vector-copy}} to each triplet of {{@vec}}, {{start}}, {{end}} arguments, but may be implemented more efficiently.
==== Predicates
<procedure>(@? obj) -> boolean</procedure>

Returns {{#t}} if obj is a valid element of an {{@vector}}, and {{#f}} otherwise.

<procedure>(@vector? obj) -> boolean</procedure>

Returns {{#t}} if obj is a {{@vector}}, and {{#f}} otherwise.

<procedure>(@vector-empty? @vec) -> boolean</procedure>

Returns {{#t}} if {{@vec}} has a length of zero, and {{#f}} otherwise.

<procedure>(@vector= @vec ...) -> boolean</procedure>

Compares the {{@vecs}} for elementwise equality, using = to do the comparisons. Returns {{#f}} unless all {{@vectors}} are the same length.
==== Selectors
<procedure>(@vector-ref @vec i) -> value</procedure>

Returns the ith element of {{@vec}}.

<procedure>(@vector-length @vec) -> exact nonnegative integer</procedure>

Returns the length of {{@vec}}
==== Iteration
<procedure>(@vector-take @vec n) -> @vector] [SRFI 152]</procedure>

<procedure>(@vector-take-right @vec n) -> @vector [SRFI 152]</procedure>

Returns a {{@vector}} containing the first/last {{n}} elements of {{@vec}}.

<procedure>(@vector-drop @vec n) -> @vector [SRFI 152]</procedure>

<procedure>(@vector-drop-right @vec n) -> @vector [SRFI 152]</procedure>

Returns a {{@vector}} containing all except the first/last {{n}} elements of {{@vec}}.

<procedure>(@vector-segment @vec n) -> list [SRFI 152]</procedure>

Returns a list of {{@vectors}}, each of which contains n consecutive elements of {{@vec}}. The last {{@vector}} may be shorter than {{n}}.

<procedure>(@vector-fold kons knil @vec @vec2 ...) -> object</procedure>

<procedure>(@vector-fold-right kons knil @vec @vec2 ...) -> object</procedure>

When one {{@vector}} argument {{@vec}} is given, folds {{kons}} over the elements of {{@vec}} in increasing/decreasing order using {{knil}} as the initial value. The {{kons}} procedure is called with the state first and the element second, as in SRFIs 43 and 133 (heterogeneous vectors). This is the opposite order to that used in SRFI 1 (lists) and the various string SRFIs.

When multiple {{@vector}} arguments are given, {{kons}} is called with the current state value and each value from all the vectors; {{@vector-fold}} scans elements from left to right, while {{@vector-fold-right}} does from right to left. If the lengths of vectors differ, only the portion of each vector up to the length of the shortest vector is scanned.

<procedure>(@vector-map f @vec @vec2 ...) -> @vector</procedure>

<procedure>(@vector-map! f @vec @vec2 ...) -> unspecified</procedure>

<procedure>(@vector-for-each f @vec @vec2 ...) -> unspecified</procedure>

Iterate over the elements of {{@vec}} and apply {{f}} to each, returning respectively a {{@vector}} of the results, an undefined value with the results placed back in {{@vec}}, and an undefined value with no change to {{@vec}}.

If more than one vector is passed, {{f}} gets one element from each vector as arguments. If the lengths of the vectors differ, iteration stops at the end of the shortest vector. For {{@vector-map!}}, only {{@vec}} is modified even when multiple vectors are passed.

If {{@vector-map}} or {{@vector-map!}} returns more than once (i.e. because of a continuation captured by {{f}}), the values returned or stored by earlier returns may be mutated.

<procedure>(@vector-count pred? @vec @vec2 ...) -> exact nonnegative integer</procedure>

Call {{pred?}} on each element of {{@vec}} and return the number of calls that return true.

When multiple vectors are given, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are given for each iteration, which stops at the end of the shortest vector.

<procedure>(@vector-cumulate f knil @vec) -> @vector</procedure>

Like {{@vector-fold}}, but returns an {{@vector}} of partial results rather than just the final result.
==== Searching
<procedure>(@vector-take-while pred? @vec) -> @vector [SRFI 152]</procedure>

<procedure>(@vector-take-while-right pred? @vec) -> @vector [SRFI 152]</procedure>

Return the shortest prefix/suffix of {{@vec}} all of whose elements satisfy {{pred?}}.

<procedure>(@vector-drop-while pred? @vec) -> @vector [SRFI 152]</procedure>

<procedure>(@vector-drop-while-right pred? @vec) -> @vector [SRFI 152]</procedure>

Drops the longest initial prefix/suffix of {{@vec}} such that all its elements satisfy pred.

<procedure>(@vector-index pred? @vec @vec2 ...) -> exact nonnegative integer or #f</procedure>

<procedure>(@vector-index-right pred? @vec @vec2 ...) -> exact nonnegative integer or #f</procedure>

Return the index of the first/last element of {{@vec}} that satisfies {{pred?}}.

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are passed for each iteration. If the lengths of vectors differ, {{@vector-index}} stops iteration at the end of the shortest one. Lengths of vectors must be the same for {{@vector-index-right}}.

<procedure>(@vector-skip pred? @vec @vec2 ...) -> exact nonnegative integer or #f</procedure>

<procedure>(@vector-skip-right pred? @vec @vec2 ...) -> exact nonnegative integer or #f</procedure>

Returns the index of the first/last element of {{@vec}} that does not satisfy {{pred?}}.

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are passed for each iteration. If the lengths of vectors differ, {{@vector-skip}} stops iteration at the end of the shortest one. Lengths of vectors must be the same for {{@vector-skip-right}}.

<procedure>(@vector-any pred? @vec @vec2 ...) -> value or boolean</procedure>

Returns first non-false result of applying {{pred?}} on a element from the {{@vec}}, or {{#f}} if there is no such element. If {{@vec}} is empty, returns #t

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector are passed for each iteration. If the lengths of vectors differ, it stops at the end of the shortest one.

<procedure>(@vector-every pred? @vec @vec2 ...) -> value or boolean</procedure>

If all elements from {{@vec}} satisfy {{pred?}}, return the last result of {{pred?}}. If not all do, return {{#f}}. If {{@vec}} is empty, return #t

When multiple vectors are passed, {{pred?}} must take the same number of arguments as the number of vectors, and corresponding elements from each vector is passed for each iteration. If the lengths of vectors differ, it stops at the end of the shortest one.

<procedure>(@vector-partition pred? @vec) -> @vector and integer</procedure>

Returns an {{@vector}} of the same type as {{@vec}}, but with all elements satisfying {{pred?}} in the leftmost part of the vector and the other elements in the remaining part. The order of elements is otherwise preserved. Returns two values, the new {{@vector}} and the number of elements satisfying {{pred?}}.

<procedure>(@vector-filter pred? @vec) -> @vector [SRFI 152]</procedure>

<procedure>(@vector-remove pred? @vec) -> @vector [SRFI 152]</procedure>

Return an {{@vector}} containing the elements of {{@vec}} that satisfy / do not satisfy {{pred?}}.
==== Mutators
<procedure>(@vector-set! @vec i value) -> unspecified</procedure>

Sets the ith element of {{@vec}} to value.

<procedure>(@vector-swap! @vec i j) -> unspecified</procedure>

Interchanges the ith and jth elements of {{@vec}}.

<procedure>(@vector-fill! @vec fill [start [end]]) -> unspecified</procedure>

Fills the portion of {{@vec}} from {{start}} to {{end}} with the value fill.

<procedure>(@vector-reverse! @vec [start [end]]) -> unspecified</procedure>

Reverses the portion of {{@vec}} from {{start}} to {{end}}.

<procedure>(@vector-copy! @to at @from [start [end]]) -> unspecified</procedure>

Copies the portion of {{@from}} from {{start}} to {{end}} onto {{@to}}, starting at index at.

<procedure>(@vector-reverse-copy! @to at @from [start [end]]) -> unspecified</procedure>

The same as {{@vector-copy!}}, but copies in reverse.

<procedure>(@vector-unfold! f @vec start end seed) -> @vector</procedure>

Like vector-unfold, but the elements are copied into the vector {{@vec}} starting at element {{start}} rather than into a newly allocated vector. Terminates when {{end}} - {{start}} elements have been generated.

<procedure>(@vector-unfold-right! f @vec start end seed) -> @vector</procedure>

The same as {{@vector-unfold!}}, but initializes the {{@vector}} from right to left.
==== Conversion
<procedure>(@vector->list @vec [start [end]]) -> proper-list</procedure>

<procedure>(reverse-@vector->list @vec [start [end]]) -> proper-list</procedure>

<procedure>(list->@vector proper-list) -> @vector</procedure>

<procedure>(reverse-list->@vector proper-list) -> @vector</procedure>

<procedure>(@vector->vector @vec [start [end]]) -> vector</procedure>

<procedure>(vector->@vector vec [start [end]]) -> @vector</procedure>

Returns a list, {{@vector}}, or heterogeneous vector with the same elements as the argument, in reverse order where specified.
==== Generators
<procedure>(make-@vector-generator @vector)</procedure>

Returns a [[https://srfi.schemers.org/srfi-121/srfi-121.html][SRFI 121]] generator that generates all the values of {{@vector}} in order. Note that the generator is finite.
==== Comparators
{{@vector-comparator}}

Variable containing a [[https://srfi.schemers.org/srfi-128/srfi-128.html][SRFI 128]] comparator whose components provide ordering and hashing of {{@vectors}}.
==== Output
<procedure>(write-@vector @vec [ port ] ) -> unspecified</procedure>

Prints to port (the current output port by default) a representation of {{@vec}} in the lexical syntax explained below.
